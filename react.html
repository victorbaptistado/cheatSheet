<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="./component/button.js" defer></script>
        <title>React</title>
    </header>
    <body>
        <nav>
            <ul class="mainNav">
                <li><a href="./index.html">Cheat Sheet</a></li>
                <li><a href="./displayProperties.html">Display Properties</a></li>
                <li><a href="./objects.html">Objects</a></li>
                <li><a href="./developmentCycle.html">Development Cycle</a></li>
                <li><a href="./debug.html">Debug</a></li>
                <li><a href="./git.html">Git</a></li>
                <li><a href="./form.html">Form</a></li>
                <li><a href="./api.html">API</a></li>
                <li><a href="#">REACT</a></li>                 
            </ul>
        </nav>
        <header>
            <h1>React</h1>
        </header>
        <div class="styleGuide">
            <h2>Virtual DOM</h2>
            <ul>
                <li><strong>Virtual DOM (VDOM)</strong> is React’s local and simplified copy of the HTML DOM. 
                A programming concept where an ideal, or “virtual”, 
                representation of a UI is kept in memory and synced with the “real” DOM by a library 
                such as ReactDOM.</li>
                <li>When you render a JSX element, every single virtual DOM object gets updated.
                This sounds incredibly inefficient, but the cost is insignificant because the virtual DOM 
                can update so quickly.</li>
                <li>Once the virtual DOM has updated, then React compares 
                the virtual DOM with a virtual DOM snapshot that was taken right before the update.
                By comparing the new virtual DOM with a pre-update version, React figures out exactly 
                which virtual DOM objects have changed. This process is called “diffing.”</li>
                <li>Once React knows which virtual DOM objects have changed, then React updates 
                those objects, and only those objects, on the real DOM. In our example from</li>
            </ul>
            <hr/>
            <h3>JSX</h3>
            <ul>
                <li>JSX (JavaScript XML) allows us to write HTML elements in JavaScript 
                and place them in the DOM without any createElement() and/or appendChild() methods.
                JSX converts HTML tags into react elements.</li>
                <li>To render <strong>logic</strong>, if we want any expression to be treated as 
                JavaScript inside of a JSX element we need to wrap it in curly braces.</li>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Often used in React</h2>
            <h3>Destructuring</h3>
            <ul>
                <li>React relies on many destructuring techniques.</li>
                <li>Destructuring, or destructuring assignment, is a JavaScript feature that makes it 
                easier to extract data from arrays and objects and assign them to variables or parameters. 
                Is a syntactic sugar introduced in the ES6 version of JavaScript.</li>
                <p class="center"><strong>Array destructuring</strong>, <strong>Object destructuring</strong>,
                <strong>Function Parameters destructuring</strong></strong></p>
                <button id="showCode16" onclick="showCode('displayCode16', 'showCode16')">Display</button>
                <div id="displayCode16">
                    <button onclick="closeCode('displayCode16', 'showCode16')">Close</button>
                    <pre>
                        <code>
                        //Array Destructuring
                        let cars = ['ferrari', 'tesla', 'cadillac'];
                        let [car1, car2, car3] = cars;
                        console.log(car1, car2, car3); // Prints: ferrari tesla cadillac
                        </code>
                    </pre>
                    <pre>
                        <code>
                        //Object Destructuring
                        let destinations = { x: 'LA', y: 'NYC', z: 'MIA' };
                        let { x, y, z } = destinations;
                        console.log(x, y, z); // Prints LA NYC MIA
                        </code>
                    </pre>
                    <pre>
                        <code>
                        //Destructuring Function Parameters (Function arguments are another place 
                        where destructuring is useful. Instead of accepting a complete object as 
                        an argument, a function can use destructuring to capture specific properties 
                        as named parameters.

                        let truck = {
                        model: '1977 Mustang convertible',
                        city: 'Detroit',
                        convertible: true
                        };
                        
                        const printCarInfo = ({model, city}) => {
                        console.log(`The ${model} is in the city ${city}.`);
                        };
                        </code>
                    </pre>
                </div>
            </ul>
            <hr/>
            <h3>Ternary and && conditionals</h3>
            <pre>
                <code>
                // Ternary, to output a condition if valued true, otherwise another will be set. 

                {!judgmental ? 
                    < li > Nacho Cheez Straight Out The Jar < /li > : < li > Second option < /li >
                }
                </code>
            </pre>
            <pre>
                <code>
                // && conditional, to use if a single condition is set to appear or not.

                {!judgmental && 
                    < li >Nacho Cheez Straight Out The Jar < /li >
                }
                </code>
            </pre>
            <hr/>
            <h3>.map</h3>
            <ul>
                <li>To create a list of JSX elements .map() is often your best bet.</li>
                <li><strong>Keys</strong>: Not all lists need to have keys. 
                A list needs keys if:
                <ul>
                    <li>The list-items have memory from one render to the next. 
                    For instance, when a to-do list renders, each item must “remember” 
                    whether it was checked off.
                    </li> 
                    <li>The items shouldn’t get amnesia when they render.
                    A list’s order might be shuffled. For instance, a list of search results 
                    might be shuffled from one render to the next.
                    </li>
                </ul>
            </ul>
            <p class="center"></p>
            <button id="showCode17" onclick="showCode('displayCode17', 'showCode17')">Display</button>
            <div id="displayCode17">
                <button onclick="closeCode('displayCode17', 'showCode17')">Close</button>
                <pre>
                    <code>
                    const strings = ['Home', 'Shop', 'About Me'];
                    const listItems = strings.map(string => < li >{string} < /li >);

                    < ul > {listItems} < /ul >

                    //using Key

                    const peopleLis = people.map((person, i) =>
                    < li key={'person_' + i} > {person} < /li >
                    );
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>Variable Attribute in a Component</h3>
            <li>We can use variables, including object properties, to set a component’s attributes 
            to keep component easy to read and organized, but more importantly, 
            so that our attributes can be dynamic and/or can be changed easily!</li>
            <button id="showCode18" onclick="showCode('displayCode18', 'showCode18')">Display</button>
            <div id="displayCode18">
                <button onclick="closeCode('displayCode18', 'showCode18')">Close</button>
                <pre>
                    <code>
                        const redPanda = {
                            src: 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Endangered_Red_Panda.jpg',
                            alt: 'Red Panda',
                            width:  '200px'
                        };
                        
                        class RedPanda extends React.Component {
                            render() {
                            return (
                                < div >
                                < h1 >Cute Red Panda< /h1 >
                                < img 
                                    src={redPanda.src}
                                    alt={redPanda.alt}
                                    width={redPanda.width} />
                                < /div >
                            );
                            }
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>Event handler</h3>
            <ul>
                <li><strong>Multiple event handler</strong>: By passing an anonymous function, 
                or a named function, 
                with multiple event handler calls as the function body, to our event listener 
                (like onClick, onKeyUp, onChange, etc) 
                we can call multiple event handlers in response to a single event.</li>
            </ul>
            <pre>
                <code>
                return (
                //Underneath, an anonymous function with multiple event handlers.
                    < button onClick={() => {         
                        this.eventHandler1();
                        this.eventHandler2();
                    }}>Here's a button!</ button> 
                )
                </code>
            </pre>
            <hr/>
        </div>
        <div class="styleGuide">
            <h2>Aditional Algorithms</h2>
            <ul><li>
                <div class="flex">
                        <p>Auth & password Conditional</p>
                        <button id="showCode19" onclick="showCode('displayCode19', 'showCode19')">Display</button>
                </div>
            </li></ul>
            <div id="displayCode19">
                <button onclick="closeCode('displayCode19', 'showCode19')">Close</button>
            <pre>
                <code>
                    class Contact extends React.Component {
                        constructor(props) {
                          super(props);
                          this.state = {
                            password: 'swordfish',
                            authorized: false
                          };
                          this.authorize = this.authorize.bind(this);
                        }
                      
                        authorize(e) {
                          const password = e.target.querySelector(
                            'input[type="password"]').value;
                          const auth = password == this.state.password;
                          this.setState({
                            authorized: auth
                          });
                        }
                      
                        render() {
                          let login = (
                            < form action="#" >
                              < input type='password' placeholder='Password' />
                              < input type='submit' onSubmit={this.authorize} />
                            < /form >
                            );
                          let contactInfo = (
                              < ul >
                                < li >
                                  client@example.com
                                < /li >
                                < li >
                                  555.555.5555
                                < /li >
                              < /ul >
                          );
                      
                          return (
                            < div id="authorization" >
                              < h1 >{this.state.authorized ? "Contact" : "Enter the Password"}< /h1 >
                              {this.state.authorized ? contactInfo : login}
                            < /div >
                          );
                        }
                      }                      
                </code>
            </pre>
            </div>
        </div>
        <div class="styleGuide">
            <h2>State</h2>
            <ul>
            <li>A React app is basically just a lot of <strong>components</strong>, setting <strong>state</strong> and passing <strong>props</strong> to one another.</li>
            <li>There are two ways for a component to get dynamic 
            information: <strong>props</strong> and <strong>state</strong>. Besides props and state, 
            every value used in a component should always stay exactly 
            the same.</li>
            <li>A <strong>programming pattern</strong> uses two React components: a <strong>stateful 
            component</strong>, and a <strong>stateless component</strong>. “Stateful” describes any 
            component that has a state property; “stateless” describes any component that does not.</li>
            <li>Components should only have <strong>one job</strong>.
            You should divide child in two: one will have one stateless component <strong>display information</strong>, 
            and a different stateless component offer the ability to <strong>change that information</strong>. e.g: A Video Player & a Menu to change its settings.</li>
            <li><strong>How does a component change its props?</strong> The answer: it doesn’t!
            A component should never update this.props.
            A React component should use props to store information that 
            can be changed, but can only be changed by a different component.
            A React component should use state to store information that 
            the component itself can change.</li>
            </ul>
            <p class="center">Forms of <strong>Components Update Parents'</strong> state</p>
            <button id="showCode20" onclick="showCode('displayCode20', 'showCode20')">Display</button>
            <div id="displayCode20">
                <button onclick="closeCode('displayCode20', 'showCode20')">Close</button>
                <ul>
                    <li><p>The parent component class defines a method that calls this.setState().</p>
                    </li>
                    <li><p>The parent component binds the newly-defined method to the current 
                        instance of the component in its constructor. This ensures that when 
                        we pass the method to the child component, it will still update the 
                        parent component. </p>
                    </li>
                    <li><p>The child receives the passed-down function, and uses it as an event handler.
                        When a user clicks on the < button > < /button >, a click event 
                        will fire. This will make the passed-down function get called, which will update 
                        the parent’s state.</p>
                    </li>
                        <pre>
                            <code>                              
                            class ParentClass extends React.Component {
                                constructor(props) {
                                    super(props);
                                    this.state = { totalClicks: 0 };
                                    this.handleClick = this.handleClick.bind(this);
                                }
                            
                                handleClick() {
                                    const total = this.state.totalClicks;
                                
                                    // calling handleClick will 
                                    // result in a state change:
                                    this.setState(
                                        { totalClicks: total + 1 }
                                    );
                                }
                            
                                // The stateful component class passes down
                                // handleClick to a stateless component class:
                                render() {
                                    return (
                                        < ChildClass onClick={this.handleClick} />
                                    );
                                }
                            } 
                            </code>
                        </pre>
                    </li>
                    <li><p>The child receives the passed-down function, and uses it as an event handler.
                        When a user clicks on the < button></button >, a click event will fire. This will make the passed-down function get called, which will update the parent’s state.</p>
                        <pre>
                            <code>
                            export class ChildClass extends React.Component {
                                render() {
                                    return (
                                    // The stateless component class uses
                                    // the passed-down handleClick function,
                                    // accessed here as this.props.onClick,
                                    // as an event handler:
                                    < button onClick={this.props.onClick}>
                                        Click Me!
                                    < /button >
                                    );
                                }
                            }
                            </code>
                        </pre>
                    </li>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>React's Lifecycle</h2>
            <ul>
                <li>The first phase of a component’s lifecycle is the <strong>Mounting phase</strong>. 
                    This is when a component is created and inserted into the DOM. The methods that run 
                    during this phase, in order, are:</li>
                <pre>
                    <code>
                    componentWillMount()
                    constructor()
                    render()
                    componentDidMount()
                    </code>
                </pre>
                <li>
                    The next phase of a component’s lifecycle is the <strong>Updating phase</strong>. 
                    This is when a component undergoes any changes to props or state. This phase is the main part of a 
                    component’s life, and the following methods will be 
                    invoked repeatedly at each change,
                </li>
                <pre>
                    <code>
                    componentWillReceiveProps()
                    shouldComponentUpdate()
                    render()
                    componentDidUpdate()
                    </code>
                </pre>
                <li>
                    The last phase of a component’s lifecycle is <strong>Unmounting</strong>. This is when 
                    component is removed from the DOM, and the only method run during this phase is
                </li>
                <pre>
                    <code>
                    componentWillUnmount().
                    </code>
                </pre>
                <li><strong>Side effects</strong> should be separated from the rendering process. 
                If we need to perform a side effect, it should strictly be done after our component renders.
                This is what useEffect gives us.
                In short, useEffect is a tool that lets us interact with the outside 
                world but not affect the rendering or performance of the component that it's in.</li>
                <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank">Lifecycle's interactive diagram.</a>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Hooks</h2>
            <ul>
                <li><strong>React Hooks</strong> are functions that let us manage the internal state of 
                components and handle post-rendering side effects directly from our function components. 
                Hooks don’t work inside classes — they let us use fancy React features without classes.</li> 
                <li>Keep in mind that <u>function components and React Hooks do not replace class components.</u> 
                They are completely optional; just a new tool that we can take advantage of.</li>
                <li>Hooks let us “hook into” state and lifecycle features directly from our function components.</li>
            </ul>
            <hr/>
            <h3>Function component</h3>
            <ul>
                <li><strong>Function components</strong> are React components defined as JavaScript functions that must return JSX.
                They may accept a props parameter (expect it to be a JavaScript object).</li>
                <li>Although <strong>function components</strong> and <strong>class components</strong> can do the same things, 
                some developers prefer function components over class components for their simplicity and straightforward features, 
                like Hooks.</li>
            </ul>
            <p class="center">Function component example:</p>
            <button id="showCode21" onclick="showCode('displayCode21', 'showCode21')">Display</button>
            <div id="displayCode21">
                <button onclick="closeCode('displayCode21', 'showCode21')">Close</button>
                <pre>
                    <code>
                        export class MyComponentClass extends React.Component {
                            render() {
                            return < h1 >Hello world< /h1 >;
                            }
                        }
                        
                        // The same component class, written as a stateless functional component:
                        export const MyComponentClass = () => {
                            return < h1 >Hello world< /h1 >;
                        }
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>HOOKs list</h3>
            <ul>
                <li><strong>useState(): </strong>Updates state.</li>
                    <ul>
                        <li>Can be used with callbacks to update previous states 
                        (and setCount for example).</li>
                        <li>Use arrays and objects to organize and manage related data 
                        that tends to change together</li>
                    </ul>
                <p class="center"><strong>useState</strong>, <strong>Previous State</strong>, 
                <strong>Array in State</strong> & <strong>Object in State</strong> example:</p>
                <button id="showCode22" onclick="showCode('displayCode22', 'showCode22')">Display</button>
                <div id="displayCode22">
                <button onclick="closeCode('displayCode22', 'showCode22')">Close</button>
                <ul>
                    <li><strong>useState</strong></li>
                    <pre>
                        <code>                       
                        function Toggle() {
                            const [toggle, setToggle] = useState();
                            
                            return (
                                < div >
                                    < p > The toggle is {toggle} < / p >
                                    < button onClick={() => setToggle("On")}> On < / button>
                                    < button onClick={() => setToggle("Off")}> Off < / button>
                                < /div >
                            );
                        }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Previous State callback</strong></li>
                    <pre>
                        <code>                       
                        export default function Counter() {
                            const [count, setCount] = useState(0);
                        
                            const increment = () => setCount(prevCount => prevCount + 1);
                        
                            return (
                                < div >
                                    < p >Wow, you've clicked that button: {count} times < /p >
                                    < button onClick={increment}>Click here! < /button >
                                < /div >
                            );
                        }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Arrays in State:</strong>The best data model for managing and rendering JSX lists.</li>
                    <pre>
                        <code>
                        const options = ["Bell Pepper", "Sausage", "Pepperoni", "Pineapple"];

                        export default function PersonalPizza() {
                        const [selected, setSelected] = useState([]);
                        
                        const toggleTopping = ({target}) => {
                            const clickedTopping = target.value;
                            setSelected((prev) => {
                                // check if clicked topping is already selected
                                if (prev.includes(clickedTopping)) {
                                    // filter the clicked topping out of state
                                    return prev.filter(t => t !== clickedTopping);
                                } else {
                                    // add the clicked topping to our state
                                    return [clickedTopping, ...prev];
                                }
                            });
                        };
                        
                        return (
                            < div >
                                {options.map(option => (
                                    < button value={option} onClick={toggleTopping} key={option} >
                                    {selected.includes(option) ? "Remove " : "Add "}
                                    {option}
                                    < /button >
                            ))}
                            < p > Order a {selected.join(", ")} pizza < /p >
                            </ div >
                        );
                        }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Objects in State:</strong> When we work with a set of related variables, 
                    it can be very helpful to group them in an object. Let’s look at an example!</li>
                    <pre>
                        <code>
                        export default function Login() {
                        const [formState, setFormState] = useState({});
                        
                        const handleChange = ({ target }) => {
                            const { name, value } = target;
                            setFormState((prev) => ({
                            ...prev,
                            [name]: value
                            }));
                        };

                        return (
                            < form >
                            < input
                                value={formState.firstName}
                                onChange={handleChange}
                                name="firstName"
                                type="text"
                            />
                            < input
                                value={formState.password}
                                onChange={handleChange}
                                type="password"
                                name="password"
                            />
                            < /form >
                        );
                        }
                        </code>
                    </pre>
                </ul>
            </ul>
        </div>
    </body>
</html>
