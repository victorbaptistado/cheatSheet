<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="./component/button.js" defer></script>
        <title>React</title>
    </header>
    <body>
        <nav>
            <ul class="mainNav">
                <li><a href="./index.html">Cheat Sheet</a></li>
                <li><a href="./displayProperties.html">Display Properties</a></li>
                <li><a href="./objects.html">Objects</a></li>
                <li><a href="./developmentCycle.html">Development Cycle</a></li>
                <li><a href="./debug.html">Debug</a></li>
                <li><a href="./git.html">Git</a></li>
                <li><a href="./form.html">Form</a></li>
                <li><a href="./api.html">API</a></li>
                <li><a href="#">REACT</a></li>                 
            </ul>
        </nav>
        <header>
            <h1>React</h1>
        </header>
        <div class="styleGuide">
            <h2>Virtual DOM</h2>
            <ul>
                <li><strong>Virtual DOM (VDOM)</strong> is React’s local and simplified copy of the HTML DOM. 
                A programming concept where an ideal, or “virtual”, 
                representation of a UI is kept in memory and synced with the “real” DOM by a library 
                such as ReactDOM.</li>
                <li>When you render a JSX element, every single virtual DOM object gets updated.
                This sounds incredibly inefficient, but the cost is insignificant because the virtual DOM 
                can update so quickly.</li>
                <li>Once the virtual DOM has updated, then React compares 
                the virtual DOM with a virtual DOM snapshot that was taken right before the update.
                By comparing the new virtual DOM with a pre-update version, React figures out exactly 
                which virtual DOM objects have changed. This process is called “diffing.”</li>
                <li>Once React knows which virtual DOM objects have changed, then React updates 
                those objects, and only those objects, on the real DOM. In our example from</li>
            </ul>
            <hr/>
            <h3>JSX</h3>
            <ul>
                <li>JSX (JavaScript XML) allows us to write HTML elements in JavaScript 
                and place them in the DOM without any createElement() and/or appendChild() methods.
                JSX converts HTML tags into react elements.</li>
                <li>To render <strong>logic</strong>, if we want any expression to be treated as 
                JavaScript inside of a JSX element we need to wrap it in curly braces.</li>
            </ul>
            <hr/>
            <h2>State</h2>
            <ul>
                <li>A React app is basically just a lot of <strong>components</strong>, setting <strong>state</strong> and passing <strong>props</strong> to one another.</li>
                <li>There are two ways for a component to get dynamic 
                information: <strong>props</strong> and <strong>state</strong>. Besides props and state, 
                every value used in a component should always stay exactly 
                the same.</li>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Often used in React</h2>
            <h3>Destructuring</h3>
            <ul>
                <li>React relies on many destructuring techniques.</li>
                <li>Destructuring, or destructuring assignment, is a JavaScript feature that makes it 
                easier to extract data from arrays and objects and assign them to variables or parameters. 
                Is a syntactic sugar introduced in the ES6 version of JavaScript.</li>
                <p class="center"><strong>Array destructuring</strong>, <strong>Object destructuring</strong>,
                <strong>Function Parameters destructuring</strong></strong></p>
                <button id="showCode16" onclick="showCode('displayCode16', 'showCode16')">Display</button>
                <div id="displayCode16">
                    <button onclick="closeCode('displayCode16', 'showCode16')">Close</button>
                    <pre>
                        <code>
                        //Array Destructuring
                        let cars = ['ferrari', 'tesla', 'cadillac'];
                        let [car1, car2, car3] = cars;
                        console.log(car1, car2, car3); // Prints: ferrari tesla cadillac
                        </code>
                    </pre>
                    <pre>
                        <code>
                        //Object Destructuring
                        let destinations = { x: 'LA', y: 'NYC', z: 'MIA' };
                        let { x, y, z } = destinations;
                        console.log(x, y, z); // Prints LA NYC MIA
                        </code>
                    </pre>
                    <pre>
                        <code>
                        //Destructuring Function Parameters (Function arguments are another place 
                        where destructuring is useful. Instead of accepting a complete object as 
                        an argument, a function can use destructuring to capture specific properties 
                        as named parameters.

                        let truck = {
                        model: '1977 Mustang convertible',
                        city: 'Detroit',
                        convertible: true
                        };
                        
                        const printCarInfo = ({model, city}) => {
                        console.log(`The ${model} is in the city ${city}.`);
                        };
                        </code>
                    </pre>
                </div>
            </ul>
            <hr/>
            <h3>Ternary and && conditionals</h3>
            <pre>
                <code>
                // Ternary, to output a condition if valued true, otherwise another will be set. 

                {!judgmental ? 
                    < li > Nacho Cheez Straight Out The Jar < /li > : < li > Second option < /li >
                }
                </code>
            </pre>
            <pre>
                <code>
                // && conditional, to use if a single condition is set to appear or not.

                {!judgmental && 
                    < li >Nacho Cheez Straight Out The Jar < /li >
                }
                </code>
            </pre>
            <hr/>
            <h3>.map</h3>
            <ul>
                <li>To create a list of JSX elements .map() is often your best bet.</li>
                <li><strong>Keys</strong>: Not all lists need to have keys. 
                A list needs keys if:
                <ul>
                    <li>The list-items have memory from one render to the next. 
                    For instance, when a to-do list renders, each item must “remember” 
                    whether it was checked off.
                    </li> 
                    <li>The items shouldn’t get amnesia when they render.
                    A list’s order might be shuffled. For instance, a list of search results 
                    might be shuffled from one render to the next.
                    </li>
                </ul>
            </ul>
            <p class="center"></p>
            <button id="showCode17" onclick="showCode('displayCode17', 'showCode17')">Display</button>
            <div id="displayCode17">
                <button onclick="closeCode('displayCode17', 'showCode17')">Close</button>
                <pre>
                    <code>
                    const strings = ['Home', 'Shop', 'About Me'];
                    const listItems = strings.map(string => < li >{string} < /li >);

                    < ul > {listItems} < /ul >

                    //using Key

                    const peopleLis = people.map((person, i) =>
                    < li key={'person_' + i} > {person} < /li >
                    );
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>Variable Attribute in a Component</h3>
            <li>We can use variables, including object properties, to set a component’s attributes 
            to keep component easy to read and organized, but more importantly, 
            so that our attributes can be dynamic and/or can be changed easily!</li>
            <button id="showCode18" onclick="showCode('displayCode18', 'showCode18')">Display</button>
            <div id="displayCode18">
                <button onclick="closeCode('displayCode18', 'showCode18')">Close</button>
                <pre>
                    <code>
                        const redPanda = {
                            src: 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Endangered_Red_Panda.jpg',
                            alt: 'Red Panda',
                            width:  '200px'
                        };
                        
                        class RedPanda extends React.Component {
                            render() {
                            return (
                                < div >
                                < h1 >Cute Red Panda< /h1 >
                                < img 
                                    src={redPanda.src}
                                    alt={redPanda.alt}
                                    width={redPanda.width} />
                                < /div >
                            );
                            }
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>Event handler</h3>
            <ul>
                <li><strong>Multiple event handler</strong>: By passing an anonymous function, 
                or a named function, 
                with multiple event handler calls as the function body, to our event listener 
                (like onClick, onKeyUp, onChange, etc) 
                we can call multiple event handlers in response to a single event.</li>
            </ul>
            <pre>
                <code>
                return (
                //Underneath, an anonymous function with multiple event handlers.
                    < button onClick={() => {         
                        this.eventHandler1();
                        this.eventHandler2();
                    }}>Here's a button!</ button> 
                )
                </code>
            </pre>
            <hr/>
            <h3>Style Object</h3>
            <ul>
                <li>For longer styles, it's a good idea to create an <strong>style object.</strong></li>
                <li>One way to make <strong>styles reusable</strong> is to keep them in a 
                <strong>separate JavaScript file.</strong> 
                This file should export the styles that you want to reuse, via export. 
                You can then import your styles into any component that wants them.</li>
            </ul>
            <button id="showCode25" onclick="showCode('displayCode25', 'showCode25')">Display</button>
            <div id="displayCode25">
                <button onclick="closeCode('displayCode25', 'showCode25')">Close</button>
                <ul>
                    <li>Style object</li>
                    <pre>
                        <code>
                    const styles = {
                        color: 'darkcyan',
                        background: 'mintcream'
                    };
                    
                    export class StyledClass extends React.Component {
                        render() {
                        return (
                            < h1 style={styles} >
                            Hello world
                            < /h1 >
                        );
                        }
                    }
                        </code>
                    </pre>
                    <hr/>
                    <li>Style module</li>
                    <pre>
                        <code>
                    const fontFamily = 'Comic Sans MS, Lucida Handwriting, cursive';
                    const background = 'pink url
                    ("https://content.codecademy.com/programs/react/images/welcome-to-my-homepage.gif") fixed';
                    const fontSize = '4em';
                    const padding = '45px 0';
                    const color = 'green';

                    export const styles = {
                        fontFamily: fontFamily,
                        background: background,
                        fontSize:   fontSize,
                        padding:    padding,
                        color:      color
                    };
                        </code>
                    </pre>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>Aditional Algorithms</h2>
            <ul>
                <li>
                    <div class="flex">
                            <p>Auth & password Conditional</p>
                            <button id="showCode19" onclick="showCode('displayCode19', 'showCode19')">Display</button>
                    </div>
                </li>
                <div id="displayCode19">
                    <button onclick="closeCode('displayCode19', 'showCode19')">Close</button>
                    <pre>
                        <code>
                class Contact extends React.Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            password: 'swordfish',
                            authorized: false
                        };
                        this.authorize = this.authorize.bind(this);
                    }
                    
                    authorize(e) {
                        const password = e.target.querySelector(
                        'input[type="password"]').value;
                        const auth = password == this.state.password;
                        this.setState({
                        authorized: auth
                        });
                    }
                    
                    render() {
                        let login = (
                        < form action="#" >
                            < input type='password' placeholder='Password' />
                            < input type='submit' onSubmit={this.authorize} />
                        < /form >
                        );
                        let contactInfo = (
                            < ul >
                            < li >
                                client@example.com
                            < /li >
                            < li >
                                555.555.5555
                            < /li >
                            < /ul >
                        );
                    
                        return (
                        < div id="authorization" >
                            < h1 >{this.state.authorized ? "Contact" : "Enter the Password"}< /h1 >
                            {this.state.authorized ? contactInfo : login}
                        < /div >
                        );
                    }
                    }   
                        </code>
                    </pre>
                </div>
                <li>
                    <div class="flex">
                            <p>Api Interaction</p>
                            <button id="showCode24" onclick="showCode('displayCode24', 'showCode24')">Display</button>
                    </div>
                </li>
                <div id="displayCode24">
                    <button onclick="closeCode('displayCode24', 'showCode24')">Close</button>
                    <pre>
                        <code>
            export default function SocialNetwork() {

                const [menu, setMenu] = useState(null);
                
                useEffect(() => {
                    get('/menu').then((response) => {setMenu(response.data)});
                }, []);
                
                const [newsFeed, setNewsFeed] = useState(null);
                
                useEffect(() => {
                    get('/news-feed').then((response) => {setNewsFeed(response.data)}); 
                }, []);
                
                const [friends, setFriends] = useState(null);
                useEffect(() => {
                    get('/friends').then((response) => {setFriends(response.data)});
                }, []);
                
                return (
                    < div className='App' >
                    < h1 > My Network < /h1 >
                    {!menu ? < p >Loading..< /p > : (
                        < nav >
                        {menu.map((menuItem) => (
                            < button key={menuItem} > {menuItem} < /button >
                        ))}
                        < /nav >
                    )}
                    < div className='content' >
                        {!newsFeed ? < p >Loading..< /p > : (
                        < section >
                            {newsFeed.map(({ id, title, message, imgSrc }) => (
                            < article key={id} >
                                < h3 >{title}< /h3 >
                                < p >{message}< /p >
                                < img src={imgSrc} alt='' />
                            < /article >
                            ))}
                        < /section >
                        )}
                        {!friends ? < p >Loading..< /p > : (
                        < aside >
                            < ul >
                            {friends
                                .sort((a, b) => (a.isOnline && !b.isOnline ? -1 : 0))
                                .map(({ id, name, isOnline }) => (
                                < li key={id} className={isOnline ? 'online' : 'offline'}>
                                    {name}
                                < /li >
                                ))}
                            < /ul >
                        < /aside >
                        )}
                    < /div >
                    < /div >
                );
                }
                        </code>
                    </pre>
                </div>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Programming Patterns</h2>
            <ul>
                <li><strong>Stateful & Stateless</strong> pattern: a <strong>programming pattern</strong> uses two React components: a <strong>stateful 
                component</strong>, and a <strong>stateless component</strong>. “Stateful” describes any 
                component that has a state property; “stateless” describes any component that does not.</li>
                <li>Components should only have <strong>one job</strong>.
                You should divide child in two: one will have one stateless component <strong>display information</strong>, 
                and a different stateless component offer the ability to <strong>change that information</strong>. e.g: A Video Player & a Menu to change its settings.</li>
                <li><strong>How does a component change its props?</strong> The answer: it doesn’t!
                A component should never update this.props.
                A React component should use props to store information that 
                can be changed, but can only be changed by a different component.
                A React component should use state to store information that 
                the component itself can change.</li>
            </ul>
            <p class="center">Forms of <strong>Components Update Parents'</strong> state</p>
            <button id="showCode20" onclick="showCode('displayCode20', 'showCode20')">Display</button>
            <div id="displayCode20">
                <button onclick="closeCode('displayCode20', 'showCode20')">Close</button>
                <ul>
                    <li><p>The parent component class defines a method that calls this.setState().</p>
                    </li>
                    <li><p>The parent component binds the newly-defined method to the current 
                        instance of the component in its constructor. This ensures that when 
                        we pass the method to the child component, it will still update the 
                        parent component. </p>
                    </li>
                    <li><p>The child receives the passed-down function, and uses it as an event handler.
                        When a user clicks on the < button > < /button >, a click event 
                        will fire. This will make the passed-down function get called, which will update 
                        the parent’s state.</p>
                    </li>
                        <pre>
                            <code>                              
                            class ParentClass extends React.Component {
                                constructor(props) {
                                    super(props);
                                    this.state = { totalClicks: 0 };
                                    this.handleClick = this.handleClick.bind(this);
                                }
                            
                                handleClick() {
                                    const total = this.state.totalClicks;
                                
                                    // calling handleClick will 
                                    // result in a state change:
                                    this.setState(
                                        { totalClicks: total + 1 }
                                    );
                                }
                            
                                // The stateful component class passes down
                                // handleClick to a stateless component class:
                                render() {
                                    return (
                                        < ChildClass onClick={this.handleClick} />
                                    );
                                }
                            } 
                            </code>
                        </pre>
                    </li>
                    <li><p>The child receives the passed-down function, and uses it as an event handler.
                        When a user clicks on the < button></button >, a click event will fire. This will make the passed-down function get called, which will update the parent’s state.</p>
                        <pre>
                            <code>
                            export class ChildClass extends React.Component {
                                render() {
                                    return (
                                    // The stateless component class uses
                                    // the passed-down handleClick function,
                                    // accessed here as this.props.onClick,
                                    // as an event handler:
                                    < button onClick={this.props.onClick}>
                                        Click Me!
                                    < /button >
                                    );
                                }
                            }
                            </code>
                        </pre>
                    </li>
                </ul>
            </div>
            <hr/>
            <h3>#1 Presentational components and Container components.</h3>
            <ul>
                <li>Separating <strong>container components</strong> from <strong>presentational components</strong> 
                is a popular React programming pattern. </li>
                <li>The <strong>functional part</strong> of a component (state, calculations, etc.) 
                can be separated into a <strong>container component</strong>. 
                If a component has to have state, make calculations based on props, 
                or manage any other complex logic, then that component shouldn’t also 
                have to render HTML-like JSX. <strong>Presentational component's</strong>
                only job is to contain JSX - it should be an exported component and will not render 
                itself because a presentational component will always 
                get rendered by a container component.</li>
                <li>You want to separate the logic of this component class into a container component.
                Create a <strong>container folder</strong> and a <strong>component folder.</strong>
                To start, just make a copy. After that, you can delete the appropriate parts.
                E.g: Highlight the entire contents of components/GuineaPigs.js, and copy it to the clipboard.
                Now, open containers/GuineaPigsContainer.js.
                Click inside the empty file, and paste. containers/GuineaPigsContainer.js 
                and components/GuineaPigs.js should be identical.</li>
                <p class="center"><strong>Example</strong></p>
                <button id="showCode26" onclick="showCode('displayCode26', 'showCode26')">Display</button>
                <div id="displayCode26">
                    <button onclick="closeCode('displayCode26', 'showCode26')">Close</button>
                    <ul>
                        <li>Container component</li>
                        <pre>
                            <code>
                    import React from 'react';
                    import ReactDOM from 'react-dom';
                    import { GuineaPigs } from '../components/GuineaPigs';
                    
                    const GUINEAPATHS = [
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-1.jpg',
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-2.jpg',
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-3.jpg',
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-4.jpg'
                    ];
                    
                    class GuineaPigsContainer extends React.Component {
                    constructor(props) {
                        super(props);        
                        this.state = { currentGP: 0 };
                        this.interval = null;
                        this.nextGP = this.nextGP.bind(this);
                    }
                    
                    nextGP() {
                        let current = this.state.currentGP;
                        let next = ++current % GUINEAPATHS.length;
                        this.setState({ currentGP: next });
                    }
                    
                    componentDidMount() {
                        this.interval = setInterval(this.nextGP, 5000);
                    }
                    
                    componentWillUnmount() {
                        clearInterval(this.interval);
                    }
                    
                    render() { 
                        const src = GUINEAPATHS[this.state.currentGP]; 
                        return < GuineaPigs src={src} />;
                    }
                    }
                    
                    ReactDOM.render(
                        < GuineaPigsContainer / >, 
                        document.getElementById('app')
                    );
                            </code>
                        </pre>
                    </ul>
                    <ul>
                        <li>Presentational component</li>
                        <pre>
                            <code>
                                import React from 'react';
                                export class GuineaPigs extends React.Component {
                                
                                  render() {
                                    let src = this.props.src;
                                    return (
                                      < div >
                                        < h1 >Cute Guinea Pigs< /h1 >
                                        < img src={src} />
                                      < /div >
                                    );
                                  }
                                }
                            </code>
                        </pre>
                    </ul>
                </div>
                <li>More material:</li>
                <ul>
                    <li><a href="https://medium.com/@learnreact/container-components-c0e67432e005" target="_blank">Container components</a></li>
                    <li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank">Presentational and Container components</a></li>
                </ul>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>React's Lifecycle</h2>
            <ul>
                <li>The first phase of a component’s lifecycle is the <strong>Mounting phase</strong>. 
                    This is when a component is created and inserted into the DOM. The methods that run 
                    during this phase, in order, are:</li>
                <pre>
                    <code>
                    componentWillMount()
                    constructor()
                    render()
                    componentDidMount()
                    </code>
                </pre>
                <li>
                    The next phase of a component’s lifecycle is the <strong>Updating phase</strong>. 
                    This is when a component undergoes any changes to props or state. This phase is the main part of a 
                    component’s life, and the following methods will be 
                    invoked repeatedly at each change,
                </li>
                <pre>
                    <code>
                    componentWillReceiveProps()
                    shouldComponentUpdate()
                    render()
                    componentDidUpdate()
                    </code>
                </pre>
                <li>
                    The last phase of a component’s lifecycle is <strong>Unmounting</strong>. This is when 
                    component is removed from the DOM, and the only method run during this phase is
                </li>
                <pre>
                    <code>
                    componentWillUnmount().
                    </code>
                </pre>
                <li><strong>Side effects</strong> should be separated from the rendering process. 
                If we need to perform a side effect, it should strictly be done after our component renders.
                This is what useEffect gives us.
                In short, useEffect is a tool that lets us interact with the outside 
                world but not affect the rendering or performance of the component that it's in.</li>
                <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank">Lifecycle's interactive diagram.</a>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Hooks</h2>
            <ul>
                <li><strong>React Hooks</strong> are functions that let us manage the internal state of 
                components and handle post-rendering side effects directly from our function components. 
                Hooks don’t work inside classes — they let us use fancy React features without classes.
                <u>Function components and React Hooks do not replace class components.</u> 
                They are completely optional; just a new tool that we can take advantage of.</li>
                <li>Hooks let us <strong>“hook into”</strong> state and lifecycle features directly from our function components.</li>
                <li><strong>Rules of Hooks:</strong> only call Hooks at the top level. Only call Hooks from React functions.</li>
                <li> React keeps track of the data and functions that we are managing 
                with Hooks based on their order in the function component’s definition. 
                For this reason, we always call our Hooks at the top level; we never call hooks 
                inside of loops, conditions, or nested functions.</li>
            </ul>
            <hr/>
            <h3>Function component</h3>
            <ul>
                <li><strong>Function components</strong> are React components defined as JavaScript functions that must return JSX.
                They may accept a props parameter (expect it to be a JavaScript object).</li>
                <li>Although <strong>function components</strong> and <strong>class components</strong> can do the same things, 
                some developers prefer function components over class components for their simplicity and straightforward features, 
                like Hooks.</li>
            </ul>
            <p class="center">Function component example:</p>
            <button id="showCode21" onclick="showCode('displayCode21', 'showCode21')">Display</button>
            <div id="displayCode21">
                <button onclick="closeCode('displayCode21', 'showCode21')">Close</button>
                <pre>
                    <code>
                        export class MyComponentClass extends React.Component {
                            render() {
                            return < h1 >Hello world< /h1 >;
                            }
                        }
                        
                        // The same component class, written as a stateless functional component:
                        export const MyComponentClass = () => {
                            return < h1 >Hello world< /h1 >;
                        }
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>HOOKs list</h3>
            <ul>
                <li><strong>useState(): </strong>Updates state.</li>
                    <ul>
                        <li>Can be used with callbacks to update previous states 
                        (and setCount for example).</li>
                        <li>Use arrays and objects to organize and manage related data 
                        that tends to change together</li>
                    </ul>
                <p class="center"><strong>useState</strong>, <strong>Previous State</strong>, 
                <strong>Array in State</strong> & <strong>Object in State</strong> example:</p>
                <button id="showCode22" onclick="showCode('displayCode22', 'showCode22')">Display</button>
                <div id="displayCode22">
                    <button onclick="closeCode('displayCode22', 'showCode22')">Close</button>
                    <ul>
                        <li><strong>useState</strong></li>
                        <pre>
                            <code>                       
                            function Toggle() {
                                const [toggle, setToggle] = useState();
                                
                                return (
                                    < div >
                                        < p > The toggle is {toggle} < / p >
                                        < button onClick={() => setToggle("On")}> On < / button>
                                        < button onClick={() => setToggle("Off")}> Off < / button>
                                    < /div >
                                );
                            }
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Previous State callback</strong></li>
                        <pre>
                            <code>                       
                            export default function Counter() {
                                const [count, setCount] = useState(0);
                            
                                const increment = () => setCount(prevCount => prevCount + 1);
                            
                                return (
                                    < div >
                                        < p >Wow, you've clicked that button: {count} times < /p >
                                        < button onClick={increment}>Click here! < /button >
                                    < /div >
                                );
                            }
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Arrays in State:</strong>The best data model for managing and rendering JSX lists.</li>
                        <pre>
                            <code>
                            const options = ["Bell Pepper", "Sausage", "Pepperoni", "Pineapple"];

                            export default function PersonalPizza() {
                            const [selected, setSelected] = useState([]);
                            
                            const toggleTopping = ({target}) => {
                                const clickedTopping = target.value;
                                setSelected((prev) => {
                                    // check if clicked topping is already selected
                                    if (prev.includes(clickedTopping)) {
                                        // filter the clicked topping out of state
                                        return prev.filter(t => t !== clickedTopping);
                                    } else {
                                        // add the clicked topping to our state
                                        return [clickedTopping, ...prev];
                                    }
                                });
                            };
                            
                            return (
                                < div >
                                    {options.map(option => (
                                        < button value={option} onClick={toggleTopping} key={option} >
                                        {selected.includes(option) ? "Remove " : "Add "}
                                        {option}
                                        < /button >
                                ))}
                                < p > Order a {selected.join(", ")} pizza < /p >
                                </ div >
                            );
                            }
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Objects in State:</strong> When we work with a set of related variables, 
                        it can be very helpful to group them in an object. Let’s look at an example!</li>
                        <pre>
                            <code>
                            export default function Login() {
                            const [formState, setFormState] = useState({});
                            
                            const handleChange = ({ target }) => {
                                const { name, value } = target;
                                setFormState((prev) => ({
                                ...prev,
                                [name]: value
                                }));
                            };

                            return (
                                < form >
                                < input
                                    value={formState.firstName}
                                    onChange={handleChange}
                                    name="firstName"
                                    type="text"
                                />
                                < input
                                    value={formState.password}
                                    onChange={handleChange}
                                    type="password"
                                    name="password"
                                />
                                < /form >
                            );
                            }
                            </code>
                        </pre>
                    </ul>
                </div>
                <li><strong>useEffect(): </strong>by using this Hook, you tell React that your 
                component needs to do something <strong>after render</strong>. 
                React will remember the function 
                you passed (we'll refer to it as our “effect”), and call it later after performing 
                the DOM updates.</li>
                <ul>
                    <li>We can use the Effect Hook to run some JavaScript code after each render, such as:
                    Fetching data from a backend service.
                    Subscribing to a stream of data.
                    Managing timers and intervals.
                    Reading from and making changes to the DOM.</li>
                    <li>There are three <strong>key moments</strong> when the Effect Hook can be utilized:
                    When the component is first added, or mounted, to the DOM and renders.
                    When the state or props change, causing the component to re-render.
                    When the component is removed, or unmounted, from the DOM.</li>
                </ul>
                <p class="center"><strong>useEffect</strong> & <strong>API</strong> example:</p>
                <button id="showCode23" onclick="showCode('displayCode23', 'showCode23')">Display</button>
                <div id="displayCode23">
                    <button onclick="closeCode('displayCode23', 'showCode23')">Close</button>
                    <ul>
                        <li><strong>Dependency Array: </strong>Second argument of useEffect(), represented by: [].</li>
                        <pre>
                            <code>
                            useEffect(() => {
                                document.title = `Hi, ${name}`;
                                }, [name]);
                            </code>
                        </pre>
                        <li><strong>Undefined array: </strong>useEffect will be triggered every re-render (cleanup can be needed).</li>
                        <li><strong>Empty array: </strong>We pass an empty array (dependency array) 
                        to useEffect() as the second argument if we want to call our effect only after 
                        the first render (no cleanup is needed).</li>
                        <li><strong>Non-empty array: </strong>A dependency array that is not empty signals to the Effect Hook that 
                        it can skip calling our effect after re-renders unless the value of one 
                        of the variables in our dependency array has changed.
                        (no cleanup is needed).</li>
                        <hr/>
                        <li>Some effects require cleanup. For example, we might want to add 
                        event listeners to some element in the DOM, beyond the JSX in our component. 
                        When we add event listeners to the DOM, it is important to remove those 
                        event listeners when we are done with them to avoid memory leaks!</li>
                        <pre>
                            <code>
                            useEffect(() => {
                                document.addEventListener('mousedown', increment);
                                    return () => {
                                        document.removeEventListener('mousedown', increment);
                                    }
                                });
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>API interaction</strong> example:</li>
                        <pre>
                            <code>
                        //Example 1 (Separation of concerns for EndPoints / State Variables)

                        export default function SocialNetwork() {

                            const [menu, setMenu] = useState(null);
                            
                            useEffect(() => {
                                get('/menu').then((response) => {setMenu(response.data)});
                            }, []);
                            
                            const [newsFeed, setNewsFeed] = useState(null);
                            
                            useEffect(() => {
                                get('/news-feed').then((response) => {setNewsFeed(response.data)}); 
                            }, []);
                            
                            const [friends, setFriends] = useState(null);
                            useEffect(() => {
                                get('/friends').then((response) => {setFriends(response.data)});
                            }, []);
                            
                            return (
                                < div className='App' >
                                < h1 > My Network < /h1 >
                                {!menu ? < p >Loading..< /p > : (
                                    < nav >
                                    {menu.map((menuItem) => (
                                        < button key={menuItem} > {menuItem} < /button >
                                    ))}
                                    < /nav >
                                )}
                                < div className='content' >
                                    {!newsFeed ? < p >Loading..< /p > : (
                                    < section >
                                        {newsFeed.map(({ id, title, message, imgSrc }) => (
                                        < article key={id} >
                                            < h3 >{title}< /h3 >
                                            < p >{message}< /p >
                                            < img src={imgSrc} alt='' />
                                        < /article >
                                        ))}
                                    < /section >
                                    )}
                                    {!friends ? < p >Loading..< /p > : (
                                    < aside >
                                        < ul >
                                        {friends
                                            .sort((a, b) => (a.isOnline && !b.isOnline ? -1 : 0))
                                            .map(({ id, name, isOnline }) => (
                                            < li key={id} className={isOnline ? 'online' : 'offline'}>
                                                {name}
                                            < /li >
                                            ))}
                                        < /ul >
                                    < /aside >
                                    )}
                                < /div >
                                < /div >
                            );
                            }
                            </code>
                        </pre>
                        <pre>
                            <code>
                        //Example 2
                        
                        export default function Shop() {
                            const [categories, setCategories] = useState(null);
                            const [selectedCategory, setSelectedCategory] = useState(null);
                            const [items, setItems] = useState({});
                        
                        
                            useEffect(() => {
                            get('/categories').then((response) => {
                                setCategories(response.data);
                            });
                            }, []);
                        
                        
                            useEffect(() => {
                            if (selectedCategory && !items[selectedCategory]) {
                                get(`/items?category=${selectedCategory}`).then((response) => {
                                setItems((prev) => 
                                ({ ...prev, [selectedCategory]: response.data }));
                                });
                            }}, [selectedCategory, items]);
                            
                            
                            if (!categories) {
                                return < p >Loading..< /p >;
                            }
                            
                            return (
                                < div className='App' >
                                < h1 >Clothes 'n Things< /h1 >
                                < nav >
                                    {categories.map((category) => (
                                    < button key={category} 
                                    onClick={() => setSelectedCategory(category)}>
                                        {category}
                                    < /button >
                                    ))}
                                < /nav >
                                < h2 >{selectedCategory}</ h2 >
                                < ul >
                                    {!items[selectedCategory]
                                    ? null
                                    : items[selectedCategory].map((item) => 
                                    < li key={item}>{item}< /li >)}
                                < /ul >
                                < /div >
                            );
                        }
                            </code>
                        </pre>
                    </ul>
                </div>
            </ul>
        </div>
    </body>
</html>
