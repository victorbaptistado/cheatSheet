<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="./component/button.js" defer></script>
        <title>React</title>
    </header>
    <body>
        <nav>
            <ul class="mainNav">
                <li><a href="./index.html">Cheat Sheet</a></li>
                <li><a href="./displayProperties.html">Display Properties</a></li>
                <li><a href="./objects.html">Objects</a></li>
                <li><a href="./developmentCycle.html">Development Cycle</a></li>
                <li><a href="./debug.html">Debug</a></li>
                <li><a href="./git.html">Git</a></li>
                <li><a href="./form.html">Form</a></li>
                <li><a href="./api.html">API</a></li>
                <li><a href="#">REACT</a></li> 
                <li><a href="./helpfulContent.html">Helpful Content</a></li>                
            </ul>
        </nav>
        <header>
            <h1>React</h1>
        </header>
        <div class="styleGuide">
            <h2>Virtual DOM</h2>
            <ul>
                <li><strong>Virtual DOM (VDOM)</strong> is React’s local and simplified copy of the HTML DOM. 
                A programming concept where an ideal, or “virtual”, 
                representation of a UI is kept in memory and synced with the “real” DOM by a library 
                such as ReactDOM.</li>
                <li>When you render a JSX element, every single virtual DOM object gets updated.
                This sounds incredibly inefficient, but the cost is insignificant because the virtual DOM 
                can update so quickly.</li>
                <li>Once the virtual DOM has updated, then React compares 
                the virtual DOM with a virtual DOM snapshot that was taken right before the update.
                By comparing the new virtual DOM with a pre-update version, React figures out exactly 
                which virtual DOM objects have changed. This process is called “diffing.”</li>
                <li>Once React knows which virtual DOM objects have changed, then React updates 
                those objects, and only those objects, on the real DOM. In our example from</li>
            </ul>
            <hr/>
            <h3>JSX</h3>
            <ul>
                <li>JSX (JavaScript XML) allows us to write HTML elements in JavaScript 
                and place them in the DOM without any createElement() and/or appendChild() methods.
                JSX converts HTML tags into react elements.</li>
                <li>To render <strong>logic</strong>, if we want any expression to be treated as 
                JavaScript inside of a JSX element we need to wrap it in curly braces.</li>
            </ul>
            <hr/>
            <h2>State</h2>
            <ul>
                <li>A React app is basically just a lot of <strong>components</strong>, setting <strong>state</strong> and passing <strong>props</strong> to one another.</li>
                <li>There are two ways for a component to get dynamic 
                information: <strong>props</strong> and <strong>state</strong>. Besides props and state, 
                every value used in a component should always stay exactly 
                the same.</li>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Often used in React</h2>
            <h3>Destructuring</h3>
            <ul>
                <li>React relies on many destructuring techniques.</li>
                <li>Destructuring, or destructuring assignment, is a JavaScript feature that makes it 
                easier to extract data from arrays and objects and assign them to variables or parameters. 
                Is a syntactic sugar introduced in the ES6 version of JavaScript.</li>
                <p class="center"><strong>Array destructuring</strong>, <strong>Object destructuring</strong>,
                <strong>Function Parameters destructuring</strong></strong></p>
                <button id="showCode16" onclick="showCode('displayCode16', 'showCode16')">Display</button>
                <div id="displayCode16">
                    <button onclick="closeCode('displayCode16', 'showCode16')">Close</button>
                    <pre>
                        <code>
                        //Array Destructuring
                        let cars = ['ferrari', 'tesla', 'cadillac'];
                        let [car1, car2, car3] = cars;
                        console.log(car1, car2, car3); // Prints: ferrari tesla cadillac
                        </code>
                    </pre>
                    <pre>
                        <code>
                        //Object Destructuring
                        let destinations = { x: 'LA', y: 'NYC', z: 'MIA' };
                        let { x, y, z } = destinations;
                        console.log(x, y, z); // Prints LA NYC MIA
                        </code>
                    </pre>
                    <pre>
                        <code>
                        //Destructuring Function Parameters (Function arguments are another place 
                        where destructuring is useful. Instead of accepting a complete object as 
                        an argument, a function can use destructuring to capture specific properties 
                        as named parameters.

                        let truck = {
                        model: '1977 Mustang convertible',
                        city: 'Detroit',
                        convertible: true
                        };
                        
                        const printCarInfo = ({model, city}) => {
                        console.log(`The ${model} is in the city ${city}.`);
                        };
                        </code>
                    </pre>
                </div>
            </ul>
            <hr/>
            <h3>Ternary and && conditionals</h3>
            <pre>
                <code>
                // Ternary, to output a condition if valued true, otherwise another will be set. 

                {!judgmental ? 
                    < li > Nacho Cheez Straight Out The Jar < /li > : < li > Second option < /li >
                }
                </code>
            </pre>
            <pre>
                <code>
                // && conditional, to use if a single condition is set to appear or not.

                {!judgmental && 
                    < li >Nacho Cheez Straight Out The Jar < /li >
                }
                </code>
            </pre>
            <hr/>
            <h3>.map</h3>
            <ul>
                <li>To create a list of JSX elements .map() is often your best bet.</li>
                <li><strong>Keys</strong>: Not all lists need to have keys. 
                A list needs keys if:
                <ul>
                    <li>The list-items have memory from one render to the next. 
                    For instance, when a to-do list renders, each item must “remember” 
                    whether it was checked off.
                    </li> 
                    <li>The items shouldn’t get amnesia when they render.
                    A list’s order might be shuffled. For instance, a list of search results 
                    might be shuffled from one render to the next.
                    </li>
                </ul>
            </ul>
            <p class="center"></p>
            <button id="showCode17" onclick="showCode('displayCode17', 'showCode17')">Display</button>
            <div id="displayCode17">
                <button onclick="closeCode('displayCode17', 'showCode17')">Close</button>
                <pre>
                    <code>
                    const strings = ['Home', 'Shop', 'About Me'];
                    const listItems = strings.map(string => < li >{string} < /li >);

                    < ul > {listItems} < /ul >

                    //using Key

                    const peopleLis = people.map((person, i) =>
                    < li key={'person_' + i} > {person} < /li >
                    );
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>Variable Attribute in a Component</h3>
            <li>We can use variables, including object properties, to set a component’s attributes 
            to keep component easy to read and organized, but more importantly, 
            so that our attributes can be dynamic and/or can be changed easily!</li>
            <button id="showCode18" onclick="showCode('displayCode18', 'showCode18')">Display</button>
            <div id="displayCode18">
                <button onclick="closeCode('displayCode18', 'showCode18')">Close</button>
                <pre>
                    <code>
                        const redPanda = {
                            src: 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Endangered_Red_Panda.jpg',
                            alt: 'Red Panda',
                            width:  '200px'
                        };
                        
                        class RedPanda extends React.Component {
                            render() {
                            return (
                                < div >
                                < h1 >Cute Red Panda< /h1 >
                                < img 
                                    src={redPanda.src}
                                    alt={redPanda.alt}
                                    width={redPanda.width} />
                                < /div >
                            );
                            }
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>Event handler</h3>
            <ul>
                <li><strong>Multiple event handler</strong>: By passing an anonymous function, 
                or a named function, 
                with multiple event handler calls as the function body, to our event listener 
                (like onClick, onKeyUp, onChange, etc) 
                we can call multiple event handlers in response to a single event.</li>
            </ul>
            <pre>
                <code>
                return (
                //Underneath, an anonymous function with multiple event handlers.
                    < button onClick={() => {         
                        this.eventHandler1();
                        this.eventHandler2();
                    }}>Here's a button!</ button> 
                )
                </code>
            </pre>
            <hr/>
            <h3>Style Object</h3>
            <ul>
                <li>For longer styles, it's a good idea to create an <strong>style object.</strong></li>
                <li>One way to make <strong>styles reusable</strong> is to keep them in a 
                <strong>separate JavaScript file.</strong> 
                This file should export the styles that you want to reuse, via export. 
                You can then import your styles into any component that wants them.</li>
            </ul>
            <button id="showCode25" onclick="showCode('displayCode25', 'showCode25')">Display</button>
            <div id="displayCode25">
                <button onclick="closeCode('displayCode25', 'showCode25')">Close</button>
                <ul>
                    <li>Style object</li>
                    <pre>
                        <code>
                    const styles = {
                        color: 'darkcyan',
                        background: 'mintcream'
                    };
                    
                    export class StyledClass extends React.Component {
                        render() {
                        return (
                            < h1 style={styles} >
                            Hello world
                            < /h1 >
                        );
                        }
                    }
                        </code>
                    </pre>
                    <hr/>
                    <li>Style module</li>
                    <pre>
                        <code>
                    const fontFamily = 'Comic Sans MS, Lucida Handwriting, cursive';
                    const background = 'pink url
                    ("https://content.codecademy.com/programs/react/images/welcome-to-my-homepage.gif") fixed';
                    const fontSize = '4em';
                    const padding = '45px 0';
                    const color = 'green';

                    export const styles = {
                        fontFamily: fontFamily,
                        background: background,
                        fontSize:   fontSize,
                        padding:    padding,
                        color:      color
                    };
                        </code>
                    </pre>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>Programming Patterns</h2>
            <ul>
                <li><strong>Stateful & Stateless</strong> pattern: a <strong>programming pattern</strong> uses two React components: a <strong>stateful 
                component</strong>, and a <strong>stateless component</strong>. “Stateful” describes any 
                component that has a state property; “stateless” describes any component that does not.</li>
                <li>Components should only have <strong>one job</strong>.
                You should divide child in two: one will have one stateless component <strong>display information</strong>, 
                and a different stateless component offer the ability to <strong>change that information</strong>. e.g: A Video Player & a Menu to change its settings.</li>
                <li><strong>How does a component change its props?</strong> The answer: it doesn’t!
                A component should never update this.props.
                A React component should use props to store information that 
                can be changed, but can only be changed by a different component.
                A React component should use state to store information that 
                the component itself can change.</li>
            </ul>
            <p class="center">Forms of <strong>Components Update Parents'</strong> state</p>
            <button id="showCode20" onclick="showCode('displayCode20', 'showCode20')">Display</button>
            <div id="displayCode20">
                <button onclick="closeCode('displayCode20', 'showCode20')">Close</button>
                <ul>
                    <li>The parent component class defines a method that calls this.setState().</li>
                    <li>The parent component binds the newly-defined method to the current 
                    instance of the component in its constructor. This ensures that when 
                    we pass the method to the child component, it will still update the 
                    parent component.</li>
                    <li>The child receives the passed-down function, and uses it as an event handler.
                    When a user clicks on the < button > < /button >, a click event 
                    will fire. This will make the passed-down function get called, which will update 
                    the parent’s state.</li>
                    <pre>
                        <code>                              
                        class ParentClass extends React.Component {
                            constructor(props) {
                                super(props);
                                this.state = { totalClicks: 0 };
                                this.handleClick = this.handleClick.bind(this);
                            }
                        
                            handleClick() {
                                const total = this.state.totalClicks;
                            
                                // calling handleClick will 
                                // result in a state change:
                                this.setState(
                                    { totalClicks: total + 1 }
                                );
                            }
                        
                            // The stateful component class passes down
                            // handleClick to a stateless component class:
                            render() {
                                return (
                                    < ChildClass onClick={this.handleClick} />
                                );
                            }
                        } 
                        </code>
                    </pre>
                    <li>The child receives the passed-down function, and uses it as an event handler.
                    When a user clicks on the < button >, a click event will fire. This will make 
                    the passed-down function get called, which will update the parent’s state.</li>
                    <pre>
                        <code>
                        export class ChildClass extends React.Component {
                            render() {
                                return (
                                // The stateless component class uses
                                // the passed-down handleClick function,
                                // accessed here as this.props.onClick,
                                // as an event handler:
                                < button onClick={this.props.onClick}>
                                    Click Me!
                                < /button >
                                );
                            }
                        }
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>#1 Presentational components and Container components.</h3>
            <ul>
                <li>Separating <strong>container components</strong> from <strong>presentational components</strong> 
                is a popular React programming pattern. </li>
                <li>The <strong>functional part</strong> of a component (state, calculations, etc.) 
                can be separated into a <strong>container component</strong>. 
                If a component has to have state, make calculations based on props, 
                or manage any other complex logic, then that component shouldn’t also 
                have to render HTML-like JSX. <strong>Presentational component's</strong>
                only job is to contain JSX - it should be an exported component and will not render 
                itself because a presentational component will always 
                get rendered by a container component.</li>
                <li>You want to separate the logic of this component class into a container component.
                Create a <strong>container folder</strong> and a <strong>component folder.</strong>
                To start, just make a copy. After that, you can delete the appropriate parts.
                E.g: Highlight the entire contents of components/GuineaPigs.js, and copy it to the clipboard.
                Now, open containers/GuineaPigsContainer.js.
                Click inside the empty file, and paste. containers/GuineaPigsContainer.js 
                and components/GuineaPigs.js should be identical.</li>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode26" onclick="showCode('displayCode26', 'showCode26')">Display</button>
                <div id="displayCode26">
                    <button onclick="closeCode('displayCode26', 'showCode26')">Close</button>
                    <ul>
                        <li>Container component</li>
                        <pre>
                            <code>
                    import React from 'react';
                    import ReactDOM from 'react-dom';
                    import { GuineaPigs } from '../components/GuineaPigs';
                    
                    const GUINEAPATHS = [
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-1.jpg',
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-2.jpg',
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-3.jpg',
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-4.jpg'
                    ];
                    
                    class GuineaPigsContainer extends React.Component {
                    constructor(props) {
                        super(props);        
                        this.state = { currentGP: 0 };
                        this.interval = null;
                        this.nextGP = this.nextGP.bind(this);
                    }
                    
                    nextGP() {
                        let current = this.state.currentGP;
                        let next = ++current % GUINEAPATHS.length;
                        this.setState({ currentGP: next });
                    }
                    
                    componentDidMount() {
                        this.interval = setInterval(this.nextGP, 5000);
                    }
                    
                    componentWillUnmount() {
                        clearInterval(this.interval);
                    }
                    
                    render() { 
                        const src = GUINEAPATHS[this.state.currentGP]; 
                        return < GuineaPigs src={src} />;
                    }
                    }
                    
                    ReactDOM.render(
                        < GuineaPigsContainer / >, 
                        document.getElementById('app')
                    );
                            </code>
                        </pre>
                    </ul>
                    <ul>
                        <li>Presentational component</li>
                        <pre>
                            <code>
                                import React from 'react';
                                export class GuineaPigs extends React.Component {
                                
                                  render() {
                                    let src = this.props.src;
                                    return (
                                      < div >
                                        < h1 >Cute Guinea Pigs< /h1 >
                                        < img src={src} />
                                      < /div >
                                    );
                                  }
                                }
                            </code>
                        </pre>
                    </ul>
                </div>
                <li>More material:</li>
                <ul>
                    <li><a href="https://medium.com/@learnreact/container-components-c0e67432e005" target="_blank">Container components</a></li>
                    <li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank">Presentational and Container components</a></li>
                    <li>Download appointment challenge <a href="https://static-assets.codecademy.com/skillpaths/react-redux/react_challenge_solution.zip" target="_blank">here</a>.</li>
                </ul>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>React's Lifecycle</h2>
            <ul>
                <li>The first phase of a component’s lifecycle is the <strong>Mounting phase</strong>. 
                    This is when a component is created and inserted into the DOM. The methods that run 
                    during this phase, in order, are:</li>
                <pre>
                    <code>
                    componentWillMount()
                    constructor()
                    render()
                    componentDidMount()
                    </code>
                </pre>
                <li>
                    The next phase of a component’s lifecycle is the <strong>Updating phase</strong>. 
                    This is when a component undergoes any changes to props or state. This phase is the main part of a 
                    component’s life, and the following methods will be 
                    invoked repeatedly at each change,
                </li>
                <pre>
                    <code>
                    componentWillReceiveProps()
                    shouldComponentUpdate()
                    render()
                    componentDidUpdate()
                    </code>
                </pre>
                <li>
                    The last phase of a component’s lifecycle is <strong>Unmounting</strong>. This is when 
                    component is removed from the DOM, and the only method run during this phase is
                </li>
                <pre>
                    <code>
                    componentWillUnmount().
                    </code>
                </pre>
                <li><strong>Side effects</strong> should be separated from the rendering process. 
                If we need to perform a side effect, it should strictly be done after our component renders.
                This is what useEffect gives us.
                In short, useEffect is a tool that lets us interact with the outside 
                world but not affect the rendering or performance of the component that it's in.</li>
                <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank">Lifecycle's interactive diagram.</a>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Hooks</h2>
            <ul>
                <li><strong>React Hooks</strong> are functions that let us manage the internal state of 
                components and handle post-rendering side effects directly from our function components. 
                Hooks don’t work inside classes — they let us use fancy React features without classes.
                <u>Function components and React Hooks do not replace class components.</u> 
                They are completely optional; just a new tool that we can take advantage of.</li>
                <li>Hooks let us <strong>“hook into”</strong> state and lifecycle features directly from our function components.</li>
                <li><strong>Rules of Hooks:</strong> only call Hooks at the top level. Only call Hooks from React functions.</li>
                <li> React keeps track of the data and functions that we are managing 
                with Hooks based on their order in the function component’s definition. 
                For this reason, we always call our Hooks at the top level; we never call hooks 
                inside of loops, conditions, or nested functions.</li>
            </ul>
            <hr/>
            <h3>Function component</h3>
            <ul>
                <li><strong>Function components</strong> are React components defined as JavaScript functions that must return JSX.
                They may accept a props parameter (expect it to be a JavaScript object).</li>
                <li>Although <strong>function components</strong> and <strong>class components</strong> can do the same things, 
                some developers prefer function components over class components for their simplicity and straightforward features, 
                like Hooks.</li>
            </ul>
            <p class="center">Function component example:</p>
            <button id="showCode21" onclick="showCode('displayCode21', 'showCode21')">Display</button>
            <div id="displayCode21">
                <button onclick="closeCode('displayCode21', 'showCode21')">Close</button>
                <pre>
                    <code>
                        export class MyComponentClass extends React.Component {
                            render() {
                            return < h1 >Hello world< /h1 >;
                            }
                        }
                        
                        // The same component class, written as a stateless functional component:
                        export const MyComponentClass = () => {
                            return < h1 >Hello world< /h1 >;
                        }
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>HOOKs list</h3>
            <ul>
                <li><strong>useState(): </strong>Updates state.</li>
                    <ul>
                        <li>Can be used with callbacks to update previous states 
                        (and setCount for example).</li>
                        <li>Use arrays and objects to organize and manage related data 
                        that tends to change together</li>
                    </ul>
                <p class="center"><strong>useState</strong>, <strong>Previous State</strong>, 
                <strong>Array in State</strong> & <strong>Object in State</strong> example:</p>
                <button id="showCode22" onclick="showCode('displayCode22', 'showCode22')">Display</button>
                <div id="displayCode22">
                    <button onclick="closeCode('displayCode22', 'showCode22')">Close</button>
                    <ul>
                        <li><strong>useState</strong></li>
                        <pre>
                            <code>                       
                            function Toggle() {
                                const [toggle, setToggle] = useState();
                                
                                return (
                                    < div >
                                        < p > The toggle is {toggle} < / p >
                                        < button onClick={() => setToggle("On")}> On < / button>
                                        < button onClick={() => setToggle("Off")}> Off < / button>
                                    < /div >
                                );
                            }
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Previous State callback</strong></li>
                        <pre>
                            <code>                       
                            export default function Counter() {
                                const [count, setCount] = useState(0);
                            
                                const increment = () => setCount(prevCount => prevCount + 1);
                            
                                return (
                                    < div >
                                        < p >Wow, you've clicked that button: {count} times < /p >
                                        < button onClick={increment}>Click here! < /button >
                                    < /div >
                                );
                            }
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Arrays in State:</strong>The best data model for managing and rendering JSX lists.</li>
                        <pre>
                            <code>
                            const options = ["Bell Pepper", "Sausage", "Pepperoni", "Pineapple"];

                            export default function PersonalPizza() {
                            const [selected, setSelected] = useState([]);
                            
                            const toggleTopping = ({target}) => {
                                const clickedTopping = target.value;
                                setSelected((prev) => {
                                    // check if clicked topping is already selected
                                    if (prev.includes(clickedTopping)) {
                                        // filter the clicked topping out of state
                                        return prev.filter(t => t !== clickedTopping);
                                    } else {
                                        // add the clicked topping to our state
                                        return [clickedTopping, ...prev];
                                    }
                                });
                            };
                            
                            return (
                                < div >
                                    {options.map(option => (
                                        < button value={option} onClick={toggleTopping} key={option} >
                                        {selected.includes(option) ? "Remove " : "Add "}
                                        {option}
                                        < /button >
                                ))}
                                < p > Order a {selected.join(", ")} pizza < /p >
                                </ div >
                            );
                            }
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Objects in State:</strong> When we work with a set of related variables, 
                        it can be very helpful to group them in an object. Let’s look at an example!</li>
                        <pre>
                            <code>
                            export default function Login() {
                            const [formState, setFormState] = useState({});
                            
                            const handleChange = ({ target }) => {
                                const { name, value } = target;
                                setFormState((prev) => ({
                                ...prev,
                                [name]: value
                                }));
                            };

                            return (
                                < form >
                                < input
                                    value={formState.firstName}
                                    onChange={handleChange}
                                    name="firstName"
                                    type="text"
                                />
                                < input
                                    value={formState.password}
                                    onChange={handleChange}
                                    type="password"
                                    name="password"
                                />
                                < /form >
                            );
                            }
                            </code>
                        </pre>
                    </ul>
                </div>
                <li><strong>useEffect(): </strong>by using this Hook, you tell React that your 
                component needs to do something <strong>after render</strong>. 
                React will remember the function 
                you passed (we'll refer to it as our “effect”), and call it later after performing 
                the DOM updates.</li>
                <ul>
                    <li>We can use the Effect Hook to run some JavaScript code after each render, such as:
                    Fetching data from a backend service.
                    Subscribing to a stream of data.
                    Managing timers and intervals.
                    Reading from and making changes to the DOM.</li>
                    <li>There are three <strong>key moments</strong> when the Effect Hook can be utilized:
                    When the component is first added, or mounted, to the DOM and renders.
                    When the state or props change, causing the component to re-render.
                    When the component is removed, or unmounted, from the DOM.</li>
                </ul>
                <p class="center"><strong>useEffect</strong> & <strong>API</strong> example:</p>
                <button id="showCode23" onclick="showCode('displayCode23', 'showCode23')">Display</button>
                <div id="displayCode23">
                    <button onclick="closeCode('displayCode23', 'showCode23')">Close</button>
                    <ul>
                        <li><strong>Dependency Array: </strong>Second argument of useEffect(), represented by: [].</li>
                        <pre>
                            <code>
                            useEffect(() => {
                                document.title = `Hi, ${name}`;
                                }, [name]);
                            </code>
                        </pre>
                        <li><strong>Undefined array: </strong>useEffect will be triggered every re-render (cleanup can be needed).</li>
                        <li><strong>Empty array: </strong>We pass an empty array (dependency array) 
                        to useEffect() as the second argument if we want to call our effect only after 
                        the first render (no cleanup is needed).</li>
                        <li><strong>Non-empty array: </strong>A dependency array that is not empty signals to the Effect Hook that 
                        it can skip calling our effect after re-renders unless the value of one 
                        of the variables in our dependency array has changed.
                        (no cleanup is needed).</li>
                        <hr/>
                        <li>Some effects require cleanup. For example, we might want to add 
                        event listeners to some element in the DOM, beyond the JSX in our component. 
                        When we add event listeners to the DOM, it is important to remove those 
                        event listeners when we are done with them to avoid memory leaks!</li>
                        <pre>
                            <code>
                            useEffect(() => {
                                document.addEventListener('mousedown', increment);
                                    return () => {
                                        document.removeEventListener('mousedown', increment);
                                    }
                                });
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>API interaction</strong> example:</li>
                        <pre>
                            <code>
                //Example 1 (Separation of concerns for EndPoints / State Variables)

                export default function SocialNetwork() {

                    const [menu, setMenu] = useState(null);
                    
                    useEffect(() => {
                        get('/menu').then((response) => {setMenu(response.data)});
                    }, []);
                    
                    const [newsFeed, setNewsFeed] = useState(null);
                    
                    useEffect(() => {
                        get('/news-feed').then((response) => {setNewsFeed(response.data)}); 
                    }, []);
                    
                    const [friends, setFriends] = useState(null);
                    useEffect(() => {
                        get('/friends').then((response) => {setFriends(response.data)});
                    }, []);
                    
                    return (
                        < div className='App' >
                        < h1 > My Network < /h1 >
                        {!menu ? < p >Loading..< /p > : (
                            < nav >
                            {menu.map((menuItem) => (
                                < button key={menuItem} > {menuItem} < /button >
                            ))}
                            < /nav >
                        )}
                        < div className='content' >
                            {!newsFeed ? < p >Loading..< /p > : (
                            < section >
                                {newsFeed.map(({ id, title, message, imgSrc }) => (
                                < article key={id} >
                                    < h3 >{title}< /h3 >
                                    < p >{message}< /p >
                                    < img src={imgSrc} alt='' />
                                < /article >
                                ))}
                            < /section >
                            )}
                            {!friends ? < p >Loading..< /p > : (
                            < aside >
                                < ul >
                                {friends
                                    .sort((a, b) => (a.isOnline && !b.isOnline ? -1 : 0))
                                    .map(({ id, name, isOnline }) => (
                                    < li key={id} className={isOnline ? 'online' : 'offline'}>
                                        {name}
                                    < /li >
                                    ))}
                                < /ul >
                            < /aside >
                            )}
                        < /div >
                        < /div >
                    );
                    }
                            </code>
                        </pre>
                        <pre>
                            <code>
                        //Example 2
                        
                        export default function Shop() {
                            const [categories, setCategories] = useState(null);
                            const [selectedCategory, setSelectedCategory] = useState(null);
                            const [items, setItems] = useState({});
                        
                        
                            useEffect(() => {
                            get('/categories').then((response) => {
                                setCategories(response.data);
                            });
                            }, []);
                        
                        
                            useEffect(() => {
                            if (selectedCategory && !items[selectedCategory]) {
                                get(`/items?category=${selectedCategory}`).then((response) => {
                                setItems((prev) => 
                                ({ ...prev, [selectedCategory]: response.data }));
                                });
                            }}, [selectedCategory, items]);
                            
                            
                            if (!categories) {
                                return < p >Loading..< /p >;
                            }
                            
                            return (
                                < div className='App' >
                                < h1 >Clothes 'n Things< /h1 >
                                < nav >
                                    {categories.map((category) => (
                                    < button key={category} 
                                    onClick={() => setSelectedCategory(category)}>
                                        {category}
                                    < /button >
                                    ))}
                                < /nav >
                                < h2 >{selectedCategory}</ h2 >
                                < ul >
                                    {!items[selectedCategory]
                                    ? null
                                    : items[selectedCategory].map((item) => 
                                    < li key={item}>{item}< /li >)}
                                < /ul >
                                < /div >
                            );
                        }
                            </code>
                        </pre>
                    </ul>
                </div>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>PropTypes</h2>
            <ul>
                <li><strong>PropTypes</strong> are useful for two reasons:
                <ul>
                    <li><strong>Prop validation.</strong>
                    Validation can ensure that your props are doing what they’re supposed to be doing. 
                    If props are missing, or if they’re present but they aren’t what you’re expecting, 
                    then a warning will print in the console.</li>
                    <li><strong>Documentation.</strong>
                    Documenting props makes it easier to glance at a file and quickly understand the 
                    component class inside. When you have a lot of files, and you will, this can be 
                    a huge benefit.</li>
                </ul>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode27" onclick="showCode('displayCode27', 'showCode27')">Display</button>
            <div id="displayCode27">
                <button onclick="closeCode('displayCode27', 'showCode27')">Close</button>
                <pre>
                    <code>
            import React from 'react';
            import PropTypes from 'prop-types';

            export class MessageDisplayer extends React.Component {
            render() {
                return (
                    <>
                    < input value={value} onChange={handleChange}/>
                    < h1 >{this.props.message}< /h1 >);
                    </>
            }
            }

            // This propTypes object should have
            // one property for each expected prop:
            MessageDisplayer.propTypes = {
                message: PropTypes.string,
                value: PropTypes.string.isRequired,
                handleChange: PropTypes.func.handleChange
            };
                    </code>
                </pre>
            </div>
        </div>
        <div class="styleGuide">
            <h2>React Form</h2>
            <ul>
                <li>In a React form, <u>you want the server to know about every new character or deletion,</u> 
                as soon as it happens (using <u>onChange</u>). That way, your screen will always be in sync 
                with the rest of your application (some third parties need to know what the user
                is typing, therefore we need to always use).</li>
            </ul>
            <hr/>
            <h3>Controlled vs Uncontrolled</h3>
            <ul>
                <li><strong>Uncontrolled component: </strong>A component that maintains 
                its own internal state. When < input / > keeps track of information makes it an 
                uncontrolled component. It maintains its own internal state, by remembering data about 
                itself.</li>
                <li><strong>Controlled component: </strong>A component that does not maintain 
                any internal state, it has no memory. Has its state controlled from outside, 
                through props. 
                In React, when you give an < input / > 
                a <u>value attribute</u>, then something strange happens: the < input / > BECOMES controlled. 
                It stops using its internal storage. E.g: value={this.props.userInput}. <u>This is a more ‘React’ way of doing things.</u></li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode28" onclick="showCode('displayCode28', 'showCode28')">Display</button>
            <div id="displayCode28">
                <button onclick="closeCode('displayCode28', 'showCode28')">Close</button>
                <pre>
                    <code>
                    export class Input extends React.Component {
                    constructor(props){
                        super(props);
                        this.state = {userInput: ''};
                        this.handleUserInput = this.handleUserInput.bind(this)
                    }

                    handleUserInput(e){
                        this.setState({userInput: e.target.value});
                    }

                    render() {
                        return (
                            < div >
                                // Notice "value" has its state stored on 
                                an outside prop, therefore making it
                                a controlled component
                                < input type="text" value={this.state.userInput} 
                                onChange={this.handleUserInput} />
                                < h1 >{this.state.userInput}< /h1 >
                            < /div >
                        );
                    }
                    }
                    </code>
                </pre>
            </div>
        </div>
        <div class="styleGuide">
            <h2>React API</h2>
            <ul>
                <li>To use the <strong>value of a Promise</strong> in React, you can use a <strong>useEffect()</strong> 
                hook with an empty dependency array to wait for the promise to resolve, and store the result in the
                value of a useState hook.</li>
            </ul>
            <p class="center"><strong>Examples:</strong></p>
            <button id="showCode32" onclick="showCode('displayCode32', 'showCode32')">Display</button>
            <div id="displayCode32">
                <button onclick="closeCode('displayCode32', 'showCode32')">Close</button>
                <ul>
                    <li><strong>useState</strong> & <strong>useEffect</strong>.</li>
                    <pre>
                        <code>
                function PromisesPage() {
                    const [catUrl, setCatUrl] = useState('');
                    const [error, setError] = useState(false);
                    const [state, setState] = useState('');
                    
                    useEffect(() => {
                        setState('loading');
                        axios
                            .get('https://cataas.com/cat?json=true')
                            .then((res) => {
                                console.log(res);
                                setState('success');
                                setCatUrl('https://cataas.com' + res.data.url);
                            })
                            .catch((err) => {
                                console.error('Error:', err);
                                setState('error');
                                setError(err);
                            });
                    }, []);

                    if (state === 'error')
                        return (
                            < h1 >
                                {error.toString()}
                            < /h1 >
                        );
                        
                    return (
                        < div >
                            < div >
                                {state === 'loading' ? (
                                    < h1 >Loading...< /h1 >
                                ) : (
                                    < img src="{catUrl}" />
                                )}
                            < /div >
                        < /div >
                    );
                }
                        </code>
                    </pre>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>React Router</h2>
            <ul>
                <li><strong>React Router:</strong> Is a standard library 
                for routing in React. It enables the navigation among views 
                of various components in a React Application, allows changing 
                the browser URL, and keeps the UI in sync with the URL.
                <u>React Router treats everything as a component</u>. To get 
                fully comfortable using React Router in your code, you have 
                to embrace this idea and the declarative coding style that 
                follows from it.</li>
                <li><strong>Link & NavLink: </strong>Works just as < a > tag, 
                but avoids the reload rendering. NavLink's difference is that it 
                gives the navigation style.
                </li>
                <li><strong>Dynamic Routes: </strong>
                Specifying a unique route for every article would not only be 
                verbose and time-consuming, it would require an impractical 
                amount of maintenance should the path structure ever change.
                Instead, we would rather express the pattern at a high level 
                with a single route that 
                can match any path of the form '/articles/' + someTitle 
                and still know which article to render. React Router 
                allows us to do this by using URL parameters to create 
                dynamic routes.
                </li>
                <li><strong>useParams:</strong> It is common to use the 
                value of URL parameters to determine what is displayed 
                in the component that a dynamic route renders. 
                For example, the Article component might need to display 
                the title of the current article, or the content shown
                is based on the URL (showing all 'cats' from 'cat category').
                React Router provides a hook, useParams(), for accessing 
                the value of URL parameters. When called, useParams() 
                returns an object that maps the names of URL Parameters to 
                their values in the current URL.</li>
                <li><strong>Switch:</strong> < Switch > renders a single component (the first child < Route > 
                or < Redirect >) that matches the location. That's used
                when we want to render an exclusive path. It's organized from
                the most specific path to the most generic.</li>
                <li><strong>Nested Routes:</strong> As an 
                application grows in scope, it can be useful to split up 
                the router and write Routes nearer to where the related UI 
                logic is written.</li>
                <li><strong>useRouteMatch: </strong>
                Instead of writing out the full URL path for Nested routes, 
                it's more flexible to create relative paths based on 
                the /categories URL. React Router provides a hook, 
                useRouteMatch(), that makes it incredibly easy to do this.
                <ul>
                    <li><strong>Url: </strong>Has the actual value of 
                    route parameters filled in.
                    Useful for building nested < Link >s.</li>
                    <li><strong>Path: </strong>Leaves the names of the current URL’s URL 
                    parameters as-is. Useful for building nested < Route >s.</li>
                </ul>
                <li><strong>Redirect:</strong> Is a routing component in React 
                Router Dom v5 that enables us to override the history 
                object and dynamically redirect a user from a route to a 
                new route. Often used for errors. Updates the browser location as declaratively.
                <u>The <strong>< Redirect /></strong> component has been 
                deprecated and replaced with React 
                <strong>< Navigate/ ></strong> in React Router v6.</u></li>
                <li><strong>useHistory: </strong> 
                Provides a mechanism for updating the browser’s location 
                imperatively.
                By enabling imperative updates to the browser location, 
                the history object allows you to respond immediately to user 
                input without having to wait.
                Browser history is a stack that stores the URLs visited 
                by the user and maintains a pointer to the user’s current 
                location. This history API allows you to navigate through 
                a user’s session history and alter the history stack if 
                necessary.</li>
                <li><strong>Query parameters: </strong>Appear in URLs 
                beginning with a question mark (?) and are followed 
                by a parameter name assigned 
                to a value. They are optional and are most often used 
                to search, sort and/or filter resources.
                Query parameters do not need to be specified in the path prop 
                since they are part of the URL’s query string, not its path! 
                React Router provides a mechanism for grabbing the values 
                of query parameters: the <strong>useLocation()</strong> hook.</li>
                <li><strong>Exact: </strong>Is a property used in a < Route > 
                that means that your path should match exactly with 
                your route path and should not be just the prefix of it.</li>
                <li>Download full React Router code
                <a href="https://static-assets.codecademy.com/Courses/react-router/react-router-lesson-solution-1.zip?_gl=1*sz135p*_ga*MzUxOTc3MDY5My4xNjY2MDU2MTg3*_ga_3LRZM6TM9L*MTY3MzA5MzQ0Ni4xNzguMS4xNjczMDk1MDQ4LjYwLjAuMA..">example 1</a>
                and
                <a href="https://static-assets.codecademy.com/Courses/react-router/adopt-a-pet-solution.zip">example 2</a>
                (adopt-a-pet-solution).
                </li>
                <li>React Router <strong>documentation</strong> <a href="https://reactrouter.com/en/main" target="_blank">here</a>.</li>
            </ul>
            <p class="center"><strong>Examples:</strong></p>
            <button id="showCode29" onclick="showCode('displayCode29', 'showCode29')">Display</button>
            <div id="displayCode29">
                <button onclick="closeCode('displayCode29', 'showCode29')">Close</button>
                <ul>
                    <li><strong>Dynamic Routes</strong></li>
                    <pre>
                        <code>
                < Route path='/articles/<strong>:title</strong>' >
                    < Article />
                < /Route >
                        </code>
                    </pre>
                To indicate an optional parameter, you’ll need to append a ? to it, like so:
                    <pre>
                        <code>
                < Route path="/:param?">
                      < MyComponent />
                < /Route>
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>useParams</strong></li>
                    The useParams hook returns an object of key/value 
                    pairs of the dynamic params from the current URL that 
                    were matched by the < Route path >. Child routes inherit 
                    all params from their parent routes.
                    <br>
                    <u>Remember to use destructuring for the useParam
                    variable assigned.</u>
                    <br><br>
                    <strong>Some of its use:</strong>
                    <br>
                    <br>
                    E.g: Can be used to <u>render title</u> based on the current URL.
                    <pre>
                        <code>
                export default function Article() {

                let { title } = useParams();
                // title will be equal to the string 'objects'
                
                // The title will be rendered in the < h1 >
                
                return (
                        < article >
                            < h1 >{title}< /h1 >
                        < /article >
                    );
                }
                        </code>
                    </pre>
                E.g: Can be used to <u>render page</u> userId based on the URL:
                    <pre>
                        <code>
                function ProfilePage() {
                    // Get the userId param from the URL.
                    let { userId } = useParams();
                    // ...
                    }
                    
                    function App() {
                    return (
                        < Routes >
                        < Route path="users" >
                            < Route path=":userId" 
                                element={< ProfilePage />} />
                            < Route path="me" element={...} />
                        < /Route >
                        < /Routes >
                    );
                }           
                        </code>
                    </pre>
                E.g: Can be used to <u>render data</u> based on URL:
                    <pre>
                        <code>
                const HomePage = () => {
                    const [data, setData] = useState(null);
                    const {type} = useParams(); // Fix me!
                    
                    useEffect(() => {
                        async function getPetsData() {
                        const petsData = await getPets(type);
                        setData(petsData);
                        }
                    
                        getPetsData();
                    }, [type]);
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Switch</strong></li>
                    <pre>
                        <code>
            < Switch >
                < div >
                    < Route path='/articles/:title' >
                        < Article />
                    < /Route >
                    < Route path='/articles/new' >
                        < NewArticle />
                    < /Route >
                    < Route path='/articles' >
                        < Articles />
                    < /Route >
                < /div >
            < /Switch >
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Nested Routes</strong> with <strong>useRouteMatch</strong></li>
                    <pre>
                        <code>
            function BandPage ({ songs }) {
            let { path, url } = useRouteMatch();
            
            // path = '/band/:band'
            // url = '/band/queen' 
            
            // Render a list of relative Links and a Route 
            to render a SongPage

            return (
                < div >
                    < ul >
                        {
                        songs.map(songName =>
                            < li >
                            < Link to={`<strong>${url}</strong>/song/${songName}`}> 
                                {category}
                            < /Link>
                            < /li>
                        )
                        }
                    < /ul >
            
                    < Route path={`<strong>${path}</strong>/song/:songName`}>
                        < SongPage />
                    < /Route>
                < /div>
            )
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Redirect</strong></li>
                    <pre>
                        <code>
            const UserProfile = ({ loggedIn }) => {
                if (!loggedIn) {
                    return (
                        < Redirect to='/' />
                    )
                }
                
            return (
                    // ... user profile contents here
                )  
            }
                        </code>
                    </pre>
                    <li><strong>Navigate</strong>(Loggin example)</li>
                    <pre>
                        <code>                         
            function App() {
                const navigate = useNavigate();
                const [isLoggedIn, setisLoggedIn] = useState(false);
            
                useEffect(() => {
                // Checking if user is not loggedIn
                if (!isLoggedIn) {
                    navigate("/");
                } else {
                    navigate("/login");
                }
                }, [navigate, isLoggedIn]);
            
                return (
                <>
                    < Routes >
                        < Route path='/' 
                            element={< h1 >Home Page Component< /h1 >} 
                        />
                        < Route path='/login' 
                            element={< h1 >Login Page Component< /h1 >} 
                        />
                        < Route path='*' 
                            element={< Navigate to='/' />} 
                        />
                    < /Routes>
            
                    {/* New line */}
                    {isLoggedIn || (
                    < button onClick={() => setisLoggedIn(true)}>
                        Log me in
                    < /button>
                    )}
                </>
                );
            }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>history.push(location)</strong> which 
                    redirects the user to the provided location.</li>
                    <li><strong>history.goBack()</strong> which navigates 
                    to the previous URL in the history stack</li>
                    <li><strong>history.goForward()</strong> which navigates 
                    to the next URL in the history stack.
                    </li>
                    <li><strong>history.go(n)</strong> which navigates n 
                    entries (where positive n values are forward and negative 
                    n values are backward) through the history stack.
                    </li>
                    <pre>
                        <code>
                            //history.push:

                            export const ExampleForm = () => {
 
                                const history = useHistory()
                               
                                const handleSubmit = e => {
                                  e.preventDefault();
                                  history.push('/')
                                }
                               
                                return (
                                  < form onSubmit={handleSubmit} >
                                        {/* form elements */ }
                                  < /form >
                                )
                              }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Query Parameter</strong> (useLocation)</li>
                    Remember to use destructuring for the useLocation variable assigned.
                    <pre>
                        <code>
                // Rendered when a user visits "/list?order=DESC"
                export const SortedList = (numberList) => {
                    const { search } = useLocation();
                    const queryParams = new URLSearchParams(search);
                    const sortOrder = queryParams.get('order');
                    
                    if (sortOrder === 'ASC') {
                    // render the numberList in ascending order
                    } else if (sortOrder === 'DESC') {
                    // render the numberList in descending order
                    } else {
                    // render the numberList as is
                    }
                }
                        </code>
                    </pre>
                </ul>
                </div>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>React Test</h2>
            <h3>Jest</h3>
            <ul>
                <li>Used with any Javascript Framework.</li>
                <ul>
                    <li><strong>Jest </strong>tutorial <a href="https://www.valentinog.com/blog/jest/" target="_blank">here</a>.</li>
                    <li><strong>Jest </strong>documentation <a href="https://jestjs.io/docs/tutorial-react" target="_blank">here</a>.</li>
                </ul>
            </ul>
            <hr/>
            <h3>Enzyme</h3>
            <ul>
                <li>Used only with React.</li>
                <ul>
                    <li><strong>Enzyme </strong>documentation <a href="https://enzymejs.github.io/enzyme/" target="_blank">here</a>.</li>
                </ul>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Redux</h2>
            <ul>
                <li>Depending on the size and complexity of your 
                state, state management can be a complicated process in plain React.
                That’s where Redux comes in. <strong>Redux: </strong>Is a state 
                management library that follows a pattern known as the 
                <a href="https://facebook.github.io/flux/docs/in-depth-overview/" target="_blank">Flux architecture</a>. 
                In the Flux pattern, and in Redux, shared information is not stored 
                in components but in a single object - that helps separate the state, the view, and actions. 
                Components are just given data to render and can request changes using events called actions. 
                The state is available throughout the application and updates are made in a predictable manner: 
                components are “notified” whenever a change is made to the state. Any components of the view 
                that would be affected by these changes are informed by this single source.</li>
                <li>State -> Actions -> View -> returns to State, and so on...</li>
                <ul>
                    <li>State: the current data used in the app;</li>
                    <li>View: the user interface displayed to users;</li>
                    <li>Actions: events that a user can take to change the state.</li>
                </ul>
                <hr/>
                <li><strong>Actions: </strong>are represented as plain JS objects.
                Here's what that action might look like:
                <pre>
                    <code>
                const action = {
                    type: 'todos/addTodo',
                    payload: 'Take selfies'
                };
                    </code>
                </pre>
                    <ul>
                        <li><strong>Type: </strong>Describes the action. 
                        Every action must have a type property with a string value.</li>
                        <li><strong>Payload: </strong>Typically, an action has a payload 
                        property with an object value - this includes any information related 
                        to the action. In this case, the payload is the todo text.
                        The name payload is simply a convention and its value can be anything.</li>
                        <li>When an action is generated and notifies other parts of the application, 
                        we say that the action is <strong>dispatched.</strong></li>
                    </ul>
                </li>
                <li><strong>Reducer: </strong>Reducer, or reducer function, is a plain 
                JavaScript function that defines how the <u>current state</u> and an <u>action</u> 
                are used in combination to create the new state.
                It defines the application’s next state given a current state and a specific action.
                It returns a default initial state if no action is provided,
                it returns the current state if the action is not recognized.
                <u>Reducers must make immutable updates and be pure functions.</u> 
                <strong>Here are some rules:</strong></li>
                <ul>
                    <li>They should only calculate the new state value based on 
                    the state and action arguments.</li>
                    <li>They are not allowed to modify the existing state. 
                    Instead, they must copy the existing state and make changes to the copied values.</li>
                    <li>They must not do any asynchronous logic or have other “side effects”.</li>
                </ul>
                <li><strong>Store: </strong>Acts as a container for state, it provides a way 
                to dispatch actions, and it calls the reducer when actions are dispatched. 
                In nearly every Redux application, there will only be one store.</li>
                <li><strong>Slice: </strong>
                In a Redux application, the top-level state properties are known as slices. 
                Each slice typically represents a different feature of the entire application. A slice can be any 
                data value (key/value), like an array of objects, or just a string.
                As a best practice, most Redux applications begin with an initialState that allows 
                the programmer to plan out the general structure of the state and
                provide an initial state value to the reducer function.<br>
                When an application state has multiple slices, individual actions 
                typically only change one slice at a time - therefore, it is recommended 
                that each action's type follows the pattern <i>'sliceName/actionDescriptor'</i>, 
                to clarify which slice of state should be updated.<br>
                We typically define one reducer for each slice of the state. Those are called “slice reducers”.</li>
                <li><strong>Redux library: </strong>Provides some very useful tools for handling 
                the most common aspects of building a Redux application and helps ensure that the core
                Redux principles are enforced (implentation in "Examples" below). 
                Check <a href="https://redux.js.org/" target="_blank">here</a>.</li>
                <li><strong>Material</strong> on Redux  <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-redux/modules/wdcp-22-core-redux-api/cheatsheet" target="_blank">here</a>.</li>
                <li><strong>Redux DevTools </strong>video <a href="https://www.youtube.com/watch?v=BYpuigD01Ew" target="_blank">here</a>.</li>
                <hr/>
                <h3>Reducer Composition: </h3>
                <li>In this pattern, individual slice 
                reducers are responsible for updating only one slice of the application's state, 
                and their results are recombined by a rootReducer to form a single state object (inside the Store).
                The <strong>root reducer </strong>delegates actions to slice reducers that are responsible for 
                updating only their assigned slice of the store's state. 
                The root reducer then reassembles the slices into a new state object.
                </li>
                <li><strong>File Structure for Redux</strong>. Following
                <a href="https://github.com/erikras/ducks-modular-redux">Redux Duck</a> pattern.
                Implentation in "Examples" below.</li>
                <li><strong>Data flow</strong> (Store -> View -> Action -> Store):</li>
                <ul>                 
                    <li>The store initializes the state with a default value.</li>
                    <li>The view displays that state.</li>
                    <li>When a user interacts with the view, like clicking a button, an action is dispatched to the store.</li>
                    <li>The dispatched action and the current state are combined in the store’s reducer to determine the next state.</li>
                    <li>The view is updated to display the new state.</li>
                </ul>
                <hr/>
                <h3>Redux with React</h3>
                Install React Redux by "npm install react-redux". With it will solve this issues:
                <ul>
                    <li><strong>With < Provider >, </strong>React-Redux gives the entire application access 
                    to the Redux store without using props and props drilling.
                    (Pop-drill, from top-level to downwards component, isn't ideal, because many times top-level
                    doesn’t make use of those props.)
                    It's used to wrap App.js in the index.js.</li>
                    <li>Subscribes individual components to specific pieces of the application state 
                    for optimized rendering. This is done with useSelector() hook.</li>
                    <li>Easily dispatches actions within components.</li>
                </ul>
                <li><strong>< Provider > :</strong> Component used to provide the Redux store to the nested application.</li>
                <li><strong>Selectors: </strong> Are created to give instructions on retrieving data from the store.
                This is exported from the componentSlicer, and its data is taken by the 
                rendering component through useSelector() hook.</li>
                <li><strong>useSelector(): </strong>This hook gives application the instructions to access data 
                from the Redux store. Is called within a child component of < Provider > for executing 
                selector instructions to retrieve data and subscribe to re-rendering. It accomplishes two things:</li>
                    <ul>
                        <li>Returns data from the Redux store using selectors.</li>
                        <li>Subscribes a child component of < Provider /> to changes in the store. 
                        React, not Redux, will re-render the component if the data from the selector changes.</li>
                    </ul>
                <li><strong>useDispatch(): </strong>This hook allows to dispatch actions from any component 
                that is a descendent of the < Provider > component, therefore avoiding passing a reference 
                to store.dispatch through props.</li>
                <li> Material on React Redux <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-redux/modules/wdcp-22-connect-to-react-with-react-redux/cheatsheet" target="_blank">here</a>.</li>
                <li>Video with Project using React Redux <a href="https://www.youtube.com/watch?v=O8usZmDJh84" target="_blank">here</a>.</li>
                <hr/>
                <h3>Redux Toolkit (RTK)</h3>
                <li><a href="https://redux-toolkit.js.org/" target="_blank">Redux Toolkit</a> 
                contains packages and functions that are essential for building a Redux app. 
                It builds in the best practices, simplifies most Redux tasks, prevents common mistakes, 
                and makes it easier to write Redux applications. Redux Toolkit has become the preferred 
                way to write Redux application logic. </li>
                <li><strong>Install</strong> with: 'npm install @reduxjs/toolkit'</li>
                <li><strong>createSlice():</strong>
                Easier way to define a slice reducer and the associated action creators.
                createSlice() has one parameter, options, which is an object with the 
                properties 'name', 'initialState' and 'reducers'. 
                (Action creators that correspond to each case reducer function 
                we provide will be automatically generated, so we don’t need to worry 
                about defining those ourselves.)
                It returns an object with the following properties: name, reducer, actions, and caseReducers.
                We typically use the “ducks” pattern when exporting the action creators 
                and the reducer.
                <br>
                createSlice() function uses a library called Immer inside of it which 
                helps avoid this mistake.</li>
                <ul>
                    <li>We can write the case reducers as functions inside of an object, instead of 
                    having to write a switch/case statement.</li>
                    <li>Action creators that correspond to each case reducer function we provide will be automatically generated, so we don’t need to worry about defining those ourselves.</li>
                    <li>No default handler needs to be written. The reducer generated by createSlice() will automatically handle all other action types by returning the current state, so we don’t have to list that ourselves.</li>
                </ul>
                <li><strong>configureStore(): </strong>Simplifies the store setup 
                process. configureStore() wraps around the Redux library’s 
                createStore() method and the combineReducers() method, and handles 
                most of the store setup for us automatically.</li>
                <hr/>
                <h3>Redux Middleware (dealing with async).</h3>
                <li><strong>Middleware: </strong>Is the code that runs in the 
                middle, usually between a framework receiving a request and producing 
                a response. Middleware is a powerful tool for extending, modifying, 
                or customizing a framework or library’s default behavior to meet 
                an application’s specific needs.</li>
                <li><strong>In Redux</strong>, middleware intercepts actions 
                between the moment when an action is 
                dispatched and the moment when that action is passed along to the 
                reducer. Some common tasks that 
                middleware perform include logging, caching, adding auth tokens to 
                request headers, crash reporting, routing, and making asynchronous 
                requests for data.
                You can add any of these functionalities to your apps by using 
                popular open-source middleware (a common one is redux-thunk, 
                that comes with React Toolkit).</li>
                <li><strong>applyMiddleware: </strong></li>
                <ul>
                    <li>Once middleware has been added to a Redux project, calls to dispatch are 
                    actually calls to the middleware pipeline (the chain of all added middlewares). 
                    This means that any actions we dispatch will be passed from middleware to 
                    middleware before they hit an app’s reducers.</li>
                    <li>Each middleware has access to the storeAPI (which consists of the dispatch
                    and getState functions), as well as the next middleware in the pipeline, 
                    and the action that is to be dispatched. The body of the middleware function 
                    performs the middleware’s specific task before calling the next middleware in 
                    the pipeline with the current action (note that if the middleware is the last in 
                    the pipeline, then next is storeAPI.dispatch so calling next(action) is the same as 
                    dispatching the action to the store).</li>
                </ul>
                <li><strong>Thunks: </strong>One of the most flexible and popular ways to add 
                asynchronous functionality to Redux. They allow us to bundle up bits of 
                computation we want to delay into packages that can be passed around in code.
                It's a function returned by another function.
                “can be used to delay dispatching an action” 
                (for example, until after an API response is received), or “to dispatch an action
                only if certain conditions are met”.
                configureStore automatically enables redux-thunk.</li>
                <li><strong>createAsyncThunk: </strong>is a function with two parameters, an action type string and 
                an asynchronous callback that generates a thunk action creator that will run the provided callback 
                and automatically dispatch promise lifecycle actions as appropriate so that you don't have to dispatch 
                pending/fulfilled/rejected actions by hand.</li> 
                <li><strong>extraReducers: </strong>
                A optional property you can pass to createSlice that allows 
                createSlice to respond to action types it did not generate
                (when you are dealing with an action that you have already defined 
                somewhere else). The most common examples are responding to a 
                createAsyncThunk action and responding to an action from another slice.</li>
                <li><strong>Github project </strong><a href="https://github.com/reduxjs/redux-thunk" target="_blank">here</a>.</li>
                <li><strong>Download</strong> Flashcard project <a href="https://static-assets.codecademy.com/skillpaths/react-redux/flashcards-solution.zip" target="_blank">here</a>.</li>  
            </ul>
            <p class="center"><strong>Examples:</strong></p>
            <button id="showCode30" onclick="showCode('displayCode30', 'showCode30')">Display</button>
            <div id="displayCode30">
                <button onclick="closeCode('displayCode30', 'showCode30')">Close</button>
                <ul>
                    <li><strong>Reducer</strong></li>
                    <ul>
                        <li>We use the equals sign = to supply a 
                        default value for the state parameter.</li>
                        <li>We use the spread operator (...) to copy 
                        the current state and any changed values into a 
                        new object, not the existing state argument.
                        We'll explain why in the next exercise.</li>
                    </ul>
                    <pre>
                        <code>
            const initialState = [ 'Print trail map', 
                                    'Pack snacks', 'Summit the mountain' ];

            const todoReducer = (state = initialState, action) => {
                switch (action.type) {
                    case 'todos/addTodo': {
                        return [...state, action.payload];
                    }
                    case 'todos/removeAll': {
                        return [];
                    }
                    default: {
                        return state;
                    }
                }
            }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>React library </strong>(Create Store, Dispatch, Subscribe):</li>
                    <pre>
                        <code>
            const increment = () => {
                return { type: 'increment' }
            }
            
            const decrement = () => {
                return { type: 'decrement' }
            }
            
            const initialState = 0;
            const countReducer = (state = initialState, action) => {
                switch (action.type) {
                case 'increment':
                    return state + 1;
                case 'decrement':
                    return state - 1;
                default:
                    return state;
                }
            }
            
            const store = createStore(countReducer);
            
            const printCountStatus = () => {
                console.log(`The count is ${store.getState()}`);
            }
            
            store.subscribe(printCountStatus);
            
            store.dispatch(decrement()); // store.getState() === -1
            store.dispatch(increment()); // store.getState() === 0
            store.dispatch(increment()); // store.getState() === 1
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>React Redux</strong> & UI (Vanilla Javascrip).</li>
                    <pre>
                        <code>
            // Action Creators
            function increment() { 
                return {type: 'increment'}
            }

            function decrement() { 
                return {type: 'decrement'}
            }

            // Reducer / Store
            const initialState = 0;
            const countReducer = (state = initialState, action) => {
                switch (action.type) {
                    case 'increment':
                        return state + 1; 
                    case 'decrement':
                        return state - 1; 
                    default:
                        return state;
                }
            };  
            const store = createStore(countReducer);

            // HTML Elements
            const counterElement = document.getElementById('counter');
            const incrementer = document.getElementById('incrementer');
            const decrementer = document.getElementById('decrementer');

            // Store State Change Listener
            const render = () => {
                counterElement.innerHTML = store.getState();
            }
            render();

            store.subscribe(render);

            // DOM Event Handlers
            const incrementerClicked = () => {
                store.dispatch(increment());
            }
            incrementer.addEventListener('click', incrementerClicked);
            
            const decrementerClicked = () => {
                store.dispatch(decrement());
            }
            decrementer.addEventListener('click', decrementerClicked);
                        </code>
                    </pre>
                    <li><strong>React</strong> with Redux (without React Redux library).</li>
                    <pre>
                        <code>
            // REDUX CODE


            const increment = () => {
                return {type: 'increment'} 
            }

            const decrement = () => { 
                return {type: 'decrement'}
            }

            const initialState = 0;
            const counterReducer = (state = initialState, action) => {
            switch (action.type) {
                case 'increment':
                    return state + 1;
                case 'decrement':
                    return state - 1;
                default:
                    return state; 
                }
            } 

            const store = createStore(counterReducer);

            
            // REACT CODE

            const render = () => {
                ReactDOM.render(
                    < CounterApp 
                    state={store.getState()}
                    />,
                    document.getElementById('root')
                )
            }

            render();
            // Render once with the initial state.
            // Subscribe render to changes to the store's state.

            function CounterApp(props) {
                const state = props.state;
                const onIncrementButtonClicked = () => {
                    store.dispatch(increment());
                }
                
                const onDecrementButtonClicked = () => {
                    store.dispatch(decrement());
                }
                
                return (   
                    < div id='counter-app' >
                    < h1 > {state} < /h1 >
                    < button onClick={onIncrementButtonClicked}>+< /button > 
                    < button onClick={onDecrementButtonClicked}>-< /button >
                    < /div >
                )
            }

            store.subscribe(render);
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Reducer Composition </strong> with combineReducers() example:</li>
                    <ul>
                        <li><strong>combineReducers()</strong> is a method provided by the redux library 
                        that accepts a collection of reducer functions and returns a rootReducer 
                        that implements the reducer composition pattern.</li>
                    </ul>
                    <pre>
                        <code>        
            // Action Creators

            const addRecipe = (recipe) => {
                return { 
                    type: 'favoriteRecipes/addRecipe', 
                    payload: recipe 
                };
            }

            const removeRecipe = (recipe) => {
                return { 
                    type: 'favoriteRecipes/removeRecipe', 
                    payload: recipe 
                };
            }

            const setSearchTerm = (term) => {
                return {
                    type: 'searchTerm/setSearchTerm',
                    payload: term
                }
            }

            const clearSearchTerm = () => {
                return {
                    type: 'searchTerm/clearSearchTerm'
                }; 
            }

            const loadData = () => {
                return { 
                    type: 'allRecipes/loadData', 
                    payload: allRecipeData
                };
            }

            // Reducers

            const initialAllRecipes = [];
            const allRecipesReducer = (allRecipes = initialAllRecipes, action) => {
                switch(action.type) {
                    case 'allRecipes/loadData': 
                        return action.payload
                    default:
                        return allRecipes;
                }
            }

            const initialSearchTerm = '';
            const searchTermReducer = (searchTerm = initialSearchTerm, action) => {
                switch(action.type) {
                    case 'searchTerm/setSearchTerm':
                        return action.payload
                    case 'searchTerm/clearSearchTerm':
                        return ''
                    default: 
                        return searchTerm;
                }
            }

            const initialFavoriteRecipes = [];
            const favoriteRecipesReducer = (favoriteRecipes = initialFavoriteRecipes, action) => {
                switch(action.type) {
                    case 'favoriteRecipes/addRecipe':
                        return [...favoriteRecipes, action.payload]
                    case 'favoriteRecipes/removeRecipe':
                        return favoriteRecipes.filter(recipe => {
                            return recipe.id !== action.payload.id
                    });
                    default:
                        return favoriteRecipes;
                }
            }

            const reducers = {
                allRecipes: allRecipesReducer,
                favoriteRecipes: favoriteRecipesReducer,
                searchTerm: searchTermReducer 
            }

            const rootReducer = combineReducers(reducers); 

            //With the Redux composition, store must be exported,
            to be used within other components
            export const store = createStore(rootReducer);
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>React Redux</strong></li>
                    <ul>
                    <li><strong>Selectors</strong></li>
                    <pre>
                        <code>
            import allRecipesData from '../../../data.js'
            import { selectSearchTerm } from '../searchTerm/searchTermSlice.js';
            
            export const loadData = () => {
                return {
                    type: 'allRecipes/loadData',
                    payload: allRecipesData
                }
            }
            
            const initialState = [];
            export const allRecipesReducer = (allRecipes = initialState, action) => {
                switch (action.type) {
                    case 'allRecipes/loadData':
                        return action.payload;
                    case 'favoriteRecipes/addRecipe':
                        return allRecipes.filter(recipe => recipe.id !== action.payload.id);
                    case 'favoriteRecipes/removeRecipe':
                        return [...allRecipes, action.payload]
                    default:
                        return allRecipes;
                }
            }
            
            // Implement the selectors below.
            export const selectAllRecipes = state => state.allRecipes;
            
            export const selectFilteredAllRecipes = state => {
                const allRecipes = selectAllRecipes(state);
                const searchTerm = selectSearchTerm(state);
                return allRecipes.filter(recipe => 
                    recipe.name.toLowerCase().includes(searchTerm.toLowerCase()))
            };      
                        </code>
                    </pre>
                    <li><strong>useSelector() </strong>& <strong>useDispatch()</strong>.</li>
                    <ul>
                        <li>Calls useDispatch() to obtain a reference to the Redux store dispatch() function and assigns it to dispatch.</li>
                        <li>Dispatches an action using dispatch() with an action object as the argument.</li>
                    </ul>
                    <pre>
                        <code>
            import { useSelector, useDispatch } from 'react-redux';
            import { selectTodo } from './todoSlice.js';
            import { removeTodo } from './todoSlice.js';
            
            const Todo = () => {
                const todo = useSelector(selectTodo);
                const dispatch = useDispatch();
            
                return (
                    < button onClick={() => dispatch(removeTodo(todo))} >
                        {todo}
                    < /button >
                )
            }
                        </code>
                    </pre>
                    <pre>
                        <code>           
            const favoriteIconURL = 'https://static-assets
                                    .codecademy.com/Courses/Learn-Redux/
                                    Recipes-App/icons/favorite.svg';
            
            export const AllRecipes = () => {
                const allRecipes = useSelector(selectFilteredAllRecipes);
                const dispatch = useDispatch();
            
                const onFirstRender = () => {
                    dispatch(loadData());
                }
                useEffect(onFirstRender, []);
                
                const onAddRecipeHandler = (recipe) => {
                    dispatch(addRecipe(recipe));
                };
            
                return (
                    < div className="recipes-container" >
                        {allRecipes.map((recipe) => (
                        < Recipe recipe={recipe} key={recipe.id}>
                            < FavoriteButton
                                onClickHandler={() => onAddRecipeHandler(recipe)}
                                icon={favoriteIconURL}
                                >
                                Add to Favorites
                            < /FavoriteButton >
                        < /Recipe >
                        ))}
                    < /div >
                );
            };            
                        </code>
                    </pre>
                </ul>
                <hr/>
                <li>Redux Tolkit</li>
                <ul>
                    <li><strong>createSlice()</strong></li>
                    <ul>
                        <pre>
                            <code>
                /* todosSlice.js */

                const options = {
                    name: 'todos',
                    initialState: [],
                    reducers: {
                        addTodo: (state, action) => {
                            return [
                            ...state,
                            {
                            id: action.payload.id,
                            text: action.payload.text,
                            completed: false
                            }
                        ]
                    },
                    toggleTodo: (state, action) => {
                        return state.map(todo =>
                        (todo.id === action.payload.id) ? { 
                        ...todo, completed: !todo.completed } : todo
                        )
                    }
                }
                }
                    
                    const todosSlice = createSlice(options);
                            </code>
                        </pre>
                        <li>someSlice.reducer needs to be exported so that it can be passed to the store and be used as the todos slice of state. While the todosSlice.actions are exported as named exports, the todosSlice.reducer value is used as the default export.</li>
                        <pre>
                            <code>
                        export const { addTodo, toggleTodo } = todosSlice.actions;
                        export default todosSlice.reducer
                            </code>
                        </pre>
                        <li>With <strong>Immer</strong>, it's possible to safely mutate, 
                        and use array.push(). 
                        Example:</li>
                        <pre>
                            <code>
            const options = {
                name: "favoriteRecipes",
                initialState: [],
                reducers: {
                    addRecipe: (state, action) => {
                        //With Immer within createSlice, it's possible to mutate
                            with array.push.  
                        return state.push(action.payload);
                    },
                    removeRecipe: (state, action) => {
                        return state.filter(recipe =>
                            recipe.id !== action.payload.id)
                        },
                },
            }
                            </code>
                        </pre>
                    </ul>
                    <li><strong>configureStore()</strong></li>
                    <ul>
                        <li>It combines todosReducer and filtersReducer into the root reducer function, which will handle a root state that looks like {todos, filters}, removing the need to call combineReducers()</li>
                        <li>It creates a Redux store using that root reducer, removing the need to call createStore()</li>
                        <li>It automatically adds the thunk middleware</li>
                        <li>It automatically adds more middleware to check for common mistakes like accidentally mutating the state</li>
                        <li>It automatically sets up the Redux DevTools Extension connection</li>
                    </ul>
                    Because of how much boilerplate code we’re able to bypass with configureStore(), we can just import the individual slice reducers straight into this file instead of creating a separate file for the root reducer and having to export/import it.
                    <pre>
                        <code>
                import { configureStore } from '@reduxjs/toolkit'
                import todosReducer from './features/todos/todosSlice'
                import filtersReducer from './features/filters/filtersSlice'
                
                const store = configureStore({
                    reducer: {
                        // Define a top-level state field named `todos`, 
                            handled by `todosReducer`
                        todos: todosReducer,
                        filters: filtersReducer
                    }
                })
                
                export default store
                        </code>
                    </pre>
                    <li>Using combineReducers</li>
                    <pre>
                        </code>
                        export default configureStore({
                            reducer: combineReducers({
                                reddit: redditReducer,
                                subreddits: subRedditReducer,
                            }),
                        });  
                        </code>
                    </pre>
                </ul>
                    <hr/>
                    <li><strong>applyMiddleware</strong></li>
                    <pre>
                        <code>
            import { createStore, applyMiddleware } from 'redux';

            const messageReducer = (state = '', action) => {
                if (action.type === 'NEW_MESSAGE') {
                    return action.payload;
                } else {
                    return state;
                }
            }

            const logger = storeAPI => next => action => {
                const nextState = next(action) 
                return nextState;
            };

            const store = createStore(messageReducer, '', applyMiddleware(logger));

            store.dispatch({
                type: "NEW_MESSAGE",
                payload: "I WROTE A MIDDLEWARE"
            })

                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Redux Thunks</strong> (for async)</li>
                    <pre>
                        <code>
            const remindMeTo = task => {
                return `Remember to ${task}!!!`;
            }
            
            const remindMeLater = (task) => {
                return () => {
                    return remindMeTo(task);
                }
            }
            
            const reminder = remindMeLater();

                        </code>
                    </pre>
                    <li>If dispatch receives a function, the middleware invokes it; if it receives a plain object, 
                    then it passes that action along to reducers to trigger state updates.</li>
                    <pre>
                        <code>

            import { fetchUser } from './api'

            const getUser = (id) => {
            return async (dispatch, getState) => {
                    const payload = await fetchUser(id);
                    dispatch({type: 'users/addUser', payload: payload});
                }
            }
                        </code>
                    </pre>
                    <li>try & catch</li>
                    <pre>
                        <code>
            import { fetchUser } from './api';

            const fetchUserById = (id) => {
                return async (dispatch, getState) => {
                    dispatch({type: 'users/requestPending'})
                    try {
                        const payload = await fetchUser(id)
                        dispatch({type: 'users/addUser', payload: payload})
                    } catch(err) {
                        dispatch({type: 'users/error', payload: err})
                    }
                }
            }
                        </code>
                    </pre>
                    <li>Promisse handled with <strong>createAsyncThunk()</strong>.</li>
                    <ul>
                        <li>If you need to access the individual 
                        pending/fulfilled/rejected action creators, you can 
                        reference them like this:</li>
                        <pre>
                            <code>
                    fetchUserById.pending
                    fetchUserById.fulfilled
                    fetchUserById.rejected
                            </code>
                        </pre>
                    </ul>
                    <pre>
                        <code>
                import { createAsyncThunk } from '@reduxjs/toolkit'
                import { fetchUser } from './api'

                const fetchUserById = createAsyncThunk(
                    'users/fetchUserById', // action type
                    async (arg, thunkAPI) => { 
                        // payload creator
                        const response = await fetchUser(arg);
                        return response.json();
                    }
                )
                        </code>
                    </pre>
                    <li><strong>createAsyncThunk </strong>& <strong>extraReducers</strong></li>
                    <pre>
                        <code>
            const fetchUserById = createAsyncThunk(
                'users/fetchUserById',
                async (userId) => {
                    const users = await fetch(`api/users${userId}`)
                    const data = await users.json()
                    return data
                }
            )

            const usersSlice = createSlice({
                name: 'users',
                initialState: { 
                        users:  [], 
                        isLoading: false, 
                        hasError: false 
                },
                reducers: {
                        addUser: (state, action) => { 
                        state.users.push(action.payload) 
                    }        
                },
                extraReducers: {
                    [fetchUserById.pending]: (state, action) => {
                        state.isLoading = true;
                        state.hasError = false;
                    },
                    [fetchUserById.fulfilled]: (state, action) => {
                        state.users.push(action.payload);
                        state.isLoading = false;
                        state.hasError = false;
                    },
                    [fetchUserById.rejected]: (state, action) => {
                        state.isLoading = false;
                        state.hasError = true;
                    }
                }
            })
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>File Structure</strong> for Redux example:</li>
                    <pre>
                        <code>
                    src/
                    |-- index.js
                    |-- app/
                        |-- App.js (+)
                        |-- store.js
                    |-- components/
                        |-- FavoriteButton.js (+)
                        |-- Recipe.js (+)
                    |-- features/
                        |-- allRecipes/
                            |-- AllRecipes.js (+)
                            |-- allRecipesSlice.js
                        |-- favoriteRecipes/
                            |-- FavoriteRecipes.js (+)
                            |-- favoriteRecipesSlice.js
                        |-- searchTerm/
                            |-- SearchTerm.js (+)
                            |-- searchTermSlice.js
                    

                    * Index.js: Is the entry point for the entire application. 
                                It passes the current state and dispatch 
                                from the store downwards to the app.
                                (This isn’t ideal considering that the top-level 
                                component doesn’t make use of those props.)
                    * App.js: As in most React applications, this top-level component 
                                will render each feature-component and pass any 
                                data needed by those components as prop values.
                    * Store.js: Import featureASlice & featureBSlice to store.
                                Use combineReducers().
                    * Feature.js: Render component. App.js pass to them the slice
                                of the store's state to be rendered
                                and the store.dispatch method to trigger state changes through user 
                                interactions within the component.
                                (dispatch and current state firstly comes from index.js).
                    * featuresSlices.js: Contain all of the code relating to each individual slice,
                                including the Action Creators.
                        </pre>
                    </code>
                    <hr/>
                    <li><strong>Implementation</strong> of React Redux Library:</li>
                    <ul>
                        <li><strong>Install</strong> the redux library into your project using npm install redux.</li>
                        <li>Import the createStore() helper function from the 'redux' library.</li>
                        <li><strong>Create a store</strong> object that holds the entire state of your Redux application using createStore().</li>
                        <li>Get the <strong>current state</strong> of the store using store.getState().</li>
                        <li><strong>Dispatch actions</strong> to the store using store.dispatch(action).</li>
                        <li>Create <strong>action creators</strong> to reduce the repetitive creation of action objects.</li>
                        <li>Register a <strong>change listener</strong> function to respond to changes to the store using store.subscribe(listener).</li>
                        <li>Recognize the pattern for connecting Redux to any user interface.</li>
                        <li>Implement a Redux application using either the <strong>HTML DOM API<strong> or <strong>React</strong>.</li>
                    </ul>
                    <li><strong>Implementation</strong> of React Redux Toolkit:</li>
                    <ul>
                        <li>configureStore, createSlices (name, initialState, reducers), thunk, useSelector, useDispatch.</li>
                        <li>Download react Reducer using npm install react-redux.</li>
                        <li>Download react Toolkit using npm install @reduxjs/toolkit.</li>
                        <li>Create Store using configureStore.</li>
                        <li>Create Slices.</li>
                    </ul>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>Aditional Algorithms</h2>
            <ul>
                <li>
                    <div class="flex">
                            <p>Auth & password Conditional</p>
                            <button id="showCode19" onclick="showCode('displayCode19', 'showCode19')">Display</button>
                    </div>
                </li>
                <div id="displayCode19">
                    <button onclick="closeCode('displayCode19', 'showCode19')">Close</button>
                    <pre>
                        <code>
                class Contact extends React.Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            password: 'swordfish',
                            authorized: false
                        };
                        this.authorize = this.authorize.bind(this);
                    }
                    
                    authorize(e) {
                        const password = e.target.querySelector(
                        'input[type="password"]').value;
                        const auth = password == this.state.password;
                        this.setState({
                        authorized: auth
                        });
                    }
                    
                    render() {
                        let login = (
                        < form action="#" >
                            < input type='password' placeholder='Password' />
                            < input type='submit' onSubmit={this.authorize} />
                        < /form >
                        );
                        let contactInfo = (
                            < ul >
                            < li >
                                client@example.com
                            < /li >
                            < li >
                                555.555.5555
                            < /li >
                            < /ul >
                        );
                    
                        return (
                        < div id="authorization" >
                            < h1 >{this.state.authorized ? "Contact" : "Enter the Password"}< /h1 >
                            {this.state.authorized ? contactInfo : login}
                        < /div >
                        );
                    }
                    }   
                        </code>
                    </pre>
                </div>
                <li>
                    <div class="flex">
                            <p>Api Interaction</p>
                            <button id="showCode24" onclick="showCode('displayCode24', 'showCode24')">Display</button>
                    </div>
                </li>
                <div id="displayCode24">
                    <button onclick="closeCode('displayCode24', 'showCode24')">Close</button>
                    <pre>
                        <code>
            export default function SocialNetwork() {

                const [menu, setMenu] = useState(null);
                
                useEffect(() => {
                    get('/menu').then((response) => {setMenu(response.data)});
                }, []);
                
                const [newsFeed, setNewsFeed] = useState(null);
                
                useEffect(() => {
                    get('/news-feed').then((response) => {setNewsFeed(response.data)}); 
                }, []);
                
                const [friends, setFriends] = useState(null);
                useEffect(() => {
                    get('/friends').then((response) => {setFriends(response.data)});
                }, []);
                
                return (
                    < div className='App' >
                        < h1 > My Network < /h1 >
                        {!menu ? < p >Loading..< /p > : (
                            < nav >
                            {menu.map((menuItem) => (
                                < button key={menuItem} > {menuItem} < /button >
                            ))}
                            < /nav >
                        )}
                        < div className='content' >
                            {!newsFeed ? < p >Loading..< /p > : (
                            < section >
                                {newsFeed.map(({ id, title, message, imgSrc }) => (
                                < article key={id} >
                                    < h3 >{title}< /h3 >
                                    < p >{message}< /p >
                                    < img src={imgSrc} alt='' />
                                < /article >
                                ))}
                            < /section >
                            )}
                            {!friends ? < p >Loading..< /p > : (
                            < aside >
                                < ul >
                                {friends
                                    .sort((a, b) => (a.isOnline && !b.isOnline ? -1 : 0))
                                    .map(({ id, name, isOnline }) => (
                                    < li key={id} className={isOnline ? 'online' : 'offline'}>
                                        {name}
                                    < /li >
                                    ))}
                                < /ul >
                            < /aside >
                            )}
                        < /div >
                    < /div >
                );
            }
                        </code>
                    </pre>
                </div>
            </ul>
        </div>
    </body>
</html>
