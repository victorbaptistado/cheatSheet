<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="./component/button.js" defer></script>
        <title>React</title>
    </header>
    <body>
        <nav>
            <ul class="mainNav">
                <li><a href="./index.html">Cheat Sheet</a></li>
                <li><a href="./displayProperties.html">Display Properties</a></li>
                <li><a href="./objects.html">Objects</a></li>
                <li><a href="./developmentCycle.html">Development Cycle</a></li>
                <li><a href="./debug.html">Debug</a></li>
                <li><a href="./git.html">Git</a></li>
                <li><a href="./form.html">Form</a></li>
                <li><a href="./api.html">API</a></li>
                <li><a href="#">REACT</a></li>                 
            </ul>
        </nav>
        <header>
            <h1>React</h1>
        </header>
        <div class="styleGuide">
            <h2>Virtual DOM</h2>
            <ul>
                <li><strong>Virtual DOM (VDOM)</strong> is React’s local and simplified copy of the HTML DOM. 
                A programming concept where an ideal, or “virtual”, 
                representation of a UI is kept in memory and synced with the “real” DOM by a library 
                such as ReactDOM.</li>
                <li>When you render a JSX element, every single virtual DOM object gets updated.
                This sounds incredibly inefficient, but the cost is insignificant because the virtual DOM 
                can update so quickly.</li>
                <li>Once the virtual DOM has updated, then React compares 
                the virtual DOM with a virtual DOM snapshot that was taken right before the update.
                By comparing the new virtual DOM with a pre-update version, React figures out exactly 
                which virtual DOM objects have changed. This process is called “diffing.”</li>
                <li>Once React knows which virtual DOM objects have changed, then React updates 
                those objects, and only those objects, on the real DOM. In our example from</li>
            </ul>
            <hr/>
            <h3>JSX</h3>
            <ul>
                <li>JSX (JavaScript XML) allows us to write HTML elements in JavaScript 
                and place them in the DOM without any createElement() and/or appendChild() methods.
                JSX converts HTML tags into react elements.</li>
                <li>To render <strong>logic</strong>, if we want any expression to be treated as 
                JavaScript inside of a JSX element we need to wrap it in curly braces.</li>
            </ul>
            <hr/>
            <h2>State</h2>
            <ul>
                <li>A React app is basically just a lot of <strong>components</strong>, setting <strong>state</strong> and passing <strong>props</strong> to one another.</li>
                <li>There are two ways for a component to get dynamic 
                information: <strong>props</strong> and <strong>state</strong>. Besides props and state, 
                every value used in a component should always stay exactly 
                the same.</li>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Often used in React</h2>
            <h3>Destructuring</h3>
            <ul>
                <li>React relies on many destructuring techniques.</li>
                <li>Destructuring, or destructuring assignment, is a JavaScript feature that makes it 
                easier to extract data from arrays and objects and assign them to variables or parameters. 
                Is a syntactic sugar introduced in the ES6 version of JavaScript.</li>
                <p class="center"><strong>Array destructuring</strong>, <strong>Object destructuring</strong>,
                <strong>Function Parameters destructuring</strong></strong></p>
                <button id="showCode16" onclick="showCode('displayCode16', 'showCode16')">Display</button>
                <div id="displayCode16">
                    <button onclick="closeCode('displayCode16', 'showCode16')">Close</button>
                    <pre>
                        <code>
                        //Array Destructuring
                        let cars = ['ferrari', 'tesla', 'cadillac'];
                        let [car1, car2, car3] = cars;
                        console.log(car1, car2, car3); // Prints: ferrari tesla cadillac
                        </code>
                    </pre>
                    <pre>
                        <code>
                        //Object Destructuring
                        let destinations = { x: 'LA', y: 'NYC', z: 'MIA' };
                        let { x, y, z } = destinations;
                        console.log(x, y, z); // Prints LA NYC MIA
                        </code>
                    </pre>
                    <pre>
                        <code>
                        //Destructuring Function Parameters (Function arguments are another place 
                        where destructuring is useful. Instead of accepting a complete object as 
                        an argument, a function can use destructuring to capture specific properties 
                        as named parameters.

                        let truck = {
                        model: '1977 Mustang convertible',
                        city: 'Detroit',
                        convertible: true
                        };
                        
                        const printCarInfo = ({model, city}) => {
                        console.log(`The ${model} is in the city ${city}.`);
                        };
                        </code>
                    </pre>
                </div>
            </ul>
            <hr/>
            <h3>Ternary and && conditionals</h3>
            <pre>
                <code>
                // Ternary, to output a condition if valued true, otherwise another will be set. 

                {!judgmental ? 
                    < li > Nacho Cheez Straight Out The Jar < /li > : < li > Second option < /li >
                }
                </code>
            </pre>
            <pre>
                <code>
                // && conditional, to use if a single condition is set to appear or not.

                {!judgmental && 
                    < li >Nacho Cheez Straight Out The Jar < /li >
                }
                </code>
            </pre>
            <hr/>
            <h3>.map</h3>
            <ul>
                <li>To create a list of JSX elements .map() is often your best bet.</li>
                <li><strong>Keys</strong>: Not all lists need to have keys. 
                A list needs keys if:
                <ul>
                    <li>The list-items have memory from one render to the next. 
                    For instance, when a to-do list renders, each item must “remember” 
                    whether it was checked off.
                    </li> 
                    <li>The items shouldn’t get amnesia when they render.
                    A list’s order might be shuffled. For instance, a list of search results 
                    might be shuffled from one render to the next.
                    </li>
                </ul>
            </ul>
            <p class="center"></p>
            <button id="showCode17" onclick="showCode('displayCode17', 'showCode17')">Display</button>
            <div id="displayCode17">
                <button onclick="closeCode('displayCode17', 'showCode17')">Close</button>
                <pre>
                    <code>
                    const strings = ['Home', 'Shop', 'About Me'];
                    const listItems = strings.map(string => < li >{string} < /li >);

                    < ul > {listItems} < /ul >

                    //using Key

                    const peopleLis = people.map((person, i) =>
                    < li key={'person_' + i} > {person} < /li >
                    );
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>Variable Attribute in a Component</h3>
            <li>We can use variables, including object properties, to set a component’s attributes 
            to keep component easy to read and organized, but more importantly, 
            so that our attributes can be dynamic and/or can be changed easily!</li>
            <button id="showCode18" onclick="showCode('displayCode18', 'showCode18')">Display</button>
            <div id="displayCode18">
                <button onclick="closeCode('displayCode18', 'showCode18')">Close</button>
                <pre>
                    <code>
                        const redPanda = {
                            src: 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Endangered_Red_Panda.jpg',
                            alt: 'Red Panda',
                            width:  '200px'
                        };
                        
                        class RedPanda extends React.Component {
                            render() {
                            return (
                                < div >
                                < h1 >Cute Red Panda< /h1 >
                                < img 
                                    src={redPanda.src}
                                    alt={redPanda.alt}
                                    width={redPanda.width} />
                                < /div >
                            );
                            }
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>Event handler</h3>
            <ul>
                <li><strong>Multiple event handler</strong>: By passing an anonymous function, 
                or a named function, 
                with multiple event handler calls as the function body, to our event listener 
                (like onClick, onKeyUp, onChange, etc) 
                we can call multiple event handlers in response to a single event.</li>
            </ul>
            <pre>
                <code>
                return (
                //Underneath, an anonymous function with multiple event handlers.
                    < button onClick={() => {         
                        this.eventHandler1();
                        this.eventHandler2();
                    }}>Here's a button!</ button> 
                )
                </code>
            </pre>
            <hr/>
            <h3>Style Object</h3>
            <ul>
                <li>For longer styles, it's a good idea to create an <strong>style object.</strong></li>
                <li>One way to make <strong>styles reusable</strong> is to keep them in a 
                <strong>separate JavaScript file.</strong> 
                This file should export the styles that you want to reuse, via export. 
                You can then import your styles into any component that wants them.</li>
            </ul>
            <button id="showCode25" onclick="showCode('displayCode25', 'showCode25')">Display</button>
            <div id="displayCode25">
                <button onclick="closeCode('displayCode25', 'showCode25')">Close</button>
                <ul>
                    <li>Style object</li>
                    <pre>
                        <code>
                    const styles = {
                        color: 'darkcyan',
                        background: 'mintcream'
                    };
                    
                    export class StyledClass extends React.Component {
                        render() {
                        return (
                            < h1 style={styles} >
                            Hello world
                            < /h1 >
                        );
                        }
                    }
                        </code>
                    </pre>
                    <hr/>
                    <li>Style module</li>
                    <pre>
                        <code>
                    const fontFamily = 'Comic Sans MS, Lucida Handwriting, cursive';
                    const background = 'pink url
                    ("https://content.codecademy.com/programs/react/images/welcome-to-my-homepage.gif") fixed';
                    const fontSize = '4em';
                    const padding = '45px 0';
                    const color = 'green';

                    export const styles = {
                        fontFamily: fontFamily,
                        background: background,
                        fontSize:   fontSize,
                        padding:    padding,
                        color:      color
                    };
                        </code>
                    </pre>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>Aditional Algorithms</h2>
            <ul>
                <li>
                    <div class="flex">
                            <p>Auth & password Conditional</p>
                            <button id="showCode19" onclick="showCode('displayCode19', 'showCode19')">Display</button>
                    </div>
                </li>
                <div id="displayCode19">
                    <button onclick="closeCode('displayCode19', 'showCode19')">Close</button>
                    <pre>
                        <code>
                class Contact extends React.Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            password: 'swordfish',
                            authorized: false
                        };
                        this.authorize = this.authorize.bind(this);
                    }
                    
                    authorize(e) {
                        const password = e.target.querySelector(
                        'input[type="password"]').value;
                        const auth = password == this.state.password;
                        this.setState({
                        authorized: auth
                        });
                    }
                    
                    render() {
                        let login = (
                        < form action="#" >
                            < input type='password' placeholder='Password' />
                            < input type='submit' onSubmit={this.authorize} />
                        < /form >
                        );
                        let contactInfo = (
                            < ul >
                            < li >
                                client@example.com
                            < /li >
                            < li >
                                555.555.5555
                            < /li >
                            < /ul >
                        );
                    
                        return (
                        < div id="authorization" >
                            < h1 >{this.state.authorized ? "Contact" : "Enter the Password"}< /h1 >
                            {this.state.authorized ? contactInfo : login}
                        < /div >
                        );
                    }
                    }   
                        </code>
                    </pre>
                </div>
                <li>
                    <div class="flex">
                            <p>Api Interaction</p>
                            <button id="showCode24" onclick="showCode('displayCode24', 'showCode24')">Display</button>
                    </div>
                </li>
                <div id="displayCode24">
                    <button onclick="closeCode('displayCode24', 'showCode24')">Close</button>
                    <pre>
                        <code>
            export default function SocialNetwork() {

                const [menu, setMenu] = useState(null);
                
                useEffect(() => {
                    get('/menu').then((response) => {setMenu(response.data)});
                }, []);
                
                const [newsFeed, setNewsFeed] = useState(null);
                
                useEffect(() => {
                    get('/news-feed').then((response) => {setNewsFeed(response.data)}); 
                }, []);
                
                const [friends, setFriends] = useState(null);
                useEffect(() => {
                    get('/friends').then((response) => {setFriends(response.data)});
                }, []);
                
                return (
                    < div className='App' >
                    < h1 > My Network < /h1 >
                    {!menu ? < p >Loading..< /p > : (
                        < nav >
                        {menu.map((menuItem) => (
                            < button key={menuItem} > {menuItem} < /button >
                        ))}
                        < /nav >
                    )}
                    < div className='content' >
                        {!newsFeed ? < p >Loading..< /p > : (
                        < section >
                            {newsFeed.map(({ id, title, message, imgSrc }) => (
                            < article key={id} >
                                < h3 >{title}< /h3 >
                                < p >{message}< /p >
                                < img src={imgSrc} alt='' />
                            < /article >
                            ))}
                        < /section >
                        )}
                        {!friends ? < p >Loading..< /p > : (
                        < aside >
                            < ul >
                            {friends
                                .sort((a, b) => (a.isOnline && !b.isOnline ? -1 : 0))
                                .map(({ id, name, isOnline }) => (
                                < li key={id} className={isOnline ? 'online' : 'offline'}>
                                    {name}
                                < /li >
                                ))}
                            < /ul >
                        < /aside >
                        )}
                    < /div >
                    < /div >
                );
                }
                        </code>
                    </pre>
                </div>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Programming Patterns</h2>
            <ul>
                <li><strong>Stateful & Stateless</strong> pattern: a <strong>programming pattern</strong> uses two React components: a <strong>stateful 
                component</strong>, and a <strong>stateless component</strong>. “Stateful” describes any 
                component that has a state property; “stateless” describes any component that does not.</li>
                <li>Components should only have <strong>one job</strong>.
                You should divide child in two: one will have one stateless component <strong>display information</strong>, 
                and a different stateless component offer the ability to <strong>change that information</strong>. e.g: A Video Player & a Menu to change its settings.</li>
                <li><strong>How does a component change its props?</strong> The answer: it doesn’t!
                A component should never update this.props.
                A React component should use props to store information that 
                can be changed, but can only be changed by a different component.
                A React component should use state to store information that 
                the component itself can change.</li>
            </ul>
            <p class="center">Forms of <strong>Components Update Parents'</strong> state</p>
            <button id="showCode20" onclick="showCode('displayCode20', 'showCode20')">Display</button>
            <div id="displayCode20">
                <button onclick="closeCode('displayCode20', 'showCode20')">Close</button>
                <ul>
                    <li><p>The parent component class defines a method that calls this.setState().</p>
                    </li>
                    <li><p>The parent component binds the newly-defined method to the current 
                        instance of the component in its constructor. This ensures that when 
                        we pass the method to the child component, it will still update the 
                        parent component. </p>
                    </li>
                    <li><p>The child receives the passed-down function, and uses it as an event handler.
                        When a user clicks on the < button > < /button >, a click event 
                        will fire. This will make the passed-down function get called, which will update 
                        the parent’s state.</p>
                    </li>
                        <pre>
                            <code>                              
                            class ParentClass extends React.Component {
                                constructor(props) {
                                    super(props);
                                    this.state = { totalClicks: 0 };
                                    this.handleClick = this.handleClick.bind(this);
                                }
                            
                                handleClick() {
                                    const total = this.state.totalClicks;
                                
                                    // calling handleClick will 
                                    // result in a state change:
                                    this.setState(
                                        { totalClicks: total + 1 }
                                    );
                                }
                            
                                // The stateful component class passes down
                                // handleClick to a stateless component class:
                                render() {
                                    return (
                                        < ChildClass onClick={this.handleClick} />
                                    );
                                }
                            } 
                            </code>
                        </pre>
                    </li>
                    <li><p>The child receives the passed-down function, and uses it as an event handler.
                        When a user clicks on the < button></button >, a click event will fire. This will make the passed-down function get called, which will update the parent’s state.</p>
                        <pre>
                            <code>
                            export class ChildClass extends React.Component {
                                render() {
                                    return (
                                    // The stateless component class uses
                                    // the passed-down handleClick function,
                                    // accessed here as this.props.onClick,
                                    // as an event handler:
                                    < button onClick={this.props.onClick}>
                                        Click Me!
                                    < /button >
                                    );
                                }
                            }
                            </code>
                        </pre>
                    </li>
                </ul>
            </div>
            <hr/>
            <h3>#1 Presentational components and Container components.</h3>
            <ul>
                <li>Separating <strong>container components</strong> from <strong>presentational components</strong> 
                is a popular React programming pattern. </li>
                <li>The <strong>functional part</strong> of a component (state, calculations, etc.) 
                can be separated into a <strong>container component</strong>. 
                If a component has to have state, make calculations based on props, 
                or manage any other complex logic, then that component shouldn’t also 
                have to render HTML-like JSX. <strong>Presentational component's</strong>
                only job is to contain JSX - it should be an exported component and will not render 
                itself because a presentational component will always 
                get rendered by a container component.</li>
                <li>You want to separate the logic of this component class into a container component.
                Create a <strong>container folder</strong> and a <strong>component folder.</strong>
                To start, just make a copy. After that, you can delete the appropriate parts.
                E.g: Highlight the entire contents of components/GuineaPigs.js, and copy it to the clipboard.
                Now, open containers/GuineaPigsContainer.js.
                Click inside the empty file, and paste. containers/GuineaPigsContainer.js 
                and components/GuineaPigs.js should be identical.</li>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode26" onclick="showCode('displayCode26', 'showCode26')">Display</button>
                <div id="displayCode26">
                    <button onclick="closeCode('displayCode26', 'showCode26')">Close</button>
                    <ul>
                        <li>Container component</li>
                        <pre>
                            <code>
                    import React from 'react';
                    import ReactDOM from 'react-dom';
                    import { GuineaPigs } from '../components/GuineaPigs';
                    
                    const GUINEAPATHS = [
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-1.jpg',
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-2.jpg',
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-3.jpg',
                    'https://content.codecademy.com/courses/React/react_photo-guineapig-4.jpg'
                    ];
                    
                    class GuineaPigsContainer extends React.Component {
                    constructor(props) {
                        super(props);        
                        this.state = { currentGP: 0 };
                        this.interval = null;
                        this.nextGP = this.nextGP.bind(this);
                    }
                    
                    nextGP() {
                        let current = this.state.currentGP;
                        let next = ++current % GUINEAPATHS.length;
                        this.setState({ currentGP: next });
                    }
                    
                    componentDidMount() {
                        this.interval = setInterval(this.nextGP, 5000);
                    }
                    
                    componentWillUnmount() {
                        clearInterval(this.interval);
                    }
                    
                    render() { 
                        const src = GUINEAPATHS[this.state.currentGP]; 
                        return < GuineaPigs src={src} />;
                    }
                    }
                    
                    ReactDOM.render(
                        < GuineaPigsContainer / >, 
                        document.getElementById('app')
                    );
                            </code>
                        </pre>
                    </ul>
                    <ul>
                        <li>Presentational component</li>
                        <pre>
                            <code>
                                import React from 'react';
                                export class GuineaPigs extends React.Component {
                                
                                  render() {
                                    let src = this.props.src;
                                    return (
                                      < div >
                                        < h1 >Cute Guinea Pigs< /h1 >
                                        < img src={src} />
                                      < /div >
                                    );
                                  }
                                }
                            </code>
                        </pre>
                    </ul>
                </div>
                <li>More material:</li>
                <ul>
                    <li><a href="https://medium.com/@learnreact/container-components-c0e67432e005" target="_blank">Container components</a></li>
                    <li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank">Presentational and Container components</a></li>
                </ul>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>React's Lifecycle</h2>
            <ul>
                <li>The first phase of a component’s lifecycle is the <strong>Mounting phase</strong>. 
                    This is when a component is created and inserted into the DOM. The methods that run 
                    during this phase, in order, are:</li>
                <pre>
                    <code>
                    componentWillMount()
                    constructor()
                    render()
                    componentDidMount()
                    </code>
                </pre>
                <li>
                    The next phase of a component’s lifecycle is the <strong>Updating phase</strong>. 
                    This is when a component undergoes any changes to props or state. This phase is the main part of a 
                    component’s life, and the following methods will be 
                    invoked repeatedly at each change,
                </li>
                <pre>
                    <code>
                    componentWillReceiveProps()
                    shouldComponentUpdate()
                    render()
                    componentDidUpdate()
                    </code>
                </pre>
                <li>
                    The last phase of a component’s lifecycle is <strong>Unmounting</strong>. This is when 
                    component is removed from the DOM, and the only method run during this phase is
                </li>
                <pre>
                    <code>
                    componentWillUnmount().
                    </code>
                </pre>
                <li><strong>Side effects</strong> should be separated from the rendering process. 
                If we need to perform a side effect, it should strictly be done after our component renders.
                This is what useEffect gives us.
                In short, useEffect is a tool that lets us interact with the outside 
                world but not affect the rendering or performance of the component that it's in.</li>
                <a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/" target="_blank">Lifecycle's interactive diagram.</a>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Hooks</h2>
            <ul>
                <li><strong>React Hooks</strong> are functions that let us manage the internal state of 
                components and handle post-rendering side effects directly from our function components. 
                Hooks don’t work inside classes — they let us use fancy React features without classes.
                <u>Function components and React Hooks do not replace class components.</u> 
                They are completely optional; just a new tool that we can take advantage of.</li>
                <li>Hooks let us <strong>“hook into”</strong> state and lifecycle features directly from our function components.</li>
                <li><strong>Rules of Hooks:</strong> only call Hooks at the top level. Only call Hooks from React functions.</li>
                <li> React keeps track of the data and functions that we are managing 
                with Hooks based on their order in the function component’s definition. 
                For this reason, we always call our Hooks at the top level; we never call hooks 
                inside of loops, conditions, or nested functions.</li>
            </ul>
            <hr/>
            <h3>Function component</h3>
            <ul>
                <li><strong>Function components</strong> are React components defined as JavaScript functions that must return JSX.
                They may accept a props parameter (expect it to be a JavaScript object).</li>
                <li>Although <strong>function components</strong> and <strong>class components</strong> can do the same things, 
                some developers prefer function components over class components for their simplicity and straightforward features, 
                like Hooks.</li>
            </ul>
            <p class="center">Function component example:</p>
            <button id="showCode21" onclick="showCode('displayCode21', 'showCode21')">Display</button>
            <div id="displayCode21">
                <button onclick="closeCode('displayCode21', 'showCode21')">Close</button>
                <pre>
                    <code>
                        export class MyComponentClass extends React.Component {
                            render() {
                            return < h1 >Hello world< /h1 >;
                            }
                        }
                        
                        // The same component class, written as a stateless functional component:
                        export const MyComponentClass = () => {
                            return < h1 >Hello world< /h1 >;
                        }
                    </code>
                </pre>
            </div>
            <hr/>
            <h3>HOOKs list</h3>
            <ul>
                <li><strong>useState(): </strong>Updates state.</li>
                    <ul>
                        <li>Can be used with callbacks to update previous states 
                        (and setCount for example).</li>
                        <li>Use arrays and objects to organize and manage related data 
                        that tends to change together</li>
                    </ul>
                <p class="center"><strong>useState</strong>, <strong>Previous State</strong>, 
                <strong>Array in State</strong> & <strong>Object in State</strong> example:</p>
                <button id="showCode22" onclick="showCode('displayCode22', 'showCode22')">Display</button>
                <div id="displayCode22">
                    <button onclick="closeCode('displayCode22', 'showCode22')">Close</button>
                    <ul>
                        <li><strong>useState</strong></li>
                        <pre>
                            <code>                       
                            function Toggle() {
                                const [toggle, setToggle] = useState();
                                
                                return (
                                    < div >
                                        < p > The toggle is {toggle} < / p >
                                        < button onClick={() => setToggle("On")}> On < / button>
                                        < button onClick={() => setToggle("Off")}> Off < / button>
                                    < /div >
                                );
                            }
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Previous State callback</strong></li>
                        <pre>
                            <code>                       
                            export default function Counter() {
                                const [count, setCount] = useState(0);
                            
                                const increment = () => setCount(prevCount => prevCount + 1);
                            
                                return (
                                    < div >
                                        < p >Wow, you've clicked that button: {count} times < /p >
                                        < button onClick={increment}>Click here! < /button >
                                    < /div >
                                );
                            }
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Arrays in State:</strong>The best data model for managing and rendering JSX lists.</li>
                        <pre>
                            <code>
                            const options = ["Bell Pepper", "Sausage", "Pepperoni", "Pineapple"];

                            export default function PersonalPizza() {
                            const [selected, setSelected] = useState([]);
                            
                            const toggleTopping = ({target}) => {
                                const clickedTopping = target.value;
                                setSelected((prev) => {
                                    // check if clicked topping is already selected
                                    if (prev.includes(clickedTopping)) {
                                        // filter the clicked topping out of state
                                        return prev.filter(t => t !== clickedTopping);
                                    } else {
                                        // add the clicked topping to our state
                                        return [clickedTopping, ...prev];
                                    }
                                });
                            };
                            
                            return (
                                < div >
                                    {options.map(option => (
                                        < button value={option} onClick={toggleTopping} key={option} >
                                        {selected.includes(option) ? "Remove " : "Add "}
                                        {option}
                                        < /button >
                                ))}
                                < p > Order a {selected.join(", ")} pizza < /p >
                                </ div >
                            );
                            }
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Objects in State:</strong> When we work with a set of related variables, 
                        it can be very helpful to group them in an object. Let’s look at an example!</li>
                        <pre>
                            <code>
                            export default function Login() {
                            const [formState, setFormState] = useState({});
                            
                            const handleChange = ({ target }) => {
                                const { name, value } = target;
                                setFormState((prev) => ({
                                ...prev,
                                [name]: value
                                }));
                            };

                            return (
                                < form >
                                < input
                                    value={formState.firstName}
                                    onChange={handleChange}
                                    name="firstName"
                                    type="text"
                                />
                                < input
                                    value={formState.password}
                                    onChange={handleChange}
                                    type="password"
                                    name="password"
                                />
                                < /form >
                            );
                            }
                            </code>
                        </pre>
                    </ul>
                </div>
                <li><strong>useEffect(): </strong>by using this Hook, you tell React that your 
                component needs to do something <strong>after render</strong>. 
                React will remember the function 
                you passed (we'll refer to it as our “effect”), and call it later after performing 
                the DOM updates.</li>
                <ul>
                    <li>We can use the Effect Hook to run some JavaScript code after each render, such as:
                    Fetching data from a backend service.
                    Subscribing to a stream of data.
                    Managing timers and intervals.
                    Reading from and making changes to the DOM.</li>
                    <li>There are three <strong>key moments</strong> when the Effect Hook can be utilized:
                    When the component is first added, or mounted, to the DOM and renders.
                    When the state or props change, causing the component to re-render.
                    When the component is removed, or unmounted, from the DOM.</li>
                </ul>
                <p class="center"><strong>useEffect</strong> & <strong>API</strong> example:</p>
                <button id="showCode23" onclick="showCode('displayCode23', 'showCode23')">Display</button>
                <div id="displayCode23">
                    <button onclick="closeCode('displayCode23', 'showCode23')">Close</button>
                    <ul>
                        <li><strong>Dependency Array: </strong>Second argument of useEffect(), represented by: [].</li>
                        <pre>
                            <code>
                            useEffect(() => {
                                document.title = `Hi, ${name}`;
                                }, [name]);
                            </code>
                        </pre>
                        <li><strong>Undefined array: </strong>useEffect will be triggered every re-render (cleanup can be needed).</li>
                        <li><strong>Empty array: </strong>We pass an empty array (dependency array) 
                        to useEffect() as the second argument if we want to call our effect only after 
                        the first render (no cleanup is needed).</li>
                        <li><strong>Non-empty array: </strong>A dependency array that is not empty signals to the Effect Hook that 
                        it can skip calling our effect after re-renders unless the value of one 
                        of the variables in our dependency array has changed.
                        (no cleanup is needed).</li>
                        <hr/>
                        <li>Some effects require cleanup. For example, we might want to add 
                        event listeners to some element in the DOM, beyond the JSX in our component. 
                        When we add event listeners to the DOM, it is important to remove those 
                        event listeners when we are done with them to avoid memory leaks!</li>
                        <pre>
                            <code>
                            useEffect(() => {
                                document.addEventListener('mousedown', increment);
                                    return () => {
                                        document.removeEventListener('mousedown', increment);
                                    }
                                });
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>API interaction</strong> example:</li>
                        <pre>
                            <code>
                //Example 1 (Separation of concerns for EndPoints / State Variables)

                export default function SocialNetwork() {

                    const [menu, setMenu] = useState(null);
                    
                    useEffect(() => {
                        get('/menu').then((response) => {setMenu(response.data)});
                    }, []);
                    
                    const [newsFeed, setNewsFeed] = useState(null);
                    
                    useEffect(() => {
                        get('/news-feed').then((response) => {setNewsFeed(response.data)}); 
                    }, []);
                    
                    const [friends, setFriends] = useState(null);
                    useEffect(() => {
                        get('/friends').then((response) => {setFriends(response.data)});
                    }, []);
                    
                    return (
                        < div className='App' >
                        < h1 > My Network < /h1 >
                        {!menu ? < p >Loading..< /p > : (
                            < nav >
                            {menu.map((menuItem) => (
                                < button key={menuItem} > {menuItem} < /button >
                            ))}
                            < /nav >
                        )}
                        < div className='content' >
                            {!newsFeed ? < p >Loading..< /p > : (
                            < section >
                                {newsFeed.map(({ id, title, message, imgSrc }) => (
                                < article key={id} >
                                    < h3 >{title}< /h3 >
                                    < p >{message}< /p >
                                    < img src={imgSrc} alt='' />
                                < /article >
                                ))}
                            < /section >
                            )}
                            {!friends ? < p >Loading..< /p > : (
                            < aside >
                                < ul >
                                {friends
                                    .sort((a, b) => (a.isOnline && !b.isOnline ? -1 : 0))
                                    .map(({ id, name, isOnline }) => (
                                    < li key={id} className={isOnline ? 'online' : 'offline'}>
                                        {name}
                                    < /li >
                                    ))}
                                < /ul >
                            < /aside >
                            )}
                        < /div >
                        < /div >
                    );
                    }
                            </code>
                        </pre>
                        <pre>
                            <code>
                        //Example 2
                        
                        export default function Shop() {
                            const [categories, setCategories] = useState(null);
                            const [selectedCategory, setSelectedCategory] = useState(null);
                            const [items, setItems] = useState({});
                        
                        
                            useEffect(() => {
                            get('/categories').then((response) => {
                                setCategories(response.data);
                            });
                            }, []);
                        
                        
                            useEffect(() => {
                            if (selectedCategory && !items[selectedCategory]) {
                                get(`/items?category=${selectedCategory}`).then((response) => {
                                setItems((prev) => 
                                ({ ...prev, [selectedCategory]: response.data }));
                                });
                            }}, [selectedCategory, items]);
                            
                            
                            if (!categories) {
                                return < p >Loading..< /p >;
                            }
                            
                            return (
                                < div className='App' >
                                < h1 >Clothes 'n Things< /h1 >
                                < nav >
                                    {categories.map((category) => (
                                    < button key={category} 
                                    onClick={() => setSelectedCategory(category)}>
                                        {category}
                                    < /button >
                                    ))}
                                < /nav >
                                < h2 >{selectedCategory}</ h2 >
                                < ul >
                                    {!items[selectedCategory]
                                    ? null
                                    : items[selectedCategory].map((item) => 
                                    < li key={item}>{item}< /li >)}
                                < /ul >
                                < /div >
                            );
                        }
                            </code>
                        </pre>
                    </ul>
                </div>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>PropTypes</h2>
            <ul>
                <li><strong>PropTypes</strong> are useful for two reasons:
                <ul>
                    <li><strong>Prop validation.</strong>
                    Validation can ensure that your props are doing what they’re supposed to be doing. 
                    If props are missing, or if they’re present but they aren’t what you’re expecting, 
                    then a warning will print in the console.</li>
                    <li><strong>Documentation.</strong>
                    Documenting props makes it easier to glance at a file and quickly understand the 
                    component class inside. When you have a lot of files, and you will, this can be 
                    a huge benefit.</li>
                </ul>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode27" onclick="showCode('displayCode27', 'showCode27')">Display</button>
            <div id="displayCode27">
                <button onclick="closeCode('displayCode27', 'showCode27')">Close</button>
                <pre>
                    <code>
            import React from 'react';
            import PropTypes from 'prop-types';

            export class MessageDisplayer extends React.Component {
            render() {
                return (
                    <>
                    < input value={value} onChange={handleChange}/>
                    < h1 >{this.props.message}< /h1 >);
                    </>
            }
            }

            // This propTypes object should have
            // one property for each expected prop:
            MessageDisplayer.propTypes = {
                message: PropTypes.string,
                value: PropTypes.string.isRequired,
                handleChange: PropTypes.func.handleChange
            };
                    </code>
                </pre>
            </div>
        </div>
        <div class="styleGuide">
            <h2>React Form</h2>
            <ul>
                <li>In a React form, <u>you want the server to know about every new character or deletion,</u> 
                as soon as it happens (using <u>onChange</u>). That way, your screen will always be in sync 
                with the rest of your application (some third parties need to know what the user
                is typing, therefore we need to always use).</li>
            </ul>
            <hr/>
            <h3>Controlled vs Uncontrolled</h3>
            <ul>
                <li><strong>Uncontrolled component: </strong>A component that maintains 
                its own internal state. When < input / > keeps track of information makes it an 
                uncontrolled component. It maintains its own internal state, by remembering data about 
                itself.</li>
                <li><strong>Controlled component: </strong>A component that does not maintain 
                any internal state, it has no memory. Has its state controlled from outside, 
                through props. 
                In React, when you give an < input / > 
                a <u>value attribute</u>, then something strange happens: the < input / > BECOMES controlled. 
                It stops using its internal storage. E.g: value={this.props.userInput}. <u>This is a more ‘React’ way of doing things.</u></li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode28" onclick="showCode('displayCode28', 'showCode28')">Display</button>
            <div id="displayCode28">
                <button onclick="closeCode('displayCode28', 'showCode28')">Close</button>
                <pre>
                    <code>
                    export class Input extends React.Component {
                    constructor(props){
                        super(props);
                        this.state = {userInput: ''};
                        this.handleUserInput = this.handleUserInput.bind(this)
                    }

                    handleUserInput(e){
                        this.setState({userInput: e.target.value});
                    }

                    render() {
                        return (
                            < div >
                                // Notice "value" has its state stored on 
                                an outside prop, therefore making it
                                a controlled component
                                < input type="text" value={this.state.userInput} 
                                onChange={this.handleUserInput} />
                                < h1 >{this.state.userInput}< /h1 >
                            < /div >
                        );
                    }
                    }
                    </code>
                </pre>
            </div>
        </div>
        <div class="styleGuide">
            <h2>React Router</h2>
            <ul>
                <li><strong>React Router:</strong> Is a standard library 
                for routing in React. It enables the navigation among views 
                of various components in a React Application, allows changing 
                the browser URL, and keeps the UI in sync with the URL.
                <u>React Router treats everything as a component</u>. To get 
                fully comfortable using React Router in your code, you have 
                to embrace this idea and the declarative coding style that 
                follows from it.</li>
                <li><strong>Link & NavLink: </strong>Works just as < a > tag, 
                but avoids the reload rendering. NavLink's difference is that it 
                gives the navigation style.
                </li>
                <li><strong>Dynamic Routes: </strong>
                Specifying a unique route for every article would not only be 
                verbose and time-consuming, it would require an impractical 
                amount of maintenance should the path structure ever change.
                Instead, we would rather express the pattern at a high level 
                with a single route that 
                can match any path of the form '/articles/' + someTitle 
                and still know which article to render. React Router 
                allows us to do this by using URL parameters to create 
                dynamic routes.
                </li>
                <li><strong>useParams:</strong> It is common to use the 
                value of URL parameters to determine what is displayed 
                in the component that a dynamic route renders. 
                For example, the Article component might need to display 
                the title of the current article.
                React Router provides a hook, useParams(), for accessing 
                the value of URL parameters. When called, useParams() 
                returns an object that maps the names of URL Parameters to 
                their values in the current URL.</li>
                <li><strong>Switch:</strong> < Switch > renders the first child < Route > 
                or < Redirect > that matches the location. That's used
                when we want to render an exclusive path. It's organized from
                the most specific path to the most generic.</li>
                <li><strong>Nested Routes:</strong> As an 
                application grows in scope, it can be useful to split up 
                the router and write Routes nearer to where the related UI 
                logic is written.</li>
                <li><strong>useRouteMatch: </strong>
                Instead of writing out the full URL path for Nested routes, 
                it's more flexible to create relative paths based on 
                the /categories URL. React Router provides a hook, 
                useRouteMatch(), that makes it incredibly easy to do this.
                <ul>
                    <li><strong>Url: </strong>Has the actual value of 
                    route parameters filled in.
                    Useful for building nested < Link >s.</li>
                    <li><strong>Path: </strong>Leaves the names of the current URL’s URL 
                    parameters as-is. useful for building nested < Route >s.</li>
                </ul>
                <li><strong>Redirect:</strong> Is a routing component in React 
                Router Dom v5 that enables us to override the history 
                object and dynamically redirect a user from a route to a 
                new route.
                <u>The <strong>< Redirect /></strong> component has been 
                deprecated and replaced with React 
                <strong>< Navigate/ ></strong> in React Router v6.</u></li>
                <li><strong>useHistory: </strong> 
                Provides a mechanism for updating the browser’s location 
                imperatively.
                By enabling imperative updates to the browser location, 
                the history object allows you to respond immediately to user 
                input without having to wait.
                Browser history is a stack that stores the URLs visited 
                by the user and maintains a pointer to the user’s current 
                location. This history API allows you to navigate through 
                a user’s session history and alter the history stack if 
                necessary.</li>
                <li><strong>Query parameters: </strong>Appear in URLs 
                beginning with a question mark (?) and are followed 
                by a parameter name assigned 
                to a value. They are optional and are most often used 
                to search, sort and/or filter resources.
                React Router provides a mechanism for grabbing the values 
                of query parameters: the <strong>useLocation()</strong> hook.</li>
                <li>Download full <strong>React Route</strong> code example <a href="https://static-assets.codecademy.com/Courses/react-router/react-router-lesson-solution-1.zip?_gl=1*sz135p*_ga*MzUxOTc3MDY5My4xNjY2MDU2MTg3*_ga_3LRZM6TM9L*MTY3MzA5MzQ0Ni4xNzguMS4xNjczMDk1MDQ4LjYwLjAuMA..">here</a>
                    .
                </li>
            </ul>
            <p class="center"><strong>Examples:</strong></p>
            <button id="showCode29" onclick="showCode('displayCode29', 'showCode29')">Display</button>
            <div id="displayCode29">
                <button onclick="closeCode('displayCode29', 'showCode29')">Close</button>
                <ul>
                    <li><strong>useParams</strong></li>
                    <pre>
                        <code>
            export default function Article() {

                let { title } = useParams();
                // title will be equal to the string 'objects'
                
                // The title will be rendered in the < h1 >
                
                return (
                    < article >
                        < h1 >{title}< /h1 >
                    < /article >
                );
                }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Dynamic Routes</strong></li>
                    <pre>
                        <code>
                < Route path='/articles/<strong>:title</strong>' >
                    < Article />
                < /Route >
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Switch</strong></li>
                    <pre>
                        <code>
            < Switch >
                < div >
                    < Route path='/articles/:title' >
                        < Article />
                    < /Route >
                    < Route path='/articles/new' >
                        < NewArticle />
                    < /Route >
                    < Route path='/articles' >
                        < Articles />
                    < /Route >
                < /div >
            < /Switch >
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Nested Routes</strong> with <strong>useRouteMatch</strong></li>
                    <pre>
                        <code>
            function BandPage ({ songs }) {
            let { path, url } = useRouteMatch();
            
            // path = '/band/:band'
            // url = '/band/queen' 
            
            // Render a list of relative Links and a Route 
            to render a SongPage

            return (
                < div >
                    < ul >
                        {
                        songs.map(songName =>
                            < li >
                            < Link to={`<strong>${url}</strong>/song/${songName}`}> 
                                {category}
                            < /Link>
                            < /li>
                        )
                        }
                    < /ul >
            
                    < Route path={`<strong>${path}</strong>/song/:songName`}>
                        < SongPage />
                    < /Route>
                < /div>
            )
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Redirect</strong></li>
                    <pre>
                        <code>
            const UserProfile = ({ loggedIn }) => {
                if (!loggedIn) {
                    return (
                        < Redirect to='/' />
                    )
                }
                
            return (
                    // ... user profile contents here
                )  
            }
                        </code>
                    </pre>
                    <li><strong>Navigate</strong>(Loggin example)</li>
                    <pre>
                        <code>                         
            function App() {
                const navigate = useNavigate();
                const [isLoggedIn, setisLoggedIn] = useState(false);
            
                useEffect(() => {
                // Checking if user is not loggedIn
                if (!isLoggedIn) {
                    navigate("/");
                } else {
                    navigate("/login");
                }
                }, [navigate, isLoggedIn]);
            
                return (
                <>
                    < Routes >
                        < Route path='/' 
                            element={< h1 >Home Page Component< /h1 >} 
                        />
                        < Route path='/login' 
                            element={< h1 >Login Page Component< /h1 >} 
                        />
                        < Route path='*' 
                            element={< Navigate to='/' />} 
                        />
                    < /Routes>
            
                    {/* New line */}
                    {isLoggedIn || (
                    < button onClick={() => setisLoggedIn(true)}>
                        Log me in
                    < /button>
                    )}
                </>
                );
            }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>history.push(location)</strong> which 
                    redirects the user to the provided location.</li>
                    <li><strong>history.goBack()</strong> which navigates 
                    to the previous URL in the history stack</li>
                    <li><strong>history.goForward()</strong> which navigates 
                    to the next URL in the history stack.
                    </li>
                    <li><strong>history.go(n)</strong> which navigates n 
                    entries (where positive n values are forward and negative 
                    n values are backward) through the history stack.
                    </li>
                    <pre>
                        <code>
                            //history.push:

                            export const ExampleForm = () => {
 
                                const history = useHistory()
                               
                                const handleSubmit = e => {
                                  e.preventDefault();
                                  history.push('/')
                                }
                               
                                return (
                                  < form onSubmit={handleSubmit} >
                                        {/* form elements */ }
                                  < /form >
                                )
                              }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Query Parameter</strong> (useLocation)</li>
                    <pre>
                        <code>
                // Rendered when a user visits "/list?order=DESC"
                export const SortedList = (numberList) => {
                    const { search } = useLocation();
                    const queryParams = new URLSearchParams(search);
                    const sortOrder = queryParams.get('order');
                    
                    if (sortOrder === 'ASC') {
                    // render the numberList in ascending order
                    } else if (sortOrder === 'DESC') {
                    // render the numberList in descending order
                    } else {
                    // render the numberList as is
                    }
                }
                        </code>
                    </pre>
                </ul>
                </div>
            </ul>
        </div>
    </body>
</html>
