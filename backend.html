<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="./component/button.js" defer></script>
        <title>Backend</title>
    </header>
    <body>
        <nav>
            <ul class="mainNav">
                <li><a href="./index.html">Cheat Sheet</a></li>
                <li><a href="./displayProperties.html">Display Properties</a></li>
                <li><a href="./objects.html">Objects</a></li>
                <li><a href="./developmentCycle.html">Development Cycle</a></li>
                <li><a href="./debug.html">Debug</a></li>
                <li><a href="./git.html">Git</a></li>
                <li><a href="./form.html">Form</a></li>
                <li><a href="./api.html">API</a></li>
                <li><a href="./react.html">REACT</a></li>
                <li><a href="./helpfulContent.html">Helpful Content</a></li>
                <li><a href="#">Backend</a></li>
            </ul>
        </nav>
        <header>
            <h1>Backend</h1>
        </header>
        <div class="styleGuide">
            <h2>Node.js</h2>
            <ul>
                <li><strong>Node</strong> provides the ability to run JavaScript programs on our own computers instead of just in the browser's 
                    console or embedded in HTML.</li>
                    <ul>
                        <li>To <strong>run a program</strong> with node <i>$ node myProgram.js</i></li>
                    </ul>
                <li>Codecademy Material <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-introduction-to-back-end/modules/wdcp-22-back-end-javascript-with-node-js/cheatsheet" target="_blank">here</a></li>
                <li>Node.js Documentation <a href="https://nodejs.org/en/docs/" target="_blank">here</a>.</li>
            </ul>
            <hr/>
            <h3>REPL</h3>
            <ul>
               <li><strong>REPL</strong> is an abbreviation for <u>read-eval-print loop</u>. It's a program that loops, or 
                repeatedly cycles, through three different states: a read state where the program reads
                input from a user, the eval state where the program evaluates the user's input, and the
                print state where the program prints out its evaluation to a console.</li>
                <li>A REPL can be extremely useful for performing calculations, learning a language, and developing
                code. It’s a place where you can explore language features and try things out while receiving 
                immediate feedback.</li>
                <li>To access REPL, type <i>node</i> in the terminal.</li>
            </ul>
            <hr/>
            <h3>Modules</h3>
            <ul>
                <li><strong>Modules</strong> are reusable pieces of code in a file that can be exported and then
                imported for use in another file. A modular program is one whose components can be separated, 
                used individually, and recombined to create a complex system.
                <strong>Module</strong> tends to refer to larger bundles, whilst <strong>Components</strong>
                on the other hand tend to be smaller bundles of code, often smaller than a full class - 
                they tend to be a component of something larger.</li>
                <li>There are two runtime environments and each has a preferred module implementation:</li>
                <ul>
                    <li>The <strong>Node</strong> runtime environment: <i>module.exports</i> and <i>require()</i> syntax.</li>
                    <li>The <strong>browser’s</strong> runtime environment and the ES6 <i>import/export</i> syntax.</li>
                </ul>
                <li>Within Node.js applications, developers have access to a number of <strong>core modules</strong> that come 
                preshipped when you install Node.js onto your machine.</li>
                <li>There are also modules created by other developers - these third-party modules often solve common
                problems and simplify the development process. When we use these modules in our code, they are 
                referred to as <strong>dependencies</strong>.</li>
                <ul>
                    <li>Most of the time, these dependencies are installed in packages handled by a <strong>package manager</strong>.
                    A package is a third-party module wrapped up with the list of that module's own dependencies.
                    The most popular package manager is <strong>Node Package Manager(npm)</strong> which is the 
                    default package manager for Node.js. You can install it using:</li> 
                    <ul>
                        <li><i>npm i < package name ></i> or <i>npm install < package name ></i></li>
                        <li><i>npm i</i></li>
                        <li><i>npm i --production</i> If you wish to leave out development dependencies.</li>
                    </ul>
                    <li>Open source developers and developers at companies use the <strong>npm registry</strong> 
                    to contribute packages to the entire community or members of their organizations, and download
                    packages to use in their own projects.</li>
                </ul>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode33" onclick="showCode('displayCode33', 'showCode33')">Display</button>
            <div id="displayCode33">
                <button onclick="closeCode('displayCode33', 'showCode33')">Close</button>
                <ul>
                    <li><strong>module.exports</strong>:</li>
                    <pre>
                        <code>
                function celsiusToFahrenheit(celsius) {
                    return celsius * (9/5) + 32;
                }
                    
                module.exports.celsiusToFahrenheit = celsiusToFahrenheit;
                module.exports.fahrenheitToCelsius = function(fahrenheit) {
                    return (fahrenheit - 32) * (5/9);
                };
                        </code>
                    </pre>
                    <li><strong>require()</strong>:</li>
                    <pre>
                        <code>
            const converters = require('./converters.js');
 
            const freezingPointC = 0;
            const boilingPointC = 100;
            
            const freezingPointF = converters.celsiusToFahrenheit(freezingPointC);
            const boilingPointF = converters.celsiusToFahrenheit(boilingPointC);
            
            console.log(`The freezing point of water in Fahrenheit is ${freezingPointF}`);
            console.log(`The boiling point of water in Fahrenheit is ${boilingPointF}`);
                        </code>
                    </pre>
                    <li><strong>require()</strong> with <strong>destructuring</strong>:</li>
                    <pre>
                        <code>
            /* celsius-to-fahrenheit.js */
            const { celsiusToFahrenheit } = require('./converters.js');
            
            const celsiusInput = process.argv[2]; 
            const fahrenheitValue = celsiusToFahrenheit(celsiusInput);
            
            console.log(`${celsiusInput} degrees Celsius = ${fahrenheitValue} degrees Fahrenheit`);
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>Node Modules</h3>
            <ul>
                <li><strong>Core Modules: </strong>are built into the Node.js environment to efficiently 
                perform common tasks. To access core modules, inside REPL type: <i>require('module').builtinModules</i></li>
                <li><strong>Process Module: </strong>Node has a global process object with useful methods and 
                information about the <strong>current process.</strong>Type in the code:</li>
                <ul>
                    <li>The <strong>process.env</strong> property is an object which stores and controls information 
                    about the environment in which the process is currently running.</li>
                    <li>The <strong>process.memoryUsage()</strong> returns information on the CPU
                    demands of the current process.</li>
                    <li>The <strong>process.argv</strong> property holds an array of command line values provided 
                    when the current process was initiated.</li>
                </ul>
                <li><strong>OS Module: </strong>When developing or debugging an app, it can be helpful to have information about the 
                computer, operating system, and network on which the program is running.
                the os module is not global and needs to be included into the file in order to gain access to it’s methods. 
                You can include the os module into your file by typing: <i>const os = require('os');</i></li>
                <ul>
                    <li><strong>os.type()</strong> — to return the computer’s operating system.</li>
                    <li><strong>os.arch()</strong> — to return the operating system CPU architecture.</li>
                    <li><strong>os.networkInterfaces()</strong> — to return information about the network interfaces of the 
                    computer, such as IP and MAC address.</li>
                    <li><strong>os.homedir()</strong> — to return the current user’s home directory.</li>
                    <li><strong>os.hostname()</strong> — to return the hostname of the operating system.</li>
                    <li><strong>os.uptime()</strong> — to return the system uptime, in seconds.</li>
                </ul>
                <li><strong>Util Module:</strong> Utility functions don’t necessarily create new functionality 
                in a program, but you can think of them as internal tools used to maintain and debug your code.
                The Node.js util core module contains methods specifically designed for these purposes. 
                The util module can be required into the file using:<i> const util = require('util');</i></li>
                <ul>
                    <li><strong>types: </strong>which provides methods for runtime type checking in Node.</li>
                    <li><strong>promisify: </strong>turns callback functions into promises.</li>
                </ul>
                <li><strong>Event Module: </strong>
                Node.js has an EventEmitter class which can be accessed by importing the events core 
                module by using the <i>require()</i> statement. Each event emitter instance has an <i>.on()</i> method
                which assigns a listener callback function to a named event. EventEmitter also has an <i>.emit()</i> 
                method which announces a named event that has occurred.</li>
                <li><strong>Error Module: </strong>Within our own code, we can generate errors and throw them, and, with synchronous
                code in Node, we can use error handling techniques such as <i>try...catch</i> statements.
                However we cannot use try...catch when the error is thrown asynchronously. Many asynchronous Node APIs use
                error-first callback functions—callback functions which have an error as the first expected argument and the data as
                the second argument. If the asynchronous task results in an error, it will be passed in as the first argument to the
                callback function. If no error was thrown, the first argument will be undefined.</li>
                <li><strong>Input/Output: </strong>Input is data that is given to the computer, while output is 
                any data or feedback that a computer provides. In Node, we can get input from a user using the 
                <i>stdin.on()</i> method on the process object. We are able to use this because <i>.on()</i> is an instance 
                of EventEmitter. To give an output, we can use the <i>.stdout.write()</i> method on the process object
                as well. This is because <i>console.log()</i> is a thin wrapper on .stdout.write().</li>
                <li><strong>Buffer Module: </strong>Is used to handle binary data. 
                It provides a variety of methods to handle the binary data such as .alloc(), .toString(), .from(), and .concat()</li>
                <ul>
                    <li>The <strong>.alloc()</strong> Method: Allows a new Buffer object to be created with the 
                    size specified as the first argument. Optionally, a second argument can be provided to specify 
                    the fill and a third argument to specify the encoding.</li>
                    <li>The <strong>.toString()</strong> Method: A Buffer object can be translated into a human-readable 
                    string by chaining the .toString() method to a Buffer object. Optionally, encoding can be specified
                    as the first argument, byte offset to begin translating can be provided as the second argument, and
                    the byte offset to end translating as the third argument.</li>
                    <li>The <strong>.from()</strong> Method: A new Buffer object can be created from a specified string, 
                    array, or another Buffer object using the .from() method. Encoding can be specified optionally as the
                    second argument.</li>
                    <li>The <strong>.concat()</strong> Method: Joins all Buffer objects in the specified array into
                    one Buffer object. The length of the concatenated Buffer can be optionally provided as the second
                    argument. This method is useful because a Buffer object can't be resized.</li>
                </ul>
                <li><strong>FS Module (file system): </strong>All of the data on a computer is organized and accessed
                through a filesystem. When running JavaScript code on a browser, it’s important for a script to have
                only limited access to a user’s filesystem. This technique of isolating some applications from others
                is known as sandboxing. In the back-end, however, less restricted interaction with the filesystem is essential.
                The Node <strong>fs core module</strong> is an API for interacting with the file system.
                Import module via <i>require('fs');</i>
                The <strong>.readFile()</strong> Method: Reads data from a provided file.</li>
                <li><strong>Readable/Writable Streams: </strong>In most cases, data isn’t processed all at once but
                rather piece by piece. This is what we call streams. Streaming data is preferred as it doesn’t require
                tons of RAM and doesn’t need to have all the data on hand to begin processing it. To read files
                line-by-line, we can use the <i>.createInterface()</i> Method from the readline core module. We can write to
                streams by using the <i>.createWriteStream()</i> Method.</li>
                <li><strong>Timers Module:</strong> There are times when we want some of our code to be executed at a
                specified point in time. This is what the timers module is used for.
                Timer functions in Node.js behave similarly to how they work in front-end JavaScript programs,
                but the difference is that they are added to the Node.js event loop. This means that the timer
                functions are scheduled and put into a queue. This queue is processed at every iteration of the
                event loop. If a timer function is executed outside of a module, the behavior will be random (non-deterministic).</li>
                The <strong>setImmediate()</strong> function is often compared with the setTimeout() function.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode31" onclick="showCode('displayCode31', 'showCode31')">Display</button>
            <div id="displayCode31">
                <button onclick="closeCode('displayCode31', 'showCode31')">Close</button>
                <ul>
                    <li><strong>Event Module</strong></li>
                    <pre>
                        <code>
                let newUserListener = (data) => {
                    console.log(`We have a new user: ${data}.`);
                };
                    
                // Assign the newUserListener function as the listener callback for 'new user' events
                myEmitter.on('new user', newUserListener)
                
                // Emit a 'new user' event
                myEmitter.emit('new user', 'Lily Pad') //newUserListener will be invoked with 'Lily Pad'
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Error Module</strong></li>
                    <pre>
                        <code>
                const errorFirstCallback = (err, data)  => {
                    if (err) {
                    console.log(`There WAS an error: ${err}`);
                    } else {
                    // err was falsy
                    console.log(`There was NO error. Event data: ${data}`);
                    }
                }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Input/Output</strong></li>
                    <ul>
                        <li>In the Node environment, the console is the terminal, and the console.log() 
                        method is a “thin wrapper” on the .stdout.write() method of the process object. 
                        stdout stands for standard output.</li>
                    </ul>
                    <pre>
                        <code>
                process.stdout.write(
                "I'm thinking of a number from 1 through 10. What do you think it is?
                \n(Write \"quit\" to give up.)\n\nIs the number ... ");

                process.stdin.on('data', (userInput) => {
                    let input = userInput.toString()
                    console.log(input)
                });
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>FS Module</strong></li>
                    <ul>
                        <li>readFile()</li>
                        <pre>
                            <code>
                const fs = require('fs');

                let readDataCallback = (err, data) => {
                    if (err) {
                        console.log(`Something went wrong: ${err}`);
                    } else {
                        console.log(`Provided file contained: ${data}`);
                    }
                };
                
                fs.readFile('./file.txt', 'utf-8', readDataCallback);
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Read/Write Streams</strong></li>
                    <ul>
                        <li><strong>createInterface() </strong>& <strong>createReadStream()</strong></li>
                        <pre>
                            <code>
                const readline = require('readline');
                const fs = require('fs');
                
                const myInterface = readline.createInterface({
                    input: fs.createReadStream('text.txt')
                });
                
                myInterface.on('line', (fileLine) => {
                    console.log(`The line read: ${fileLine}`);
                });
                            </code>
                        </pre>
                        <li><strong>.createWriteStream()</strong></li>
                        <pre>
                            <code>
                const fs = require('fs')
                const fileStream = fs.createWriteStream('output.txt');
                
                fileStream.write('This is the first line!'); 
                fileStream.write('This is the second line!');
                fileStream.end();
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Timers Module</strong></li>
                    <ul>
                        <li><strong>setImmediate()</strong></li>
                        <pre>
                            <code>
                    setImmediate(() => {
                        console.log('Hello! My name is Codey.')
                    });
                            </code>
                        </pre>
                    </ul>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>Express.js</h2>
            <ul>
                <li><strong>Express.js: </strong>Is a server-side framework built upon Node.js. A server-side framework can handle 
                a lot of the back-end responsibilities without needing to come up with a custom solution, which
                saves a lot of time. This workflow might include things like accessing databases, generating HTML,
                handling URL routing, access to libraries built to work with the framework, existing resources and
                documentation for solving common problems, improved security.</li>
                <li>Express Documentation <a href="https://expressjs.com/en/4x/api.html" target="_blank">here</a>.</li>
                <hr/>
                <h3>Initiating</h3>
                <li>Express is a Node module, so in order to use it, we will need to import it into our program file
                with <i>require('express')</i>.</li>
                <li><strong>app.listen():</strong> The purpose of a server is to listen for requests, perform whatever action is required to satisfy 
                the request, and then return a response. In order for our server to start responding, as first argument
                we have to tell the server where to listen for new requests by providing a port number argument to a method called 
                <i>app.listen()</i>. The server will then listen on the specified port and respond to any requests that come 
                into it. The second argument is a callback function that will be called once the server is running and ready to receive responses.</li>
            </ul>
            <hr/>
            <h3>Routes</h3>
            <ul>
                <li><strong>Routes: </strong>registering a series of routes we tell our server how to deal with any given request. 
                It defines the control flow for requests based on the request's path and HTTP verb.
                For example, if your server receives a GET request at <i>/monsters</i>, we will use a route to
                define the appropriate functionality for that HTTP verb (GET) and path (/monsters).</li>
                <ul>
                    <li><i>localhost:4001/monsters</i>, the path is <i>/monsters</i>, hostname is <i>localhost</i>, the port
                    number is <i>4001</i>).</li>
                    <li>Express tries to match requests by route, meaning that if we send a request to 
                    < server address >:< port number ><i>/api-endpoint</i>, the Express server will search through any
                    registered routes in order that they are registered in your code and try to match <i>/api-endpoint</i>.
                    The first one that is matched will be used, and its callback will be called.</li>
                </ul>
                <li><strong>Route Parameters: </strong>Makes Routes dynamic. Parameters are route path segments 
                    that begin with <i>:</i> in their Express route definitions. They act as wildcards, matching any
                    text at that path segment. For example <i>/monsters/:id</i> will match <i>both/monsters/1</i>
                    and <i>/monsters/45</i>.</li>
                    <ul>
                        <li>Express parses any parameters, extracts their actual values, and attaches them as an object
                        to the request object: <strong>req.params</strong>. This object’s keys are any parameter names
                        in the route, and each key’s value is the actual value of that field per request.</li>
                        <li>Not all APIs implement route parameters but when they do, it most commonly does not access
                        sensitive data, unless it also requires to have an API key to access the response from such route.</li>
                    </ul>
                <hr/>
            </ul>
            <h3>CRUD</h3>
            <ul>
                <li>app.get, app.put, app.post, app.delete are used to connect with api requests.
                This is the cleanest order to use:</li>
                    <ul>
                        <li>GET <i>/expressions/</i></li>
                        <li>GET <i>/expressions/:id</i></li>
                        <li>PUT <i>/expressions/:id</i></li>
                        <li>DELETE <i>/expressions/:id</i></li>
                    </ul>
                <li><strong>app.get():</strong> Registers routes to match GET requests. Express routes (including
                app.get()) usually take two arguments, a path (usually a string), and a callback function to handle
                the request and send a response.</li>
                <ul>
                    <li><strong>res: </strong>Facilitates how we can submit responses by providing a response 
                    object, commonly seen as: res, and it represents the HTTP response that we will emit when 
                    we receive an HTTP request to any of our endpoints. Inside of it, we just need to pass
                    the data of the response using:</li>
                    <ul>
                        <li><strong>.send()</strong>: Express servers send responses using the <i>.send()</i> method on the
                        response object. <i>.send()</i> will take any input and include it in the response body.</li>
                        <li><strong>.json()</strong>: can also be used to explicitly send JSON-formatted responses. 
                        <i>.json()</i> sends any JavaScript object passed into it.</li>
                    </ul>
                </ul>
                <li><strong>app.put(): </strong>PUT requests are used for updating existing resources. 
                For this reason, it's needed to include a unique identifier 
                as a route parameter to determine which specific resource to update.</li> 
                <ul>
                    <li>A <strong>query string</strong> is a part of a uniform resource locator (URL) that assigns values
                    to specified parameters. Query strings appear at the end of the path in URLs, and they are indicated 
                    with a <i>?</i> character. For instance, in <i>/monsters/1?name=chimera&age=1</i>, the query string is 
                    <i>name=chimera&age=1</i> and the path is <i>/monsters/1/</i> Query strings do not count as part of the route path. I</li>
                    <li><strong>req.query: </strong>This property is an object containing a property for each query string parameter 
                    in the route. When query parser is set to disabled, it is an empty object {}, otherwise it is the result of the 
                    configured query parser.</li>
                    <li><strong>req.param</strong> vs <strong>req.query</strong>: Both are closely related but they are not the same at all, params are parameters set for the route, query are 
                    values resembling variable assignment that provide extra information on what is being required for the route and
                    it will always start with a ? on the URL, inherently they are both string values that express extrapolates into
                    objects and key/value pairs from the req object.</li>
                    <ul>
                        <li><strong>req.param:</strong> <i>/lor/creatures/:name</i> if we were to make a request <i>/lor/creatures/gollum</i> gollum is the 
                        name parameter and so we could find it in the object as: req.params.name which equals to gollum or</li>
                        <li><strong>req.query:</strong> <i>/lor/creatures/hobbit?familyname=Baggins&home=Shire</i> we get two query parameters, familyname 
                        and home, this way we can get each as <i>req.query.familyname</i> which is Baggins and <i>req.query.home</i> which is Shire.:</li>
                    </ul>
                </ul>
                <li><strong>app.post(): </strong>POST request are use to create a new resource.
                The client does not know the id of the monster until it is created and sent back by the server, therefore
                POST /monsters/:id doesn’t make sense because a client couldn’t know the unique id of a monster before it
                exists.</li>
                <li><strong> app.delete(): </strong>Deletes currently existing data. Their paths should usually 
                end with a route parameter to indicate which resource to delete.</li>
                <li><strong>app.use(express.static('public')):</strong> This is used to make sure that once the 
                server is started, you can reload the browser and render on it.
                The static method of express allows us to serve all the static files of our application, that is to say,
                all HTML, CSS, and JS files that will comprise the front end visuals on the browser. In our case:
                express.static('public');
                Public is the name of the directory where we find those files, for example, in our execise 37:</li>
                <li><strong>Status Codes: </strong> Response codes provide information to clients about how their 
                requests were handled. Any res.send() has by default sent a 200 OK status code.
                The res object has a <i>.status()</i> method to allow us to set the status code,
                and other methods like .send() can be chained from it.</li>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode34" onclick="showCode('displayCode34', 'showCode34')">Display</button>
                <div id="displayCode34">
                    <button onclick="closeCode('displayCode34', 'showCode34')">Close</button>
                    <li>In a real setting API server, <u>the data doesn't exist in arrays and objects within the file</u> as 
                    the examples underneath.
                    The reason is that it will not be <strong>persisting data</strong>, since if we keep it as an object, or an array of values 
                    or even an array of objects in the file, every time we were to stop the server, all changes will disappear since 
                    the file will only have whatever we wrote in it but not any further changes introduced.
                    That is why in real APIs we also implement storage technologies like <strong>SQL</strong> or <strong>NoSQL</strong> databases, 
                    <strong>yaml files</strong>, and <strong>cloud storage</strong> 
                    services for which we need to learn and implement other libraries or their documentation on how we communicate with them 
                    within our express server.</li>
                    <hr/>
                    <li><strong>Importing</strong> Express.js, <strong>app.listen()</strong>,
                    <strong>app.get()</strong>, <strong>send()</strong>,
                    <strong>app.put()</strong>, <strong>app.post()</strong>, <strong>app.delete()</strong> 
                    & <strong>app.use()</strong>.</li>
                    <pre>
                        <code>
            //Importing express.js
            const express = require('express');
            const app = express();

            // Use static server to serve the Express Yourself Website
                so to reload and render on the browser
            app.use(express.static('public'));

            const { getElementById, getIndexById, updateElement,
            seedElements, createElement } = require('./utils');

            const PORT = process.env.PORT || 4001;

            // Variables that stores data, that'll be 
                requested, created, updated and deleted
            const expressions = [];
            seedElements(expressions, 'expressions');
            const animals = [];
            seedElements(animals, 'animals');

            // Get all expressions
            app.get('/expressions', (req, res, next) => {
                res.send(expressions);
            });

            // Get a single expression (based on ID)
            app.get('/expressions/:id', (req, res, next) => {
                const foundExpression = getElementById(req.params.id, expressions);
                if (foundExpression) {
                    res.send(foundExpression);
                } else {
                    res.status(404).send();
                }
            });

            // Update an expression (based on ID)
            app.put('/expressions/:id', (req, res, next) => {
                const expressionIndex = getIndexById(req.params.id, expressions);
                //getIndexById will return -1 if the expressions array 
                    doesn’t contain an element with that id.
                //updateElement will throw an error if you pass in
                    an id that doesn’t exist in the array
                if (expressionIndex !== -1) {
                    updateElement(req.params.id, req.query, expressions);
                    res.send(expressions[expressionIndex]);
                } else {
                    res.status(404).send();
                }
            });

            // Create an expression
            app.post('/expressions', (req, res, next) => {
                const receivedExpression = createElement('expressions', req.query);
                if (receivedExpression) {
                    expressions.push(receivedExpression);
                    res.status(201).send(receivedExpression);
                } else {
                    res.status(400).send();
                }
            });

            // Delete an expression (based on ID)
            app.delete('/expressions/:id', (req, res, next) => {
                const expressionIndex = getIndexById(req.params.id, expressions);
                //getIndexById will return -1 for a non-existent ID,
                and the proper index if it exists. 
                Then you can use the splice method to remove the element.
                if (expressionIndex !== -1) {
                    expressions.splice(expressionIndex, 1);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            });

            // Get all animals
            app.get('/animals', (req, res, next) => {
                res.send(animals);
            });

            // Get a single animal
            app.get('/animals/:id', (req, res, next) => {
                const animal = getElementById(req.params.id, animals);
                if (animal) {
                    res.send(animal);
                } else {
                    res.status(404).send();
                }
            });

            // Create an animal
            app.post('/animals', (req, res, next) => {
                const receivedAnimal = createElement('animals', req.query);
                if (receivedAnimal) {
                    animals.push(receivedAnimal);
                    res.status(201).send(receivedAnimal);
                } else {
                    res.status(400).send();
                }
            });

            // Update an animal
            app.put('/animals/:id', (req, res, next) => {
                const animalIndex = getIndexById(req.params.id, animals);
                if (animalIndex !== -1) {
                    updateElement(req.params.id, req.query, animals);
                    res.send(animals[animalIndex]);
                } else {
                    res.status(404).send();
                }
            });

            // Delete a single animal
            app.delete('/animals/:id', (req, res, next) => {
                const animalIndex = getIndexById(req.params.id, animals);
                if (animalIndex !== -1) {
                    animals.splice(animalIndex, 1);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on ${PORT}`);
            });
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>app.put</strong> & <strong>req.params</strong>, <strong>req.query</strong>.</li>
                    <pre>
                        <code>
            const express = require('express');
            const app = express();

            const PORT = process.env.PORT || 4001;

            const currencies = {
                diram: {
                    countries: ['UAE', 'Morocco'],
                },
                real: {
                    countries: ['Brazil'],
                },
                dinar: {
                    countries: ['Algeria', 'Bahrain', 'Jordan', 'Kuwait'],
                },
                vatu: {
                    countries: ['Vanuatu'],
                },
                shilling: {
                    countries: ['Tanzania', 'Uganda', 'Somalia', 'Kenya'],
                },
            };

            app.put('/currencies/:name/countries', (req, res, next) => {
                const currencyName = req.params.name; //param ":name" from PUT request
                const countries = req.query; //value property from the key: value
                currencies[currencyName] = countries;  //query: value assign to parameter

                if(currencies[currencyName]){
                    res.send(currencies[currencyName]);
                } else {
                res.status(404).send();
                }
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });

                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Route Parameters</strong>:</li>
                    <ul>
                        <pre>
                            <code>
                const monsters = { 
                    hydra: { height: 3, age: 4 }, 
                    dragon: { height: 200, age: 350 } 
                };

                // GET /monsters/hydra
                app.get('/monsters/:name', (req, res, next) => {
                    console.log(req.params); // { name: 'hydra' }
                    res.send(monsters[req.params.name]);
                });
                            </code>
                        </pre>
                        <li>Another example:</li>
                        <pre>
                            <code>
            const express = require('express');
            const app = express();

            app.use(express.static('public'));

            const { getElementById, seedElements } = require('./utils');

            const expressions = [];
            seedElements(expressions, 'expressions');

            const PORT = process.env.PORT || 4001;

            app.get('/expressions', (req, res, next) => {
                res.send(expressions);
            });

            app.get('/expressions/:id', (req, res, next) => {
                const foundExpression = getElementById(req.params.id, expressions);
                res.send(foundExpression);
            });

            app.listen(PORT, () => {
                console.log(`Listening on port ${PORT}`);
            });
                            </code>
                        </pre>
                    </ul>    
                    <hr/>
                    <li><strong>Status Code:</strong></li>
                    <pre>
                        <code>
            const monsterStoreInventory = { fenrirs: 4, 
                                            banshees: 1, 
                                            jerseyDevils: 4, 
                                            krakens: 3 };
            
            app.get('/monsters-inventory/:name', (req, res, next) => {
                const monsterInventory = monsterStoreInventory[req.params.name];
                if (monsterInventory) {
                    res.send(monsterInventory);
                } else {
                    res.status(404).send('Monster not found');
                }
            });
                        </code>
                    </pre>
                </div>
            </ul>
                <hr/>
            <h3>Express.Router</h3>
                <ul>
                    <li>Routers are mini versions of Express applications — they provide functionality for handling 
                    route matching, requests, and sending responses.
                    Generally, we will keep each router in its own file, and require them in the main application. 
                    (because of reusability, scalability and cleaness). 
                    For example, having a router file that specifies all routes and depending on the main route, 
                    it will use the respective file that handles the request to that route.
                    We can use it with <strong>express.Router()</strong>.</li>
                    <li>Is very common having a <i>router.js</i> file that handles all the route connections.</li>
                    <li>Routers nested within nested routers <a href='https://discuss.codecademy.com/t/why-would-we-nest-routers-in-nested-routers/394943' target="_blank">here</a>.</li>
                    <li>To use a router, we mount it at a certain path using <strong>app.use()</strong> and pass in the router as the
                    second argument. This router will now be used for all paths that begin with that path segment.</li>
                    <li><strong>Documentation</strong> on Routing <a href="https://expressjs.com/en/guide/routing.html" target="_blank">here</a>.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode35" onclick="showCode('displayCode35', 'showCode35')">Display</button>
                <div id="displayCode35">
                    <button onclick="closeCode('displayCode35', 'showCode35')">Close</button>
                    <ul>
                        <li><strong>Express.Router</strong></li>
                        <ul>
                            <li>The code below contains all the monsters specific code. In a more full-fledged API, this file
                            would contain multiple routes. To use this router in another file, we use <strong>module.exports</strong>
                            so that other files can access monstersRouter. The only other new line of code required is
                            that Express must be required in each file, since we’ll need to create a router with 
                            <i>express.Router()</i>.</li>
                        </ul>
                        <pre>
                            <code>
                // monsters.js
                const express = require('express');
                const monstersRouter = express.Router();
                    
                const monsters = {
                    '1': {
                        name: 'godzilla',
                        age: 250000000
                    },
                    '2': {
                        Name: 'manticore',
                        age: 21
                    }
                }
                    
                monstersRouter.get('/:id', (req, res, next) => {
                    const monster = monsters[req.params.id];
                    if (monster) {
                        res.send(monster);
                    } else {
                        res.status(404).send();
                    }
                });
                    
                module.exports = monstersRouter;
                            </code>
                        </pre>
                        <li>Our <i>main.js</i> file could then be refactored to import the monstersRouter:</li>
                        <pre>
                            <code>
                            // main.js
                            const express = require('express');
                            const app = express();
                            const monstersRouter = require('./monsters.js');
                             
                            app.use('/monsters', monstersRouter);
                            </code>
                        </pre>
                    </ul>
                </div>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Postman</h2>
            <ul>
                <li>Postman is a GUI that aids in the development of APIs by 
                making it easy to test requests and their responses in an organized way.</li>
                <li>API requests with <strong>Postman</strong>(GUI) & <strong>cURL</strong>(Command Line)
                <a href="https://www.taniarascia.com/making-api-requests-postman-curl/" target="_blank">here</a></li>
                <hr/>
                <h3>API Requests</h3>
                <li><strong>Initializing: </strong>
                Set the URL connected to the server & the HTTP method.</li>
                <li><strong>GET: </strong>
                Write proper URL to GET request.</li>
                <li><strong>POST: </strong> It is <u>non-idempotent</u>, meaning that two identical 
                POST requests will create two new resources.<br>
                Select <strong>POST</strong> method, Body => Raw (set to JSON), 
                write the Post request. As the output, an id will be created as a property
                inside "user". Example: </li>
                <pre><code>{"user": {"username": "Victor", "password": "Rego"}}</code></pre>
                <li><strong>PUT: </strong>It is <u>idempotent</u>, meaning that two identical PUT requests will modify the same
                resource.<br>
                A <strong>PUT</strong> request requires the entire body to be sent through; if any data 
                is missing, that data will be wiped (except automatic values like auto-incrementing 
                IDs and timestamps).</li>
                <li><strong>PATCH: </strong>Updates an existing resource, and does not require
                sending the entire body with the request.</li>
                <li><strong>DELETE: </strong>Removes a resource. No values to send.</li>
                <li><strong>Authentication: </strong>
                In Postman, you'll go to Headers and add Authorization as the key and Bearer < JWT_TOKEN > as
                the value to send authentication values. You can also go to Headers, click Presets, Manage
                Presets, and put your own reusable variables in for any headers or values you'll be reusing a lot.</li>
            </ul>
        </div>
    </body>
</html>
