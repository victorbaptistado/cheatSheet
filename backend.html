<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="./component/button.js" defer></script>
        <title>Backend</title>
    </header>
    <body>
        <nav>
            <ul class="mainNav">
                <li><a href="./index.html">Cheat Sheet</a></li>
                <li><a href="./displayProperties.html">Display Properties</a></li>
                <li><a href="./objects.html">Objects</a></li>
                <li><a href="./developmentCycle.html">Development Cycle</a></li>
                <li><a href="./debug.html">Debug</a></li>
                <li><a href="./git.html">Git</a></li>
                <li><a href="./form.html">Form</a></li>
                <li><a href="./api.html">API</a></li>
                <li><a href="./react.html">REACT</a></li>
                <li><a href="./helpfulContent.html">Helpful Content</a></li>
                <li><a href="#">Backend</a></li>
            </ul>
        </nav>
        <header>
            <h1>Backend</h1>
        </header>
        <div class="styleGuide">
            <h2>Node.js</h2>
            <ul>
                <li><strong>Node</strong> provides the ability to run JavaScript programs on our own computers instead of just in the browser's 
                    console or embedded in HTML.</li>
                    <ul>
                        <li>To <strong>run a program</strong> with node <i>$ node myProgram.js</i></li>
                    </ul>
                <li>Codecademy Material <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-introduction-to-back-end/modules/wdcp-22-back-end-javascript-with-node-js/cheatsheet" target="_blank">here</a></li>
                <li>Node.js Documentation <a href="https://nodejs.org/en/docs/" target="_blank">here</a>.</li>
            </ul>
            <hr/>
            <h3>REPL</h3>
            <ul>
               <li><strong>REPL</strong> is an abbreviation for <u>read-eval-print loop</u>. It's a program that loops, or 
                repeatedly cycles, through three different states: a read state where the program reads
                input from a user, the eval state where the program evaluates the user's input, and the
                print state where the program prints out its evaluation to a console.</li>
                <li>A REPL can be extremely useful for performing calculations, learning a language, and developing
                code. It’s a place where you can explore language features and try things out while receiving 
                immediate feedback.</li>
                <li>To access REPL, type <i>node</i> in the terminal.</li>
            </ul>
            <hr/>
            <h3>Modules</h3>
            <ul>
                <li><strong>Modules</strong> are reusable pieces of code in a file that can be exported and then
                imported for use in another file. A modular program is one whose components can be separated, 
                used individually, and recombined to create a complex system.
                <strong>Module</strong> tends to refer to larger bundles, whilst <strong>Components</strong>
                on the other hand tend to be smaller bundles of code, often smaller than a full class - 
                they tend to be a component of something larger.</li>
                <li>There are two runtime environments and each has a preferred module implementation:</li>
                <ul>
                    <li>The <strong>Node</strong> runtime environment: <i>module.exports</i> and <i>require()</i> syntax.</li>
                    <li>The <strong>browser’s</strong> runtime environment and the ES6 <i>import/export</i> syntax.</li>
                </ul>
                <li>Within Node.js applications, developers have access to a number of <strong>core modules</strong> that come 
                preshipped when you install Node.js onto your machine.</li>
                <li>There are also modules created by other developers - these third-party modules often solve common
                problems and simplify the development process. When we use these modules in our code, they are 
                referred to as <strong>dependencies</strong>.</li>
                <ul>
                    <li>Most of the time, these dependencies are installed in packages handled by a <strong>package manager</strong>.
                    A package is a third-party module wrapped up with the list of that module's own dependencies.
                    The most popular package manager is <strong>Node Package Manager(npm)</strong> which is the 
                    default package manager for Node.js. You can install it using:</li> 
                    <ul>
                        <li><i>npm i < package name ></i> or <i>npm install < package name ></i></li>
                        <li><i>npm i</i></li>
                        <li><i>npm i --production</i> If you wish to leave out development dependencies.</li>
                    </ul>
                    <li>Open source developers and developers at companies use the <strong>npm registry</strong> 
                    to contribute packages to the entire community or members of their organizations, and download
                    packages to use in their own projects.</li>
                </ul>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode33" onclick="showCode('displayCode33', 'showCode33')">Display</button>
            <div id="displayCode33">
                <button onclick="closeCode('displayCode33', 'showCode33')">Close</button>
                <ul>
                    <li><strong>module.exports</strong>:</li>
                    <pre>
                        <code>
                function celsiusToFahrenheit(celsius) {
                    return celsius * (9/5) + 32;
                }
                    
                module.exports.celsiusToFahrenheit = celsiusToFahrenheit;
                module.exports.fahrenheitToCelsius = function(fahrenheit) {
                    return (fahrenheit - 32) * (5/9);
                };
                        </code>
                    </pre>
                    <li><strong>require()</strong>:</li>
                    <pre>
                        <code>
            const converters = require('./converters.js');
 
            const freezingPointC = 0;
            const boilingPointC = 100;
            
            const freezingPointF = converters.celsiusToFahrenheit(freezingPointC);
            const boilingPointF = converters.celsiusToFahrenheit(boilingPointC);
            
            console.log(`The freezing point of water in Fahrenheit is ${freezingPointF}`);
            console.log(`The boiling point of water in Fahrenheit is ${boilingPointF}`);
                        </code>
                    </pre>
                    <li><strong>require()</strong> with <strong>destructuring</strong>:</li>
                    <pre>
                        <code>
            /* celsius-to-fahrenheit.js */
            const { celsiusToFahrenheit } = require('./converters.js');
            
            const celsiusInput = process.argv[2]; 
            const fahrenheitValue = celsiusToFahrenheit(celsiusInput);
            
            console.log(`${celsiusInput} degrees Celsius = ${fahrenheitValue} degrees Fahrenheit`);
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>Node Modules</h3>
            <ul>
                <li><strong>Core Modules: </strong>are built into the Node.js environment to efficiently 
                perform common tasks. To access core modules, inside REPL type: <i>require('module').builtinModules</i></li>
                <li><strong>Process Module: </strong>Node has a global process object with useful methods and 
                information about the <strong>current process.</strong>Type in the code:</li>
                <ul>
                    <li>The <strong>process.env</strong> property is an object which stores and controls information 
                    about the environment in which the process is currently running.</li>
                    <li>The <strong>process.memoryUsage()</strong> returns information on the CPU
                    demands of the current process.</li>
                    <li>The <strong>process.argv</strong> property holds an array of command line values provided 
                    when the current process was initiated.</li>
                </ul>
                <li><strong>OS Module: </strong>When developing or debugging an app, it can be helpful to have information about the 
                computer, operating system, and network on which the program is running.
                the os module is not global and needs to be included into the file in order to gain access to it’s methods. 
                You can include the os module into your file by typing: <i>const os = require('os');</i></li>
                <ul>
                    <li><strong>os.type()</strong> — to return the computer’s operating system.</li>
                    <li><strong>os.arch()</strong> — to return the operating system CPU architecture.</li>
                    <li><strong>os.networkInterfaces()</strong> — to return information about the network interfaces of the 
                    computer, such as IP and MAC address.</li>
                    <li><strong>os.homedir()</strong> — to return the current user’s home directory.</li>
                    <li><strong>os.hostname()</strong> — to return the hostname of the operating system.</li>
                    <li><strong>os.uptime()</strong> — to return the system uptime, in seconds.</li>
                </ul>
                <li><strong>Util Module:</strong> Utility functions don’t necessarily create new functionality 
                in a program, but you can think of them as internal tools used to maintain and debug your code.
                The Node.js util core module contains methods specifically designed for these purposes. 
                The util module can be required into the file using:<i> const util = require('util');</i></li>
                <ul>
                    <li><strong>types: </strong>which provides methods for runtime type checking in Node.</li>
                    <li><strong>promisify: </strong>turns callback functions into promises.</li>
                </ul>
                <li><strong>Event Module: </strong>
                Node.js has an EventEmitter class which can be accessed by importing the events core 
                module by using the <i>require()</i> statement. Each event emitter instance has an <i>.on()</i> method
                which assigns a listener callback function to a named event. EventEmitter also has an <i>.emit()</i> 
                method which announces a named event that has occurred.</li>
                <li><strong>Error Module: </strong>Within our own code, we can generate errors and throw them, and, with synchronous
                code in Node, we can use error handling techniques such as <i>try...catch</i> statements.
                However we cannot use try...catch when the error is thrown asynchronously. Many asynchronous Node APIs use
                error-first callback functions—callback functions which have an error as the first expected argument and the data as
                the second argument. If the asynchronous task results in an error, it will be passed in as the first argument to the
                callback function. If no error was thrown, the first argument will be undefined.</li>
                <li><strong>Input/Output: </strong>Input is data that is given to the computer, while output is 
                any data or feedback that a computer provides. In Node, we can get input from a user using the 
                <i>stdin.on()</i> method on the process object. We are able to use this because <i>.on()</i> is an instance 
                of EventEmitter. To give an output, we can use the <i>.stdout.write()</i> method on the process object
                as well. This is because <i>console.log()</i> is a thin wrapper on .stdout.write().</li>
                <li><strong>Buffer Module: </strong>Is used to handle binary data. 
                It provides a variety of methods to handle the binary data such as .alloc(), .toString(), .from(), and .concat()</li>
                <ul>
                    <li>The <strong>.alloc()</strong> Method: Allows a new Buffer object to be created with the 
                    size specified as the first argument. Optionally, a second argument can be provided to specify 
                    the fill and a third argument to specify the encoding.</li>
                    <li>The <strong>.toString()</strong> Method: A Buffer object can be translated into a human-readable 
                    string by chaining the .toString() method to a Buffer object. Optionally, encoding can be specified
                    as the first argument, byte offset to begin translating can be provided as the second argument, and
                    the byte offset to end translating as the third argument.</li>
                    <li>The <strong>.from()</strong> Method: A new Buffer object can be created from a specified string, 
                    array, or another Buffer object using the .from() method. Encoding can be specified optionally as the
                    second argument.</li>
                    <li>The <strong>.concat()</strong> Method: Joins all Buffer objects in the specified array into
                    one Buffer object. The length of the concatenated Buffer can be optionally provided as the second
                    argument. This method is useful because a Buffer object can't be resized.</li>
                </ul>
                <li><strong>FS Module (file system): </strong>All of the data on a computer is organized and accessed
                through a filesystem. When running JavaScript code on a browser, it’s important for a script to have
                only limited access to a user’s filesystem. This technique of isolating some applications from others
                is known as sandboxing. In the back-end, however, less restricted interaction with the filesystem is essential.
                The Node <strong>fs core module</strong> is an API for interacting with the file system.
                Import module via <i>require('fs');</i>
                The <strong>.readFile()</strong> Method: Reads data from a provided file.</li>
                <li><strong>Readable/Writable Streams: </strong>In most cases, data isn’t processed all at once but
                rather piece by piece. This is what we call streams. Streaming data is preferred as it doesn’t require
                tons of RAM and doesn’t need to have all the data on hand to begin processing it. To read files
                line-by-line, we can use the <i>.createInterface()</i> Method from the readline core module. We can write to
                streams by using the <i>.createWriteStream()</i> Method.</li>
                <li><strong>Timers Module:</strong> There are times when we want some of our code to be executed at a
                specified point in time. This is what the timers module is used for.
                Timer functions in Node.js behave similarly to how they work in front-end JavaScript programs,
                but the difference is that they are added to the Node.js event loop. This means that the timer
                functions are scheduled and put into a queue. This queue is processed at every iteration of the
                event loop. If a timer function is executed outside of a module, the behavior will be random (non-deterministic).</li>
                The <strong>setImmediate()</strong> function is often compared with the setTimeout() function.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode31" onclick="showCode('displayCode31', 'showCode31')">Display</button>
            <div id="displayCode31">
                <button onclick="closeCode('displayCode31', 'showCode31')">Close</button>
                <ul>
                    <li><strong>Event Module</strong></li>
                    <pre>
                        <code>
                let newUserListener = (data) => {
                    console.log(`We have a new user: ${data}.`);
                };
                    
                // Assign the newUserListener function as the listener callback for 'new user' events
                myEmitter.on('new user', newUserListener)
                
                // Emit a 'new user' event
                myEmitter.emit('new user', 'Lily Pad') //newUserListener will be invoked with 'Lily Pad'
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Error Module</strong></li>
                    <pre>
                        <code>
                const errorFirstCallback = (err, data)  => {
                    if (err) {
                    console.log(`There WAS an error: ${err}`);
                    } else {
                    // err was falsy
                    console.log(`There was NO error. Event data: ${data}`);
                    }
                }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Input/Output</strong></li>
                    <ul>
                        <li>In the Node environment, the console is the terminal, and the console.log() 
                        method is a “thin wrapper” on the .stdout.write() method of the process object. 
                        stdout stands for standard output.</li>
                    </ul>
                    <pre>
                        <code>
                process.stdout.write(
                "I'm thinking of a number from 1 through 10. What do you think it is?
                \n(Write \"quit\" to give up.)\n\nIs the number ... ");

                process.stdin.on('data', (userInput) => {
                    let input = userInput.toString()
                    console.log(input)
                });
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>FS Module</strong></li>
                    <ul>
                        <li>readFile()</li>
                        <pre>
                            <code>
                const fs = require('fs');

                let readDataCallback = (err, data) => {
                    if (err) {
                        console.log(`Something went wrong: ${err}`);
                    } else {
                        console.log(`Provided file contained: ${data}`);
                    }
                };
                
                fs.readFile('./file.txt', 'utf-8', readDataCallback);
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Read/Write Streams</strong></li>
                    <ul>
                        <li><strong>createInterface() </strong>& <strong>createReadStream()</strong></li>
                        <pre>
                            <code>
                const readline = require('readline');
                const fs = require('fs');
                
                const myInterface = readline.createInterface({
                    input: fs.createReadStream('text.txt')
                });
                
                myInterface.on('line', (fileLine) => {
                    console.log(`The line read: ${fileLine}`);
                });
                            </code>
                        </pre>
                        <li><strong>.createWriteStream()</strong></li>
                        <pre>
                            <code>
                const fs = require('fs')
                const fileStream = fs.createWriteStream('output.txt');
                
                fileStream.write('This is the first line!'); 
                fileStream.write('This is the second line!');
                fileStream.end();
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Timers Module</strong></li>
                    <ul>
                        <li><strong>setImmediate()</strong></li>
                        <pre>
                            <code>
                    setImmediate(() => {
                        console.log('Hello! My name is Codey.')
                    });
                            </code>
                        </pre>
                    </ul>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>Express.js</h2>
            <ul>
                <li><strong>Express.js: </strong>Is a server-side framework built upon Node.js. A server-side framework can handle 
                a lot of the back-end responsibilities without needing to come up with a custom solution, which
                saves a lot of time. This workflow might include things like accessing databases, generating HTML,
                handling URL routing, access to libraries built to work with the framework, existing resources and
                documentation for solving common problems, improved security.</li>
                <li>Express Documentation <a href="https://expressjs.com/en/4x/api.html" target="_blank">here</a>.</li>
                <li>Express simple explanation <a href="https://www.freecodecamp.org/news/going-out-to-eat-and-understanding-the-basics-of-express-js-f034a029fb66/" target="_blank">here</a>.</li>
                <li>Express API Project <a href="https://codecademy-content.s3.amazonaws.com/PRO/independent-practice-projects/quote-api/quote-api-solution.zip" target="_blank">here</a>.</li>
                <li>Boss machine full project<a href="https://content.codecademy.com/PRO/skill-paths/backend-javascript/projects/boss-machine/project-4-boss-machine-solution.zip" target="_blank">here</a></li>
                <hr/>
                <h3>Initiating</h3>
                <li>Express is a Node module, so in order to use it, we will need to import it into our program file
                with <i>require('express')</i>.</li>
                <li><strong>app.listen():</strong> The purpose of a server is to listen for requests, perform whatever action is required to satisfy 
                the request, and then return a response. In order for our server to start responding, as first argument
                we have to tell the server where to listen for new requests by providing a port number argument to a method called 
                <i>app.listen()</i>. The server will then listen on the specified port and respond to any requests that come 
                into it. The second argument is a callback function that will be called once the server is running and ready to receive responses.</li>
            </ul>
            <hr/>
            <h3>Routes</h3>
            <ul>
                <li><strong>Routes: </strong>registering a series of routes we tell our server how to deal with any given request. 
                It defines the control flow for requests based on the request's path and HTTP verb.
                For example, if your server receives a GET request at <i>/monsters</i>, we will use a route to
                define the appropriate functionality for that HTTP verb (GET) and path (/monsters).</li>
                <ul>
                    <li><i>localhost:4001/monsters</i>, the path is <i>/monsters</i>, hostname is <i>localhost</i>, the port
                    number is <i>4001</i>).</li>
                    <li>Express tries to match requests by route, meaning that if we send a request to 
                    < server address >:< port number ><i>/api-endpoint</i>, the Express server will search through any
                    registered routes in order that they are registered in your code and try to match <i>/api-endpoint</i>.
                    The first one that is matched will be used, and its callback will be called.</li>
                </ul>
                <li><strong>Route Parameters: </strong>Makes Routes dynamic. Parameters are route path segments 
                    that begin with <i>:</i> in their Express route definitions. They act as wildcards, matching any
                    text at that path segment. For example <i>/monsters/:id</i> will match <i>both/monsters/1</i>
                    and <i>/monsters/45</i>.</li>
                <ul>
                    <li>Express parses any parameters, extracts their actual values, and attaches them as an object
                    to the request object: <strong>req.params</strong>. This object’s keys are any parameter names
                    in the route, and each key’s value is the actual value of that field per request.</li>
                    <li>Not all APIs implement route parameters but when they do, it most commonly does not access
                    sensitive data, unless it also requires to have an API key to access the response from such route.</li>
                    <li><strong>router.param()</strong>: When working with routes that require parameters, we might find
                    ourselves in a position where multiple different routes require the same parameter and use it to 
                    identify the same piece of data.router.param.</li>
                </ul>
                <li><strong>Merge Parameters: </strong>When we’re building web endpoints, we might want to access 
                some property of a complex object. In order to do this in Express, we can design a nested router. 
                This would be a router that is invoked within another router. In order to pass parameters the parent 
                router has access to, we pass a special configuration object when defining the router.</li>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode38" onclick="showCode('displayCode38', 'showCode38')">Display</button>
                <div id="displayCode38">
                    <button onclick="closeCode('displayCode38', 'showCode38')">Close</button>
                    <ul>
                        <li><strong>router.param()</strong></li>
                        <pre>
                            <code>
                    app.param('spellId', (req, res, next, id) => {
                        let spellId = Number(id);
                        try {
                        const found = SpellBook.find((spell) => {
                            return spellId === spell.id;
                        })
                        if (found) {
                            req.spell = found;
                            next();
                        } else {
                            next(new Error('Your magic spell was not found in any of our tomes'));
                        };
                        } catch (err) {
                            next(err)
                        }
                    });
                            </code>
                        </pre>
                        <li><strong>Full example:</strong></li>
                        <pre>
                            <code>
                const express = require('express');
                const app = express();
                const bodyParser = require('body-parser');

                app.use(express.static('public'));

                const PORT = process.env.PORT || 4001;

                const spiceRack = [
                {
                    id: 1,
                    name: 'cardamom',
                    grams: 45,
                },
                {
                    id: 2,
                    name: 'pimento',
                    grams: 20,
                },
                {
                    id: 3,
                    name: 'cumin',
                    grams: 450,
                },
                {
                    id: 4,
                    name: 'sichuan peppercorns',
                    grams: 107,
                }
                ];

                let nextSpiceId = 5;

                app.use(bodyParser.json());

                // Add your code here:
                app.param('spiceId', (req, res, next, id) => {
                const spiceId = Number(id);
                const spiceIndex = spiceRack.findIndex(spice => spice.id === spiceId);
                
                if (spiceIndex !== -1){
                    req.spiceIndex = spiceIndex;
                    next();
                } else {
                    res.sendStatus(404);
                }
                })


                app.get('/spices/', (req, res, next) => {
                res.send(spiceRack);
                });

                app.post('/spices/', (req, res, next) => {
                const newSpice = req.body.spice;
                if (newSpice.name  && newSpice.grams) {
                    newSpice.id = nextSpiceId++;
                    spiceRack.push(newSpice);
                    res.send(newSpice);
                } else {
                    res.status(400).send();
                }
                });

                app.get('/spices/:spiceId', (req, res, next) => {
                res.send(spiceRack[req.spiceIndex]);
                });

                app.put('/spices/:spiceId', (req, res, next) => {
                spiceRack[req.spiceIndex] = req.body.spice;
                res.send(spiceRack[req.spiceIndex]);
                });

                app.delete('/spices/:spiceId', (req, res, next) => {
                spiceRack.splice(req.spiceIndex, 1);
                res.status(204).send();
                });

                app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
                });
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Merge Parameters:</strong></li>
                        <pre>
                            <code>
            const sorcererRouter = express.Router();
            const familiarRouter = express.Router({mergeParams: true});
                
            sorcererRouter.use('/:sorcererId/familiars', familiarRouter);
                
            sorcererRouter.get('/', (req, res, next) => {
                res.status(200).send(Sorcerers);
                next();
            });
                
            sorcererRouter.param('sorcererId', (req, res, next, id) => {
                const sorcerer = getSorcererById(id);   
                req.sorcerer = sorcerer;
                next();
            });
                
            familiarRouter.get('/', (req, res, next) => {
                res.status(200).send(`Sorcerer ${req.sorcerer} has familiars ${getFamiliars(sorcerer)}`);
            });
                
            app.use('/sorcerer', sorcererRouter);
                            </code>
                        </pre>
                    </ul>
                </div>
                <hr/>
            </ul>
            <h3>CRUD</h3>
            <ul>
                <li>app.get, app.put, app.post, app.delete are used to connect with api requests.
                This is the cleanest order to use:</li>
                    <ul>
                        <li>GET <i>/expressions/</i></li>
                        <li>GET <i>/expressions/:id</i></li>
                        <li>PUT <i>/expressions/:id</i></li>
                        <li>DELETE <i>/expressions/:id</i></li>
                    </ul>
                <li><strong>app.get():</strong> Registers routes to match GET requests. Express routes (including
                app.get()) usually take two arguments, a path (usually a string), and a callback function to handle
                the request and send a response.</li>
                <ul>
                    <li><strong>res: </strong>Facilitates how we can submit responses by providing a response 
                    object, commonly seen as: res, and it represents the HTTP response that we will emit when 
                    we receive an HTTP request to any of our endpoints. Inside of it, we just need to pass
                    the data of the response using:</li>
                    <ul>
                        <li><strong>.send()</strong>: Express servers send responses using the <i>.send()</i> method on the
                        response object. <i>.send()</i> will take any input and include it in the response body.</li>
                        <li><strong>.json()</strong>: can also be used to explicitly send JSON-formatted responses. 
                        <i>.json()</i> sends any JavaScript object passed into it.</li>
                    </ul>
                </ul>
                <li><strong>app.post(): </strong>POST request are use to create a new resource.
                The client does not know the id of the monster until it is created and sent back by the server, therefore
                POST /monsters/:id doesn’t make sense because a client couldn’t know the unique id of a monster before it
                exists.</li>
                <li><strong>app.put(): </strong>PUT requests are used for updating existing resources. 
                For this reason, it's needed to include a unique identifier 
                as a route parameter to determine which specific resource to update.</li> 
                <li><strong> app.delete(): </strong>Deletes currently existing data. Their paths should usually 
                end with a route parameter to indicate which resource to delete.</li>
                <li><strong>Query string: </strong>Is a part of a uniform resource locator (URL) that assigns values
                to specified parameters. Query strings appear at the end of the path in URLs, and they are indicated 
                with a <i>?</i> character. For instance, in <i>/monsters/1?name=chimera&age=1</i>, the query string is 
                <i>name=chimera&age=1</i> and the path is <i>/monsters/1/</i> Query strings do not count as part of the route path. I</li>    
                <ul>
                    <li><strong>req.query: </strong>This property is an object containing a property for each query string parameter 
                    in the route. When query parser is set to disabled, it is an empty object {}, otherwise it is the result of the 
                    configured query parser.</li>
                    <li><strong>req.param</strong> vs <strong>req.query</strong>: Both are closely related but they are not the same at all, params are parameters set for the route, query are 
                    values resembling variable assignment that provide extra information on what is being required for the route and
                    it will always start with a ? on the URL, inherently they are both string values that express extrapolates into
                    objects and key/value pairs from the req object.</li>
                    <ul>
                        <li><strong>req.param:</strong> <i>/lor/creatures/:name</i> if we were to make a request <i>/lor/creatures/gollum</i> gollum is the 
                        name parameter and so we could find it in the object as: req.params.name which equals to gollum.</li>
                        <li><strong>req.query:</strong> <i>/lor/creatures/hobbit?familyname=Baggins&home=Shire</i> we get two query parameters, familyname 
                        and home, this way we can get each as <i>req.query.familyname</i> which is Baggins and <i>req.query.home</i> which is Shire.</li>
                    </ul>
                </ul>
                <li><strong>app.use(express.static('public')):</strong> This is used to make sure that once the 
                server is started, you can reload the browser and render on it.
                The static method of express allows us to serve all the static files of our application, that is to say,
                all HTML, CSS, and JS files that will comprise the front end visuals on the browser. In our case:
                express.static('public');
                Public is the name of the directory where we find those files, for example, in our execise 37:</li>
                <li><strong>Status Codes: </strong> Response codes provide information to clients about how their 
                requests were handled. Any res.send() has by default sent a 200 OK status code.
                The res object has a <i>.status()</i> method to allow us to set the status code,
                and other methods like .send() can be chained from it.</li>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode34" onclick="showCode('displayCode34', 'showCode34')">Display</button>
                <div id="displayCode34">
                    <button onclick="closeCode('displayCode34', 'showCode34')">Close</button>
                    <li>In a real setting API server, <u>the data doesn't exist in arrays and objects within the file</u> as 
                    the examples underneath.
                    The reason is that it will not be <strong>persisting data</strong>, since if we keep it as an object, or an array of values 
                    or even an array of objects in the file, every time we were to stop the server, all changes will disappear since 
                    the file will only have whatever we wrote in it but not any further changes introduced.
                    That is why in real APIs we also implement storage technologies like <strong>SQL</strong> or <strong>NoSQL</strong> databases, 
                    <strong>yaml files</strong>, and <strong>cloud storage</strong> 
                    services for which we need to learn and implement other libraries or their documentation on how we communicate with them 
                    within our express server.</li>
                    <hr/>
                    <li><strong>Importing</strong> Express.js, <strong>app.listen()</strong>,
                    <strong>app.get()</strong>, <strong>send()</strong>,
                    <strong>app.put()</strong>, <strong>app.post()</strong>, <strong>app.delete()</strong> 
                    & <strong>app.use()</strong>.</li>
                    <pre>
                        <code>
            //Importing express.js
            const express = require('express');
            const app = express();

            // Use static server to serve the Express Yourself Website
                so to reload and render on the browser
            app.use(express.static('public'));

            const { getElementById, getIndexById, updateElement,
            seedElements, createElement } = require('./utils');

            const PORT = process.env.PORT || 4001;

            // Variables that stores data, that'll be 
                requested, created, updated and deleted
            const expressions = [];
            seedElements(expressions, 'expressions');
            const animals = [];
            seedElements(animals, 'animals');

            // Get all expressions
            app.get('/expressions', (req, res, next) => {
                res.send(expressions);
            });

            // Get a single expression (based on ID)
            app.get('/expressions/:id', (req, res, next) => {
                const foundExpression = getElementById(req.params.id, expressions);
                if (foundExpression) {
                    res.send(foundExpression);
                } else {
                    res.status(404).send();
                }
            });

            // Update an expression (based on ID)
            app.put('/expressions/:id', (req, res, next) => {
                const expressionIndex = getIndexById(req.params.id, expressions);
                //getIndexById will return -1 if the expressions array 
                    doesn’t contain an element with that id.
                //updateElement will throw an error if you pass in
                    an id that doesn’t exist in the array
                if (expressionIndex !== -1) {
                    updateElement(req.params.id, req.query, expressions);
                    res.send(expressions[expressionIndex]);
                } else {
                    res.status(404).send();
                }
            });

            // Create an expression
            app.post('/expressions', (req, res, next) => {
                const receivedExpression = createElement('expressions', req.query);
                if (receivedExpression) {
                    expressions.push(receivedExpression);
                    res.status(201).send(receivedExpression);
                } else {
                    res.status(400).send();
                }
            });

            // Delete an expression (based on ID)
            app.delete('/expressions/:id', (req, res, next) => {
                const expressionIndex = getIndexById(req.params.id, expressions);
                //getIndexById will return -1 for a non-existent ID,
                and the proper index if it exists. 
                Then you can use the splice method to remove the element.
                if (expressionIndex !== -1) {
                    expressions.splice(expressionIndex, 1);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            });

            // Get all animals
            app.get('/animals', (req, res, next) => {
                res.send(animals);
            });

            // Get a single animal
            app.get('/animals/:id', (req, res, next) => {
                const animal = getElementById(req.params.id, animals);
                if (animal) {
                    res.send(animal);
                } else {
                    res.status(404).send();
                }
            });

            // Create an animal
            app.post('/animals', (req, res, next) => {
                const receivedAnimal = createElement('animals', req.query);
                if (receivedAnimal) {
                    animals.push(receivedAnimal);
                    res.status(201).send(receivedAnimal);
                } else {
                    res.status(400).send();
                }
            });

            // Update an animal
            app.put('/animals/:id', (req, res, next) => {
                const animalIndex = getIndexById(req.params.id, animals);
                if (animalIndex !== -1) {
                    updateElement(req.params.id, req.query, animals);
                    res.send(animals[animalIndex]);
                } else {
                    res.status(404).send();
                }
            });

            // Delete a single animal
            app.delete('/animals/:id', (req, res, next) => {
                const animalIndex = getIndexById(req.params.id, animals);
                if (animalIndex !== -1) {
                    animals.splice(animalIndex, 1);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on ${PORT}`);
            });
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>app.put</strong> & <strong>req.params</strong>, <strong>req.query</strong>.</li>
                    <pre>
                        <code>
            const express = require('express');
            const app = express();

            const PORT = process.env.PORT || 4001;

            const currencies = {
                diram: {
                    countries: ['UAE', 'Morocco'],
                },
                real: {
                    countries: ['Brazil'],
                },
                dinar: {
                    countries: ['Algeria', 'Bahrain', 'Jordan', 'Kuwait'],
                },
                vatu: {
                    countries: ['Vanuatu'],
                },
                shilling: {
                    countries: ['Tanzania', 'Uganda', 'Somalia', 'Kenya'],
                },
            };

            app.put('/currencies/:name/countries', (req, res, next) => {
                const currencyName = req.params.name; //param ":name" from PUT request
                const countries = req.query; //value property from the key: value
                currencies[currencyName] = countries;  //query: value assign to parameter

                if(currencies[currencyName]){
                    res.send(currencies[currencyName]);
                } else {
                res.status(404).send();
                }
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });

                        </code>
                    </pre>
                    <li><strong>app.post</strong> & <strong>req.query</strong>.</li>
                    <pre>
                        <code>
            const express = require('express');
            const app = express();

            const PORT = process.env.PORT || 4001;

            const soups = ['gazpacho', 'borscht', 'primordial', 'avgolemono', 'laksa'];

            app.post('/soups', (req, res, next) => {
                const soup = req.query.name;
                soups.push(soup);
                res.status(201).send(soup);
            })

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });

                        </code>
                    </pre>
                    <li><strong>app.delete</strong> & <strong>req.params</strong></li>
                    <hr/>
            const express = require('express');
            const app = express();

            const PORT = process.env.PORT || 4001;

            const puddingFlavors = ['chocolate', 'banana', 'butterscotch', 'pistachio'];

            const findPuddingIndex = (name) => {
                return puddingFlavors.indexOf(name);
            }

            const deletePuddingAtIndex = (index) => {
                puddingFlavors.splice(index, 1);
            }

            app.delete('/puddings/:flavor', (req, res, next) => {
                const index = findPuddingIndex(req.params.flavor);
                if(index !== -1){
                    deletePuddingAtIndex(index);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            })

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });
                    <hr/>
                    <li><strong>Route Parameters</strong>:</li>
                    <ul>
                        <pre>
                            <code>
                const monsters = { 
                    hydra: { height: 3, age: 4 }, 
                    dragon: { height: 200, age: 350 } 
                };

                // GET /monsters/hydra
                app.get('/monsters/:name', (req, res, next) => {
                    console.log(req.params); // { name: 'hydra' }
                    res.send(monsters[req.params.name]);
                });
                            </code>
                        </pre>
                        <li>Another example:</li>
                        <pre>
                            <code>
            const express = require('express');
            const app = express();

            app.use(express.static('public'));

            const { getElementById, seedElements } = require('./utils');

            const expressions = [];
            seedElements(expressions, 'expressions');

            const PORT = process.env.PORT || 4001;

            app.get('/expressions', (req, res, next) => {
                res.send(expressions);
            });

            app.get('/expressions/:id', (req, res, next) => {
                const foundExpression = getElementById(req.params.id, expressions);
                res.send(foundExpression);
            });

            app.listen(PORT, () => {
                console.log(`Listening on port ${PORT}`);
            });
                            </code>
                        </pre>
                    </ul>    
                    <hr/>
                    <li><strong>Status Code:</strong></li>
                    <pre>
                        <code>
            const monsterStoreInventory = { fenrirs: 4, 
                                            banshees: 1, 
                                            jerseyDevils: 4, 
                                            krakens: 3 };
            
            app.get('/monsters-inventory/:name', (req, res, next) => {
                const monsterInventory = monsterStoreInventory[req.params.name];
                if (monsterInventory) {
                    res.send(monsterInventory);
                } else {
                    res.status(404).send('Monster not found');
                }
            });
                        </code>
                    </pre>
                </div>
            </ul>
                <hr/>
            <h3>Express.Router</h3>
                <ul>
                    <li>Routers are mini versions of Express applications — they provide functionality for handling 
                    route matching, requests, and sending responses.
                    Generally, we will keep each router in its own file, and require them in the main application. 
                    (because of reusability, scalability and cleaness). 
                    For example, having a router file that specifies all routes and depending on the main route, 
                    it will use the respective file that handles the request to that route.
                    We can use it with <strong>express.Router()</strong>.</li>
                    <li>Is very common having a <i>router.js</i> file that handles all the route connections.</li>
                    <li>Routers nested within nested routers <a href='https://discuss.codecademy.com/t/why-would-we-nest-routers-in-nested-routers/394943' target="_blank">here</a>.</li>
                    <li>To use a router, we mount it at a certain path using <strong>app.use()</strong> and pass in the router as the
                    second argument. This router will now be used for all paths that begin with that path segment.</li>
                    <li><strong>Documentation</strong> on Routing <a href="https://expressjs.com/en/guide/routing.html" target="_blank">here</a>.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode35" onclick="showCode('displayCode35', 'showCode35')">Display</button>
                <div id="displayCode35">
                    <button onclick="closeCode('displayCode35', 'showCode35')">Close</button>
                    <ul>
                        <li><strong>Express.Router</strong></li>
                        <ul>
                            <li>The code below contains all the monsters specific code. In a more full-fledged API, this file
                            would contain multiple routes. To use this router in another file, we use <strong>module.exports</strong>
                            so that other files can access monstersRouter. The only other new line of code required is
                            that Express must be required in each file, since we’ll need to create a router with 
                            <i>express.Router()</i>.</li>
                        </ul>
                        <pre>
                            <code>
                // monsters.js
                const express = require('express');
                const monstersRouter = express.Router();
                    
                const monsters = {
                    '1': {
                        name: 'godzilla',
                        age: 250000000
                    },
                    '2': {
                        Name: 'manticore',
                        age: 21
                    }
                }
                    
                monstersRouter.get('/:id', (req, res, next) => {
                    const monster = monsters[req.params.id];
                    if (monster) {
                        res.send(monster);
                    } else {
                        res.status(404).send();
                    }
                });
                    
                module.exports = monstersRouter;
                            </code>
                        </pre>
                        <li>Our <i>main.js</i> file could then be refactored to import the monstersRouter:</li>
                        <pre>
                            <code>
                            // main.js
                            const express = require('express');
                            const app = express();
                            const monstersRouter = require('./monsters.js');
                             
                            app.use('/monsters', monstersRouter);
                            </code>
                        </pre>
                    </ul>
                </div>
                <hr/>
                <h3>Middleware</h3>
                <ul>
                    <li><strong>DRY</strong>ing Routes With app.use().
                    A path can be written as optional, to write middleware that will run for every request at a specific 
                    path. It can also be even an array of routes to reference more than one path.</li>
                    <li><strong>Middleware</strong> is code that executes between a server receiving a request and
                    sending a response. It operates on the boundary, so to speak, between those two HTTP actions.
                    Middleware is a function that can perform logic on the request and response objects, such
                    as: inspecting a request, performing some logic based on the request, attaching information to the 
                    response, attaching a status to the response, sending the response back to the user, or simply passing
                    the request and response to another middleware. Middleware can do any combination of those things or
                    anything else a Javascript function can do.</li>
                    <li><strong>Middleware stack: </strong> Is a chain of middleware. Most of Express's functionality is 
                    chaining middleware. <u>Express routes are middleware</u>. Every route created in Express is also a 
                    middleware function handling the request and response objects at that part of the stack.</li>
                    <ul>
                        <li>The routes are called in the order that they appear in the file, provided the previous route
                        called <strong>next()</strong> and thus passed control to the next middleware.</li>
                        <li>An Express middleware is a function with three parameters: <i>(req, res, next)</i>.
                        The third argument to a middleware function, <i>next</i>, should get explicitly called as the last 
                        part of the middleware’s body. This will hand off the processing of the request and the construction
                        of the response to the next middleware in the stack.</li>
                        <li><u>We don’t always want to pass control to the <i>next</i> middleware in the stack.</u>
                        For example, when designing a system with confidential information, we want to be able to selectively 
                        show that information to authorized users. In order to do that, we would create middleware that tests 
                        a user’s permissions. If the user has the permission necessary, we would continue through the middleware 
                        stack by calling <i>next()</i>. If it fails, we would want to let the user know that they’re not allowed to see 
                        the information they’re trying to access.</li>
                    </ul>
                    <li>Since middleware is just a function with a specific signature, namely <i>(req, res, next)</i>, 
                    we can define functions and using them as middleware.
                    We can remove the <i>app.use()</i> line and replace it with a specific route method, or sprinkle it throughout
                    the application without it being universal.
                    With modular pieces like this, it is useful to know that methods such as <i>app.use()</i>, <i>app.get()</i>, 
                    <i>app.post()</i>, and so on all can take multiple callbacks as additional parameters.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode36" onclick="showCode('displayCode36', 'showCode36')">Display</button>
                <div id="displayCode36">
                    <button onclick="closeCode('displayCode36', 'showCode36')">Close</button>
                    <ul>
                        <li><strong>app.use()</strong> & <strong>next()</strong></li>
                        <pre>
                            <code>
            //A path can be written as optional 
                so to write middleware that will run
                for every request at a specific path.
                It can be even an array of routes
                to reference more than one path.
            app.use([path, anotherPath](req, res, next) => {
                console.log("A sorcerer approaches!");
                next();
            });
                
            app.get('/magic/:spellname', (req, res, next) => {
                console.log("The sorcerer is casting a spell!");
                next();
            });
                
            app.get('/magic/:spellname', (req, res, next) => {
                console.log(`The sorcerer has cast ${req.params.spellname}`);
                res.status(200).send();
            });
                
            app.get('/magic/:spellname', (req, res, next) => {
                console.log("The sorcerer is leaving!");
            });
                
            // Accessing http://localhost:4001/magic/fireball 
            // Console Output:
            // "A sorcerer approaches!"
            // "The sorcerer is casting a spell!"
            // "The sorcerer has cast fireball"
                                </code>
                            </pre>
                            <hr/>
                            <li>Other example:</li>
                            <pre>
                                <code>
            const express = require('express');
            const app = express();

            app.use(express.static('public'));

            const PORT = process.env.PORT || 4001;

            const jellybeanBag = {
                mystery: {
                    number: 4
                },
                lemon: {
                    number: 5
                },
                rootBeer: {
                    number: 25
                },
                cherry: {
                    number: 3
                },
                licorice: {
                    number: 1
                }
            };

            // Logging Middleware 
                (this below could be changed for Morgan)
            app.use((req, res, next) => {
                console.log(`${req.method} Request Received`);
                next('Bag with that name does not exist');
            });

            app.use('/beans/:beanName', (req, res, next) => {
                const beanName = req.params.beanName;
                if (!jellybeanBag[beanName]) {
                    res.status(404).send('Bag with that name does not exist');
                    return console.log('Response Sent');
                }
                req.bean = jellybeanBag[beanName];
                req.beanName = beanName;
                next();
            });

            app.get('/beans/', (req, res, next) => {
                res.send(jellybeanBag);
                console.log('Response Sent');
            });

            app.post('/beans/', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
            });

            // This below could be changed for bodyParser.
            req.on('end', () => {
                const body = JSON.parse(bodyData);
                const beanName = body.name;
                if (jellybeanBag[beanName] || jellybeanBag[beanName] === 0) {
                    return res.status(404).send('Bag with that name already exists!');
                }
                const numberOfBeans = Number(body.number) || 0;
                jellybeanBag[beanName] = {
                    number: numberOfBeans
                };
                res.send(jellybeanBag[beanName]);
                console.log('Response Sent');
                });
            });

            app.get('/beans/:beanName', (req, res, next) => {
                res.send(req.bean);
                console.log('Response Sent');
            });

            app.post('/beans/:beanName/add', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
            });

            req.on('end', () => {
                const numberOfBeans = Number(JSON.parse(bodyData).number) || 0;
                req.bean.number += numberOfBeans;
                res.send(req.bean);
                console.log('Response Sent');
                });
            });

            app.post('/beans/:beanName/remove', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
            });

            req.on('end', () => {
                const numberOfBeans = Number(JSON.parse(bodyData).number) || 0;
                if (req.bean.number < numberOfBeans) {
                    return res.status(400).send('Not enough beans in the jar to remove!');
                }
                req.bean.number -= numberOfBeans;
                res.send(req.bean);
                console.log('Response Sent');
                });
            });

            app.delete('/beans/:beanName', (req, res, next) => {
                jellybeanBag[req.beanName] = null;
                res.status(204).send();
                console.log('Response Sent');
            });

            app.put('/beans/:beanName/name', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
                });

                req.on('end', () => {
                    const newName = JSON.parse(bodyData).name;
                    jellybeanBag[newName] = req.bean;
                    jellybeanBag[req.beanName] = null;
                    res.send(jellybeanBag[newName]);
                    console.log('Response Sent');
                });
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });
                                </code>
                            </pre>
                            <li>In the below code sample, we created reusable middleware for authentication and data validation. 
                            We use the authenticate() middleware to verify a user is logged in before proceeding with the request
                            and we use the validateData() middleware before performing the appropriate create or update function.
                            Additional middleware can be placed at any point in this chain.</li>
                            <pre>
                                <code>
            const authenticate = (req, res, next) => {
            ...
            };
            
            const validateData = (req, res, next) => {
            ...
            };
            
            const getSpell = (req, res, next) => {
                res.status(200).send(getSpellById(req.params.id));
            };
            
            const createSpell = (req, res, next) => {
                createSpellFromRequest(req);
                res.status(201).send();
            };
            
            const updateSpell = (req, res, next) => {
                updateSpellFromRequest(req);
                res.status(204).send();
            }
            
            app.get('/spells/:id', authenticate, getSpell);
            
            app.post('/spells', authenticate, validateData, createSpell);
            
            app.put('/spells/:id', authenticate, validateData, updateSpell);
                                </code>
                            </pre>
                        </ul>
                    </div>
                <h3>Open-Source Middleware</h3>
                <ul>
                    <li>If we needed to write a web server from scratch every time we wanted to build a web application, 
                    we’d waste a lot of time solving problems that have been solved countless times before and ignoring
                    perfectly good pre-existing solutions. Luckily for us web developers, Express already exists as an
                    <strong>open-source package</strong> that we can install and use to build upon. There is a huge ecosystem of Javascript
                    packages that will solve so many of the problems that developers frequently run into.</li>
                    <li><strong>Morgan: </strong>Is an open-source library for logging (console.log) information about the HTTP request-response
                    cycle in a server application. <i>morgan()</i> is a function that will return a middleware function 
                    that will have the function signature <i>(req, res, next)</i> that can be inserted into an <i>app.use()</i>,
                    and that function will be called before all following middleware functions. Morgan takes an argument 
                    to describe the formatting of the logging output. For example, <i>morgan('tiny')</i> will return a middleware 
                    function that does a “tiny” amount of logging. With morgan in place, we’ll be able to remove the existing logging code.</li>
                    <ul>
                        <li>Morgan's <strong>documentation</strong> <a href="https://github.com/expressjs/morgan" target="_blank">here</a>.</li>
                    </ul>
                    <li><strong>Body-parser: </strong>Simplifies a perform request body parsing. That substituted a lot
                    of the req.on code from the previous examples.</li>
                    <ul>
                        <li>Body-parser <strong>documentation</strong> <a href="https://github.com/expressjs/body-parser#body-parser" target="_blank">here</a>.</li>
                    </ul>
                    <li><strong>List of middlewares</strong> <a href="https://expressjs.com/en/resources/middleware.html" target="_blank">here</a>.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode37" onclick="showCode('displayCode37', 'showCode37')">Display</button>
                <div id="displayCode37">
                    <button onclick="closeCode('displayCode37', 'showCode37')">Close</button>
                    <ul>
                        <li><strong>Morgan</strong></li>
                        <pre>
                            <code>
            const express = require('express');
            const morgan = require('morgan');
            const app = express();

            //This will console.log 
                (`${req.method} Request Received`) 
                to every router.
            app.use(morgan('tiny'));

            //This will console .log 
                :method :url :status :response-time ms - :res[content-length]
                to every router.
            app.use(morgan('dev')); 
                            </code>
                        </pre>
                        <li><strong>Body-Parser</strong></li>
                        <pre>
                            <code>
            const bodyParser = require('body-parser');

            app.use(bodyParser.json());
                            </code>
                        </pre>
                        <li>Full code example: <strong>Morgan</strong> & <strong>body-parser</strong></li>
                        <pre>
                            <code>
            const express = require('express');
            const app = express();
            const morgan = require('morgan');
            const bodyParser = require('body-parser');

            app.use(express.static('public'));

            const PORT = process.env.PORT || 4001;

            const cards = [
                {
                    id: 1,
                    suit: 'Clubs',
                    rank: '2'
                },
                {
                    id: 2,
                    suit: 'Diamonds',
                    rank: 'Jack'
                },
                {
                    id: 3,
                    suit: 'Hearts',
                    rank: '10'
                }
            ];
            let nextId = 4;

            // Logging
            if (!process.env.IS_TEST_ENV) {
                app.use(morgan('short'));
            }

            // Parsing
            app.use(bodyParser.json());

            // Find card
            app.use('/cards/:cardId', (req, res, next) => {
                const cardId = Number(req.params.cardId);
                const cardIndex = cards.findIndex(card => card.id === cardId);
                if (cardIndex === -1) {
                    return res.status(404).send('Card not found');
                }
                req.cardIndex = cardIndex;
                next();
            });

            const validateCard = (req, res, next) => {
            const newCard = req.body;
            const validSuits = ['Clubs', 'Diamonds', 'Hearts', 'Spades'];
            const validRanks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace'];
            if (validSuits.indexOf(newCard.suit) === -1 || validRanks.indexOf(newCard.rank) === -1) {
                return res.status(400).send('Invalid card!');
            }
                next();
            };

            // Get all Cards
            app.get('/cards/', (req, res, next) => {
                res.send(cards);
            });

            // Create a new Card
            app.post('/cards/', validateCard, (req, res, next) => {
                const newCard = req.body;
                newCard.id = nextId++;
                cards.push(newCard);
                res.status(201).send(newCard);
            });

            // Get a single Card
            app.get('/cards/:cardId', (req, res, next) => {
                res.send(cards[req.cardIndex]);
            });

            // Update a Card
            app.put('/cards/:cardId', validateCard, (req, res, next) => {
                const newCard = req.body;
                const cardId = Number(req.params.cardId);
                if (!newCard.id || newCard.id !== cardId) {
                    newCard.id = cardId;
                }
                cards[req.cardIndex] = newCard;
                res.send(newCard);
            });

            // Delete a Card
            app.delete('/cards/:cardId', (req, res, next) => {
                cards.splice(req.cardIndex, 1);
                res.status(204).send();
            });

            // Start the server
            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });
                            </code>
                        </pre>
                    </ul>
                </div>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Postman</h2>
            <ul>
                <li>Postman is a GUI that aids in the development of APIs by 
                making it easy to test requests and their responses in an organized way.</li>
                <li>API requests with <strong>Postman</strong>(GUI) & <strong>cURL</strong>(Command Line)
                <a href="https://www.taniarascia.com/making-api-requests-postman-curl/" target="_blank">here</a></li>
                <hr/>
                <h3>API Requests</h3>
                <li><strong>Initializing: </strong>
                Set the URL connected to the server & the HTTP method.</li>
                <li><strong>GET: </strong>
                Write proper URL to GET request.</li>
                <li><strong>POST: </strong> It is <u>non-idempotent</u>, meaning that two identical 
                POST requests will create two new resources.<br>
                Select <strong>POST</strong> method, Body => Raw (set to JSON), 
                write the Post request. As the output, an id will be created as a property
                inside "user". Example: </li>
                <pre><code>{"user": {"username": "Victor", "password": "Rego"}}</code></pre>
                <li><strong>PUT: </strong>It is <u>idempotent</u>, meaning that two identical PUT requests will modify the same
                resource.<br>
                A <strong>PUT</strong> request requires the entire body to be sent through; if any data 
                is missing, that data will be wiped (except automatic values like auto-incrementing 
                IDs and timestamps).</li>
                <li><strong>PATCH: </strong>Updates an existing resource, and does not require
                sending the entire body with the request.</li>
                <li><strong>DELETE: </strong>Removes a resource. No values to send.</li>
                <li><strong>Authentication: </strong>
                In Postman, you'll go to Headers and add Authorization as the key and Bearer < JWT_TOKEN > as
                the value to send authentication values. You can also go to Headers, click Presets, Manage
                Presets, and put your own reusable variables in for any headers or values you'll be reusing a lot.</li>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>CORS</h2>
            <ul>
                <li><strong>Cross-origin resource sharing (CORS)</strong> is a standard mechanism that allows JavaScript XMLHttpRequest 
                (XHR) calls executed in a web page to interact with resources from non-origin domains (different domains that are outside
                current). 
                The CORS standard is needed because it allows servers to specify not only who can access the assets, but also
                how they can be accessed.</li>
                <li>Servers will allow GET requests, meaning they will allow resources from external origins (say, a web page) 
                to read their assets. HTTP requests methods like PATCH, PUT, or DELETE, however, may be denied to prevent
                malicious behavior. For many servers, this is intentional. For example, it is likely that server A does not
                want servers B, C, or D to edit or delete its assets.
                <u>With CORS, a server can specify who can access its assets and which HTTP request methods are allowed from external resources.</u></li>
                <li>An <strong>HTTP header</strong> is a piece of information associated with a request or a response.
                Headers are passed back and forth between your web browser (also referred to as a client) and a server when
                the web page you are on wants to use resources hosted on a different server. Headers are used to describe requests
                and responses. The CORS standard manages cross-origin requests by adding new HTTP headers to the standard list of headers. </li>
                <ul>
                    <li><strong>Access-Control-Allow-Origin:</strong> This header allows servers to specify how their resources are shared with external domains. 
                    When a GET request is made to access a resource on Server A, Server A will respond with a value for the Access-Control-Allow-Origin
                    header. Many times, this value will be *, meaning that Server A will share the requested resources with any domain on the 
                    Internet. Other times, the value of this header may be set to a particular domain (or list of domains), meaning that 
                    Server A will share its resources with that specific domain (or list of domains). The Access-Control-Allow-Origin 
                    header is critical to resource security.</li>
                    <li>List of <strong>Headers</strong><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#cors" target="_blank">here</a>.</li>
                </ul>
                <li><strong>Pre-flight request: </strong>
                Most servers will allow GET requests but may block requests to modify resources on the server. 
                Servers don’t just blindly block such requests; they have a process in place that first checks and then communicates 
                to the client (your web browser) which requests are allowed. When a request is made using any of the following HTTP request 
                methods, a standard preflight request will be made before the original request PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.    
                Preflight requests use the OPTIONS header. The preflight request is sent before the original request, 
                hence the term “preflight.” The purpose of the preflight request is to determine whether or not the original request is safe (for example, a 
                DELETE request). The server will respond to the preflight request and indicate whether or not the original request is safe. If the server specifies 
                that the original request is safe, it will allow the original request. Otherwise, it will block the original request.</li>
                <hr/>
                <h3>How to implement CORS?</h3>
                <li>Implementing the request headers to set up CORS correctly depends on the language and framework of the backend.
                <ul>
                    <li>If you are using Node, you can use setHeader(), <i>response.setHeader('Content-Type', 'text/html');</i>.</li>
                    <li>If you are using Express, you can use CORS middleware: <i>$ npm install cors</i></li>
                </ul>
                <pre>
                    <code>                   
                    var express = require('express');
                    var cors = require('cors');
                    var app = express();
                     
                    app.use(cors());
                     
                    app.get('/hello/:id', function (req, res, next) {
                      res.json({msg: 'Hello world, we are CORS-enabled!'});
                    });
                     
                    app.listen(80, function () {
                      console.log('CORS-enabled web server is listening on port 80');
                    });
                    </code>
                </pre>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>User Authentication and Authorization</h2>
            <ul>
                <li><strong>Authentication</strong> determines identity, <strong>authorization</strong> determines the privileges associated with an 
                identity, and <strong>encryption</strong> ensures that data can only be accessed by authorized parties.</li>
            </ul>
            <hr/>
            <h3>Authentication</h3>
            <ul>
                <li><strong>Authentication</strong> is the verification of who you are. For example, let’s say you’ve gone to a concert. At the front door, the 
                security guard asks to see your ticket and ID in order to verify that the name on your ID matches the name on your ticket. 
                Authentication relies on one or more factors to verify identity, and these factors come in three main types:</li>
                <ul>
                    <li><strong>Knowledge</strong> is something you know, like a username and password.</li> 
                    <li><strong>Possession</strong> is something you have, like a security card or mobile device.</li> 
                    <li><strong>Inherence</strong> is something you are, which generally refers to biometric data such as fingerprints.</li>
                </ul>
                <li><strong>Single-Factor Authentication: </strong>Relies on a single factor, such as a simple username/password combo,
                and is becoming increasingly insecure.</li>
                <li><strong>Multi-Factor Authentication: </strong>requires multiple factors, such as a username/password combo and a code 
                sent to a mobile device. This is distinct from Multi-Step authentication, which requires multiple types of authentication 
                within a single factor, such as a password and a PIN.</li>
            </ul>
            <hr/>
            <h3>Authorization</h3>
            <ul>
                <li><strong>Authorization</strong> is the verification of what you are allowed to do. 
                It is responsible for everything from preventing users from modifying each other’s accounts, to protecting back-end assets 
                from attackers, to granting limited access to external services.
                Good authorization will allow you to limit users and services to the privileges they require; just because a user is authorized 
                to manage one group doesn’t mean they should be able to manage all groups, for example.</li>
            </ul>
            <hr/>
            <h3>Encryption</h3>
            <strong>Encryption</strong> enforces authentication and authorization is encryption. 
            Encryption is the process of transforming data into a format that is unreadable unless you have the correct key to decrypt it.
        </div>
        <div class="styleGuide">
            <h2>Web Sessions & Security</h2>
            <h3>Sessions & Cookies & Localstorage</h3>
            <ul>
                <li><strong>Sessions & Cookies & Localstorage </strong>
                <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-user-authentication-authorization/modules/wdcp-22-session-authentication-in-express/cheatsheet" target="_blank">here.</a></li>
                <li><strong>Web sessions: </strong>HTTP(S) protocol on its own is stateless, meaning requests and 
                responses are just relaying information back and forth with no knowledge of a specific user.
                But web developers want to create engaging, personalized experiences for users. This means there needs to 
                be a system that associates the requests with a specific user and does so in a secure.
                Without it, every time you reloaded the window you would be logged out or lose your cart!
                A <strong>web session</strong> refers to a series of user interactions over a time frame. 
                <u>Session data is stored server-side and associated with a session ID.</u>
                Think of a session as short-term memory for a web application.</li>
                <li><strong>Sessions Cookies:</strong> A cookie is a text file that stores stateful client data in a 
                key-pair format. It is stored by the web browser, aka client-side.</li>
                <li><strong>Sessions localStorage and sessionStorage: </strong>
                Client-side browser storage introduced with HTML5 that stores data in a key-pair format. 
                It does not interact with the server and is only changeable through JavaScript, with simple syntax.</li>
                <li>Ideally, all sessions-based web applications should enforce <strong>HTTPS</strong> for all communication. This 
                prevents common web attacks that could give the attacker access to the session.
                Security headers allow you to customize your web application’s security policy! They are an important 
                line of defense against web attacks. You should research each header, different options for each, 
                and find out how they can improve security while maintaining usability.</li>
                <ul>
                    <li>List of Security Headers
                    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#security" target="_blank">here</a>.</li> 
                    <li>You can use <a href="https://securityheaders.com/" target="_blank">https://securityheaders.com/</a> 
                    to check which headers are active on your web address.</li>
                </ul>
                <hr/>
                <h3>Express Session</h3>
                <li>In order to implement sessions within an Express application, we can use the NPM module, express-session, 
                as a middleware. Once the session middleware is implemented, each user that navigates to our app will have a 
                unique session generated for them. This allows us to store their session data server-side under a session 
                identifier and easily retrieve it.</li>
                <li><strong>Express Configure:</strong></li>
                <ul>
                    <li><strong>secret:</strong> The secret property is a key used for signing and/or encrypting 
                    cookies in order to protect our session ID.
                    <li><strong>resave:</strong> Setting this option to true will force a session to be saved 
                    back to the session data store, even when no data was modified. Typically, this option should 
                    be false, but also depends on your session storage strategy.</li>
                    <li><strong>saveUninitialized</strong>: This property is a boolean value. If it’s set to true,
                    the server will store every new session, even if there are no changes to the session object. 
                    This might be useful if we want to keep track of recurring visits from the same browser, but 
                    overall, setting this property to false allows us to save memory space.</li>
                    <li>The resave & saveUninitialized determine how often the session object will be saved.</li>
                </ul>
                <li><strong>Storing Session Data:</strong>
                Sessions are typically stored in three different ways:</li>
                <ul>
                    <li>In <strong>memory</strong> (this is the default storage)</li>
                    <li>In a <strong>database</strong> like MongoDB or MySQL</li>
                    <li>A <strong>memory cache</strong> like Redis or Memcached.</li>
                    <li>Whenever a user makes a request from the same client with a valid session identifier, the server 
                    retrieves the valid session information. express-session provides an in-memory store called, <strong>MemoryStore()</strong>. If no other store 
                    is specified, then this is set as the default storage.</li>        
                </ul>
                <li><strong>Sessions and Authentication (Cookies):</strong>
                We should make use of client-side storage so that the user’s browser can automatically send over the 
                session identifier with each incoming HTTP request.
                We’ll tell the client browser to create a cookie that stores the session ID. We can also modify cookie attributes to add a bit of security.
                Cookies will have a few default properties set, but we can specify them using key-value pairs. </li>
                <ul>
                    <li><strong>maxAge</strong> property sets the number of milliseconds until the cookie expires.</li> 
                    <li><strong>secure attribute</strong> makes it only send to the server via HTTPS.</li> 
                    <li><strong>sameSite</strong> property setted to 
                    "none" allows a cross-site cookie through different browsers.</li>
                    <li><strong>Other cookie</strong> properties include: cookie.expires, cookie.httpOnly, cookie.sameSite</li>
                </ul>
                <li><strong>Sessions and Authentication (Logging In):</strong>
                With a session middleware configured, we can now make use of the session and combine it with an authentication process.
                <ul>
                    <li>We can do this by first looking up the user in our database and then verifying that the password is correct.</li>
                    <li>Once credentials are confirmed, we’ll add data to our session.</li>
                    <li>Once the user is logged in we’ll add a property, authenticated within our session object and assign it to 
                    true. We’ll also set user in the session data and assign it the username and password we received.</li>
                    <li>Once the user is logged in, their session is created and stored in memory. The properties authenticated and user will 
                    be accessible and changeable as session data.</li>
                </ul>
                <li><strong>Accessing Session Data: </strong>
                Data in a session is serialized as JSON when stored, so we’re able to store and access data in nested objects. Let’s say we had 
                saved the number of items in a user’s cart in the session data: <i>req.session.user.cartCount = 2;</i>
                We can then access it by referring to <i>req.session.user.cartCount</i> when we need to display the correct number of items. We can also update its value.
                One common use case of session data is to protect specific routes. In the example below, we check that the authorized 
                property exists within the session, and if it’s set to true before we move on to the next route handler.
                </li>
                <li><strong>Download project</strong> with <strong>Sessions Authentication</strong> & <strong>Sessions Access</strong> <a href="https://static-assets.codecademy.com/content/paths/web-security/sessions-in-express/sessions-auth-data.zip" target="_blank">here</a>.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode39" onclick="showCode('displayCode39', 'showCode39')">Display</button>
            <div id="displayCode39">
                <button onclick="closeCode('displayCode39', 'showCode39')">Close</button>
                <ul>
                    <li>We can <strong>install</strong> the package by running the following command:</li>        
                    <pre>
                        <code>
            npm install express-session
                        </code>
                    </pre>    
                    <li>From here, we import the session module and <strong>store it in a variable</strong>:</li>
                    <pre>
                        <code>
            const session = require("express-session")
                        </code>
                    </pre>
                    <li><strong>Configure express-session</strong> & <strong>Storing Session Data</strong></li>
                    <pre>
                        <code>
            //instantiate a new store
            const store = new session.MemoryStore();
            
            app.use(
                session({
                  secret: "f4z4gs$Gcg",
                  cookie: { maxAge: 1000 * 60 *60 * 24, secure: true, sameSite: "none" },
                  saveUninitialized: false,
                  resave: false,
                })
            );
                        </code>
                    </pre>  
                    <li><strong>Sessions Authentication</strong> & <strong>Sessions Access</strong></li>
                    <pre>
                        <code>
                const express = require("express");
                const app = express();
                const session = require("express-session");
                const store = new session.MemoryStore();
                const db = require("./db");
                const PORT = process.env.PORT || 4001;
                
                app.set("trust proxy", 1);
                app.use(express.json());
                app.use(express.urlencoded({ extended: false }));
                app.set("view engine", "ejs");
                app.use(express.static(__dirname + "/public"));
                
                app.use(
                    session({
                        secret: "f4z4gs$Gcg",
                        cookie: { maxAge: 300000000, secure: true, sameSite: "none" },
                        saveUninitialized: false,
                        resave: false,
                        store,
                    })
                );
                
                function ensureAuthentication(req, res, next) {
                    // Check for the authorized property within the session
                    if (req.session.authenticated) {
                        return next();
                    } else {
                        res.status(403).json({ msg: "You're not authorized to view this page" });
                    }
                }
                
                // Add your ensureAuthentication middleware below:
                app.get("/shop", ensureAuthentication, (req, res) => {
                    // Send the user object to the view page:
                    // res.render() takes in a view page as the 
                        first argument and an object whose properties 
                        define local variables for the view as the second argument.
                    res.render("shop", { user: req.session.user });
                });
                
                app.get("/login", (req, res) => {
                    res.render("login");
                });
                
                // POST request for logging in
                // Sessions and Authentication (Logging In)
                app.post("/login", (req, res) => {
                    const { username, password } = req.body;
                    db.users.findByUsername(username, (err, user) => {
                        if (!user) return res.status(403).json({ msg: "No user found!" });
                        if (user.password === password) {
                                req.session.authenticated = true;
                                req.session.user = {
                                username,
                                password,
                            };
                            res.redirect("/shop");
                        } else {
                            res.status(403).json({ msg: "Bad Credentials" });
                        }
                    });
                });
                
                app.listen(PORT, () => {
                    console.log(`Server is listening on port ${PORT}`);
                });
                            
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>JSON Web Tokens (JWTs)</h3>
            <ul>
                <li><strong>JSON Web Tokens</strong> are self-contained JSON objects that compactly and securely transmit information between 
                two parties. They are secure because they are digitally signed using a secret or a public/private key pair.</li>
                <li>JWTs are used for authorization: They’re often used for SSO.
                Information Exchange: If a server received a valid JWT, it knows the sender is who they say they are and the information hasn’t been tampered with.
                <ul>
                    <li>Why <strong>use JWTs?</strong> Parsing JSON is easier than some alternatives like XML or SAML.
                    JWTs are small, scale well, and are easier for mobile devices to process.</li>
                    <li>Why <strong>not use JWT</strong>?
                    A mix of a public and private key-pair adds security, but can also add complexity.
                    Sensitive information, like passwords or Social Security Numbers, should not be stored client-side, even if it is encoded.</li>
                </ul>
                <li>A JWT is made up of three components:</li>
                <ul>
                    <li><strong>JWT Header: </strong>A JWT header contains the type of the token we’re creating and the signing algorithm 
                    that will be used. <strong>Type:</strong> The type of this token will always be “JWT”. The Internet Assigned Numbers Authority, or IANA, coordinates internet 
                    protocol resources across the globe. The “JWT” type aligns with the media type “application/jwt“.
                    <strong>Algorithm:</strong> The signing, or hashing, algorithm used might vary. Some commonly used algorithms are HMAC-SHA256, 
                    represented by "HS256", RSA with SHA-256, represented by "RW256", and ECDSA with SHA-256, represented by "ES256".</li>
                    <li><strong>JWT Payload: </strong>A JWT payload contains claims about an entity. A claim is a statement or piece of 
                    information and the entity is often a user. There are three types of claims a JWT payload can contain:
                    <strong>Registered Claims:</strong> These are predefined claim types that anyone can use in a JWT.
                    <strong>Public Claims:</strong> These are custom claim types that are created by a developer and can be used 
                    publicly. They should be registered to avoid collisions, also known as repeated claims.
                    <strong>Private Claims:</strong> These are custom claim types that are not registered or public. They are only 
                    used between parties that have agreed to use them. List of registered claims and public claims 
                    <a href="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" target="_blank">here</a>.</li>
                    <li><strong>JWTSignature: </strong>Is used to verify that the JWT wasn’t tampered with or changed. 
                    It can be created taking the encoded header, the encoded payload, a secret, and using the hashing algorithm 
                    to create a hash from those elements.</li>
                </ul>
                <li><strong>Do not store your JWT in localStorage</strong> as an attacker could use Cross-Site Scripting 
                attacks to steal local data.
                <strong>Storing your JWT in a cookie could expose your data to a Cross-Site 
                Resource Forgery attack</strong>. Additionally, if a user has disabled cookies in their browser, 
                the application is now unable to store the JWT.</li>
                <li>JWT documentation <a href="https://jwt.io/" target="_blank">here</a>.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode40" onclick="showCode('displayCode40', 'showCode40')">Display</button>
            <div id="displayCode40">
                <button onclick="closeCode('displayCode40', 'showCode40')">Close</button>
                <ul>
                    <li>JWS <strong>Header</strong> specifying the <strong>HMAC-SHA256</strong> algorithm:</li>
                    <pre>
                        <code>
                {
                    'alg': 'HS256',  
                    'typ': 'JWT'
                }
                        </code>
                    </pre>
                    <li>JWS <strong>Payload</strong> using some common registered claims:</li>
                    <pre>
                        <code>
                
            {
                'sub': '1234567890',
                'name': 'Harine Cooper',
                'admin': false,
                'iat': 1620924478,
                'exp': 1620939187
            }
                        </code>
                    </pre>
                    <li>In this example, we will use <strong>jwt.io’s JWT debugger</strong> to create our <strong>final JWT</strong>.</li>
                    <ul>
                        <li>The secret is a symmetric key known by the sender and receiver of this token. </li>
                        <li>The <strong>Base64Url encoding of our header</strong> is: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</li>
                        <li>The <strong>Base64Url encoding of our payload</strong> is:<br/>
                        <i>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkhhcmluZSBDb29wZXIiLCJhZG1pbiI6ZmFsc2UsI<br/>mlhdCI6MTYyMDkyNDQ3OCwiZXhwIjoxNjIwOTM5MTg3fQ</i></li>
                        <li>Finally, we use the HMAC-SHA256 algorithm we defined in our header to create our signature:</li>
                        <pre>
                            <code>
                        HMACSHA256(
                            base64UrlEncode(header) + "." +
                            base64UrlEncode(payload),
                            secret)
                            </code>
                        </pre>
                        <li>Which gives us: <i>3B-FLgPETrExxlDKW30AoU7KGE6xuZodw79TQR8_mwM</i></li>
                        <li>Concatenating our encoded header, our encoded payload, and our signature, and separating each with a “.”, gives us our final token:
                        <i>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikhh<br/>cmluZSBDb29wZXIiLCJhZG1pbiI6ZmFsc2UsImlhdCI6MTYyMDkyNDQ3OCwiZXhwIjoxNjIwOTM5MTg3fQ.3B-FLgPETrExxlDKW30AoU7KGE6xuZodw79TQR8_mwM</i></li>
                    </ul>
                </ul>
            </div>
            <hr/>
            <h3>Protecting information (Encryption, Hashing, Encoding, Obfuscation)</h3>
            <ul>
                <li><strong>Encryption: </strong>
                    Encryption Cryptography is the science of hiding data and making it available again. In 
                    cryptography, hiding data is called encryption and unhiding it is called decryption. When data is
                    securely exchanged, it is first encrypted by the sender, and then decrypted by the receiver using 
                    a special key. There are two main types of encryption: symmetric and asymmetric.
                    Asymmetric encryption is the most secure way to transmit data; however, it is slower and more complex than
                    symmetric encryption. Therefore, it is primarily used to exchange smaller pieces of data.</li>
                    <ul>
                        <li><strong>Symmetric</strong> encryption uses the same key to both encrypt and decrypt data.</li>
                        <li><strong>Asymmetric</strong> encryption uses two different keys to encrypt and decrypt data.</li>
                    </ul>
                <li><strong>Hashing: </strong>
                Hashing does not encrypt data. Instead, hashing is a one-way process that takes a piece of data of any size 
                and uses a mathematical function to represent that data with a unique hash value of a fixed size. You cannot 
                compute the original data from its hash.
                Because each hash should be unique, hashing allows us to see if changes have been made to documents.
                <ul>
                    <li>Hashes are widely used in order to <strong>store passwords in online databases</strong>. If passwords are stored in plaintext 
                    and a database is breached, so are all of the passwords! However, if they are stored as hash values, even if 
                    someone hacks into a website’s database, only the password hashes are exposed.</li>
                    <li><strong>For example</strong>, let’s suppose a user’s password is: <i>CodecademyIsGr8t</i>
                    Now, if the website storing the password is using a SHA-256 hash, even if someone hacked into that website, 
                    all the hacker would see is the hash value:
                    <i>d04f855e71ad9d495d91e666175d593b669f45970f885a258f6dbbaab262ac8b</i>
                    Remember, an attacker has no way of decrypting a hash value to get the original value. Hashing is a one-way process.</li>
                </ul>
                <li><strong>Encoding: </strong>While it may sound similar to encryption, encoding is not actually used to hide 
                data. Encoding transforms data into a form that can be used by a different type of system. Some different types 
                of encoding are: <strong>ASCII, Unicode, Base64</strong>. Encoded information is easily reversed and only requires 
                knowledge of the algorithm used to decode information.</li>
                <li><strong>Obfuscation: </strong>Obfuscation is less about data security and more about securing code. Developers might 
                obfuscate their code in order to hide what their code is actually doing. Obfuscate means to hide the meaning of something 
                by making it difficult to understand.
                Developers might want to hide trade secrets or intellectual property from others who can access their code. 
                Obfuscating their code makes it difficult for others to steal code and use it for their own purposes. Obfuscation can also make 
                it harder for users to hack software or get around licensing requirements needed to use programs.
                Malicious actors might also use obfuscation to make it hard for users or antivirus software to detect a virus they are 
                planting on a system. If you don’t know what an application is for, be very careful before downloading or opening it.</li>
            </ul>
            <hr/>
            <h3>Passport.js</h3>
            <li>Passport.js is a flexible authentication middleware for Node.js that can be added to any Express-based 
            application. With Passport.js we can implement authentication using the concept of strategies.
            Passport strategies are separate modules created to work with different means of authentication. Passport is a very extensible 
            middleware, and it allows you to plug in over 300 different authentication providers like Facebook, Twitter, Google, and more.</li>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode41" onclick="showCode('displayCode41', 'showCode41')">Display</button>
            <div id="displayCode41">
                <button onclick="closeCode('displayCode41', 'showCode41')">Close</button>
                <ul>
                    <li><strong>Configuring Passport.js: </strong>
                    One of the great things about using Passport.js is that a lot of the heavy lifting is taken care of 
                    by the module. In order to use it, we need to configure it and implement cookies and sessions for 
                    persistent logins.</li>
                    <ul>
                        <li>To start using the traditional authentication module, we <strong>install the passport</strong> and the <strong>passport-local</strong> 
                        packages via the terminal: <i>npm install passport passport-local</i>
                        <li>Once imported, <strong>we require the passport and passport-local</strong> packages in our JavaScript file as below.
                        We’re importing the passport-local package with its Strategy instance to authenticate users with 
                        a username and password.</li>
                        <pre>
                            <code>
                const passport = require("passport");
                const LocalStrategy = require("passport-local").Strategy;
                            </code>
                        </pre>    
                        <li>Now that we have the package installed, we can <strong>initialize</strong> it by calling the initialize() method:
                        <i>app.use(passport.initialize());</i>
                        passport is a middleware and must be implemented using <i>app.use()</i>. The <i>initialize()</i> method initializes 
                        the authentication module across our app.</li>
                        <li>Next, we want to <strong>allow for persistent logins</strong>, and we can do this by calling <i>session()</i> on our passport 
                        module: <i>app.use(passport.session());</i>
                        The <i>session()</i> middleware alters the request object and is able to attach a ‘user’ value that can be 
                        retrieved from the session id.</li>
                    </ul>
                    <hr/>
                    <li><strong>Passport's Local Strategy</strong></li>
                    <ul>
                        <li>With Passport configured, we can now set up the passport-local strategy for authenticating with a username and password.
                        First, we can configure the local strategy by creating a new instance of it and passing it as middleware into passport:</li>
                        <pre>
                            <code>
                    passport.use(new LocalStrategy(
                        function(username, password, done) {
                        // …
                        }
                    ));
                            </code>
                        </pre>
                        <li>The new LocalStrategy object will take in an anonymous function with the following parameters:</li>
                        <ul>
                            <li>username</li>
                            <li>password</li>
                            <li>A callback function called done.</li>
                        </ul>
                        <li>The purpose of the done callback is to supply an authenticated user to Passport if a user is authenticated. 
                        The logic within the anonymous function follows this order:</li>
                        <ol>
                            <li>Verify login details in the callback function.</li>
                            <li>If login details are valid, the done callback function is invoked and the user is authenticated.</li>
                            <li>If the user is not authenticated, pass false into the callback function.</li>
                        </ol>
                        <li>The done callback function takes in two arguments:</li>
                        <ul>
                            <li>An error or null if no error is found.</li>
                            <li>A user or false if no user is found.</li>
                        </ul>
                        <li>With those steps implemented our updated strategy should look like:</li>
                        <pre>
                            <code>
                    passport.use(new LocalStrategy(
                    function (username, password, done) {
                        // Look up user in the db
                        db.users.findByUsername(username, (err, user) => {
                        // If there's an error in db lookup, 
                        // return err callback function
                        if(err) return done(err);
                    
                        // If user not found, 
                        // return null and false in callback
                        if(!user) return done(null, false);
                    
                        // If user found, but password not valid, 
                        // return err and false in callback
                        if(user.password != password) return done(null, false);
                    
                        // If user found and password valid, 
                        // return the user object in callback
                        return done(null, user)
                        });
                    })
                    );
                            </code>
                        </pre>
                        <li>We’re looking for potential errors during the authentication process and addressing them before the next request handler is reached.</li>
                        <li>Once the local strategy is configured, the Express application will have user authentication implemented!</li>
                    </ul>
                    <hr/>
                    <li><strong>Passport Implementation: </strong></li>
                    <pre>
                        <code>
                const express = require("express");
                const app = express();
                const passport = require("passport");
                const LocalStrategy = require("passport-local").Strategy;
                const session = require("express-session");
                const PORT = process.env.PORT || 5000;
                
                app.use(
                    session({
                    secret: "secret-key",
                    resave: false,
                    saveUninitialized: false,
                    })
                );
                
                app.use(passport.initialize());
                app.use(passport.session());
                
                // Add your passport local strategy below:
                passport.use(new LocalStrategy(
                    function (username, password, done) {
                        db.users.findByUsername(username, (err, user) => {
                            if(err) return done(err);
                            if(!user) return done(null, false);
                            if(user.password != password) return done(null, false);
                            return done(null, user)
                        });
                    })
                );
                
                app.get("/", (req, res) => {
                    res.send("Hello from the homepage!");
                });
                
                app.listen(PORT, () => {
                    console.log(`Server is listening on port: ${PORT}`);
                });
                        </code>
                    </pre>
                </ul>
            </div>
        </div>
    </body>
</html>
