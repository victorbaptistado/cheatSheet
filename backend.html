<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="./component/button.js" defer></script>
        <title>Backend</title>
    </header>
    <body>
        <nav>
            <ul class="mainNav">
                <li><a href="./AI.html">AI</a></li>
                <li><a href="./displayProperties.html">Display Properties</a></li>
                <li><a href="./objects.html">Objects</a></li>
                <li><a href="./operationalSystem.html">Operational System</a></li>
                <li><a href="./debugTesting.html">Debug & Testing</a></li>
                <li><a href="./git.html">Git</a></li>
                <li><a href="./form.html">Form</a></li>
                <li><a href="./api.html">API</a></li>
                <li><a href="./react.html">REACT</a></li>
                <li><a href="./index.html">Helpful Content</a></li>
                <li><a href="#">Backend</a></li>
            </ul>
        </nav>
        <header>
            <h1>Backend</h1>
        </header>
        <div class="styleGuide">
            <h2>Node.js</h2>
            <ul>
                <li><strong>Node</strong> provides the ability to run JavaScript programs on our own computers instead of just in the browser's 
                    console or embedded in HTML.</li>
                    <ul>
                        <li>To <strong>run a program</strong> with node <i>$ node myProgram.js</i></li>
                    </ul>
                <li><strong>Codecademy Material</strong> <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-introduction-to-back-end/modules/wdcp-22-back-end-javascript-with-node-js/cheatsheet" target="_blank">here</a></li>
                <li><strong>Node.js Documentation</strong> <a href="https://nodejs.org/en/docs/" target="_blank">here</a>.</li>
                <li><strong>nodemon</strong> is a tool that helps develop Node.js based applications by automatically 
                restarting the node application when file changes in the directory are detected. Documentation
                <a href="https://www.npmjs.com/package/nodemon" target="_blank">here</a></li>
            </ul>
            <hr/>
            <h3>REPL</h3>
            <ul>
               <li><strong>REPL</strong> is an abbreviation for <u>read-eval-print loop</u>. It's a program that loops, or 
                repeatedly cycles, through three different states: a read state where the program reads
                input from a user, the eval state where the program evaluates the user's input, and the
                print state where the program prints out its evaluation to a console.</li>
                <li>A REPL can be extremely useful for performing calculations, learning a language, and developing
                code. It’s a place where you can explore language features and try things out while receiving 
                immediate feedback.</li>
                <li>To access REPL, type <i>node</i> in the terminal.</li>
            </ul>
            <hr/>
            <h3>Modules</h3>
            <ul>
                <li><strong>Modules</strong> are reusable pieces of code in a file that can be exported and then
                imported for use in another file. A modular program is one whose components can be separated, 
                used individually, and recombined to create a complex system.
                <strong>Module</strong> tends to refer to larger bundles, whilst <strong>Components</strong>
                on the other hand tend to be smaller bundles of code, often smaller than a full class - 
                they tend to be a component of something larger.</li>
                <li>There are two runtime environments and each has a preferred module implementation:</li>
                <ul>
                    <li>The <strong>Node</strong> runtime environment: <i>module.exports</i> and <i>require()</i> syntax.</li>
                    <li>The <strong>browser’s</strong> runtime environment and the ES6 <i>import/export</i> syntax.</li>
                </ul>
                <li>Within Node.js applications, developers have access to a number of <strong>core modules</strong> that come 
                preshipped when you install Node.js onto your machine.</li>
                <li>There are also modules created by other developers - these third-party modules often solve common
                problems and simplify the development process. When we use these modules in our code, they are 
                referred to as <strong>dependencies</strong>.</li>
                <ul>
                    <li>Most of the time, these dependencies are installed in packages handled by a <strong>package manager</strong>.
                    A package is a third-party module wrapped up with the list of that module's own dependencies.
                    The most popular package manager is <strong>Node Package Manager(npm)</strong> which is the 
                    default package manager for Node.js. You can install it using:</li> 
                    <ul>
                        <li><i>npm i < package name ></i> or <i>npm install < package name ></i></li>
                        <li><i>npm i</i></li>
                        <li><i>npm i --production</i> If you wish to leave out development dependencies.</li>
                    </ul>
                    <li>Open source developers and developers at companies use the <strong>npm registry</strong> 
                    to contribute packages to the entire community or members of their organizations, and download
                    packages to use in their own projects.</li>
                </ul>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode33" onclick="showCode('displayCode33', 'showCode33')">Display</button>
            <div id="displayCode33">
                <button onclick="closeCode('displayCode33', 'showCode33')">Close</button>
                <ul>
                    <li><strong>module.exports</strong>:</li>
                    <pre>
                        <code>
                function celsiusToFahrenheit(celsius) {
                    return celsius * (9/5) + 32;
                }
                    
                module.exports.celsiusToFahrenheit = celsiusToFahrenheit;
                module.exports.fahrenheitToCelsius = function(fahrenheit) {
                    return (fahrenheit - 32) * (5/9);
                };
                        </code>
                    </pre>
                    <li><strong>require()</strong>:</li>
                    <pre>
                        <code>
            const converters = require('./converters.js');
 
            const freezingPointC = 0;
            const boilingPointC = 100;
            
            const freezingPointF = converters.celsiusToFahrenheit(freezingPointC);
            const boilingPointF = converters.celsiusToFahrenheit(boilingPointC);
            
            console.log(`The freezing point of water in Fahrenheit is ${freezingPointF}`);
            console.log(`The boiling point of water in Fahrenheit is ${boilingPointF}`);
                        </code>
                    </pre>
                    <li><strong>require()</strong> with <strong>destructuring</strong>:</li>
                    <pre>
                        <code>
            /* celsius-to-fahrenheit.js */
            const { celsiusToFahrenheit } = require('./converters.js');
            
            const celsiusInput = process.argv[2]; 
            const fahrenheitValue = celsiusToFahrenheit(celsiusInput);
            
            console.log(`${celsiusInput} degrees Celsius = ${fahrenheitValue} degrees Fahrenheit`);
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>Node Modules</h3>
            <ul>
                <li><strong>Core Modules: </strong>are built into the Node.js environment to efficiently 
                perform common tasks. To access core modules, inside REPL type: <i>require('module').builtinModules</i></li>
                <li><strong>Process Module: </strong>Node has a global process object with useful methods and 
                information about the <strong>current process.</strong>Type in the code:</li>
                <ul>
                    <li>The <strong>process.env</strong> property is an object which stores and controls information 
                    about the environment in which the process is currently running.</li>
                    <li>The <strong>process.memoryUsage()</strong> returns information on the CPU
                    demands of the current process.</li>
                    <li>The <strong>process.argv</strong> property holds an array of command line values provided 
                    when the current process was initiated.</li>
                </ul>
                <li><strong>OS Module: </strong>When developing or debugging an app, it can be helpful to have information about the 
                computer, operating system, and network on which the program is running.
                the os module is not global and needs to be included into the file in order to gain access to it’s methods. 
                You can include the os module into your file by typing: <i>const os = require('os');</i></li>
                <ul>
                    <li><strong>os.type()</strong> — to return the computer’s operating system.</li>
                    <li><strong>os.arch()</strong> — to return the operating system CPU architecture.</li>
                    <li><strong>os.networkInterfaces()</strong> — to return information about the network interfaces of the 
                    computer, such as IP and MAC address.</li>
                    <li><strong>os.homedir()</strong> — to return the current user’s home directory.</li>
                    <li><strong>os.hostname()</strong> — to return the hostname of the operating system.</li>
                    <li><strong>os.uptime()</strong> — to return the system uptime, in seconds.</li>
                </ul>
                <li><strong>Util Module:</strong> Utility functions don’t necessarily create new functionality 
                in a program, but you can think of them as internal tools used to maintain and debug your code.
                The Node.js util core module contains methods specifically designed for these purposes. 
                The util module can be required into the file using:<i> const util = require('util');</i></li>
                <ul>
                    <li><strong>types: </strong>which provides methods for runtime type checking in Node.</li>
                    <li><strong>promisify: </strong>turns callback functions into promises.</li>
                </ul>
                <li><strong>Event Module: </strong>
                Node.js has an EventEmitter class which can be accessed by importing the events core 
                module by using the <i>require()</i> statement. Each event emitter instance has an <i>.on()</i> method
                which assigns a listener callback function to a named event. EventEmitter also has an <i>.emit()</i> 
                method which announces a named event that has occurred.</li>
                <li><strong>Error Module: </strong>Within our own code, we can generate errors and throw them, and, with synchronous
                code in Node, we can use error handling techniques such as <i>try...catch</i> statements.
                However we cannot use try...catch when the error is thrown asynchronously. Many asynchronous Node APIs use
                error-first callback functions—callback functions which have an error as the first expected argument and the data as
                the second argument. If the asynchronous task results in an error, it will be passed in as the first argument to the
                callback function. If no error was thrown, the first argument will be undefined.</li>
                <li><strong>Input/Output: </strong>Input is data that is given to the computer, while output is 
                any data or feedback that a computer provides. In Node, we can get input from a user using the 
                <i>stdin.on()</i> method on the process object. We are able to use this because <i>.on()</i> is an instance 
                of EventEmitter. To give an output, we can use the <i>.stdout.write()</i> method on the process object
                as well. This is because <i>console.log()</i> is a thin wrapper on .stdout.write().</li>
                <li><strong>Buffer Module: </strong>Is used to handle binary data. 
                It provides a variety of methods to handle the binary data such as .alloc(), .toString(), .from(), and .concat()</li>
                <ul>
                    <li>The <strong>.alloc()</strong> Method: Allows a new Buffer object to be created with the 
                    size specified as the first argument. Optionally, a second argument can be provided to specify 
                    the fill and a third argument to specify the encoding.</li>
                    <li>The <strong>.toString()</strong> Method: A Buffer object can be translated into a human-readable 
                    string by chaining the .toString() method to a Buffer object. Optionally, encoding can be specified
                    as the first argument, byte offset to begin translating can be provided as the second argument, and
                    the byte offset to end translating as the third argument.</li>
                    <li>The <strong>.from()</strong> Method: A new Buffer object can be created from a specified string, 
                    array, or another Buffer object using the .from() method. Encoding can be specified optionally as the
                    second argument.</li>
                    <li>The <strong>.concat()</strong> Method: Joins all Buffer objects in the specified array into
                    one Buffer object. The length of the concatenated Buffer can be optionally provided as the second
                    argument. This method is useful because a Buffer object can't be resized.</li>
                </ul>
                <li><strong>FS Module (file system): </strong>All of the data on a computer is organized and accessed
                through a filesystem. When running JavaScript code on a browser, it’s important for a script to have
                only limited access to a user’s filesystem. This technique of isolating some applications from others
                is known as sandboxing. In the back-end, however, less restricted interaction with the filesystem is essential.
                The Node <strong>fs core module</strong> is an API for interacting with the file system.
                Import module via <i>require('fs');</i>
                The <strong>.readFile()</strong> Method: Reads data from a provided file.</li>
                <li><strong>Readable/Writable Streams: </strong>In most cases, data isn’t processed all at once but
                rather piece by piece. This is what we call streams. Streaming data is preferred as it doesn’t require
                tons of RAM and doesn’t need to have all the data on hand to begin processing it. To read files
                line-by-line, we can use the <i>.createInterface()</i> Method from the readline core module. We can write to
                streams by using the <i>.createWriteStream()</i> Method.</li>
                <li><strong>Timers Module:</strong> There are times when we want some of our code to be executed at a
                specified point in time. This is what the timers module is used for.
                Timer functions in Node.js behave similarly to how they work in front-end JavaScript programs,
                but the difference is that they are added to the Node.js event loop. This means that the timer
                functions are scheduled and put into a queue. This queue is processed at every iteration of the
                event loop. If a timer function is executed outside of a module, the behavior will be random (non-deterministic).</li>
                The <strong>setImmediate()</strong> function is often compared with the setTimeout() function.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode31" onclick="showCode('displayCode31', 'showCode31')">Display</button>
            <div id="displayCode31">
                <button onclick="closeCode('displayCode31', 'showCode31')">Close</button>
                <ul>
                    <li><strong>Event Module</strong></li>
                    <pre>
                        <code>
                let newUserListener = (data) => {
                    console.log(`We have a new user: ${data}.`);
                };
                    
                // Assign the newUserListener function as the listener callback for 'new user' events
                myEmitter.on('new user', newUserListener)
                
                // Emit a 'new user' event
                myEmitter.emit('new user', 'Lily Pad') //newUserListener will be invoked with 'Lily Pad'
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Error Module</strong></li>
                    <pre>
                        <code>
                const errorFirstCallback = (err, data)  => {
                    if (err) {
                    console.log(`There WAS an error: ${err}`);
                    } else {
                    // err was falsy
                    console.log(`There was NO error. Event data: ${data}`);
                    }
                }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Input/Output</strong></li>
                    <ul>
                        <li>In the Node environment, the console is the terminal, and the console.log() 
                        method is a “thin wrapper” on the .stdout.write() method of the process object. 
                        stdout stands for standard output.</li>
                    </ul>
                    <pre>
                        <code>
                process.stdout.write(
                "I'm thinking of a number from 1 through 10. What do you think it is?
                \n(Write \"quit\" to give up.)\n\nIs the number ... ");

                process.stdin.on('data', (userInput) => {
                    let input = userInput.toString()
                    console.log(input)
                });
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>FS Module</strong></li>
                    <ul>
                        <li>readFile()</li>
                        <pre>
                            <code>
                const fs = require('fs');

                let readDataCallback = (err, data) => {
                    if (err) {
                        console.log(`Something went wrong: ${err}`);
                    } else {
                        console.log(`Provided file contained: ${data}`);
                    }
                };
                
                fs.readFile('./file.txt', 'utf-8', readDataCallback);
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Read/Write Streams</strong></li>
                    <ul>
                        <li><strong>createInterface() </strong>& <strong>createReadStream()</strong></li>
                        <pre>
                            <code>
                const readline = require('readline');
                const fs = require('fs');
                
                const myInterface = readline.createInterface({
                    input: fs.createReadStream('text.txt')
                });
                
                myInterface.on('line', (fileLine) => {
                    console.log(`The line read: ${fileLine}`);
                });
                            </code>
                        </pre>
                        <li><strong>.createWriteStream()</strong></li>
                        <pre>
                            <code>
                const fs = require('fs')
                const fileStream = fs.createWriteStream('output.txt');
                
                fileStream.write('This is the first line!'); 
                fileStream.write('This is the second line!');
                fileStream.end();
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Timers Module</strong></li>
                    <ul>
                        <li><strong>setImmediate()</strong></li>
                        <pre>
                            <code>
                    setImmediate(() => {
                        console.log('Hello! My name is Codey.')
                    });
                            </code>
                        </pre>
                    </ul>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>Express.js</h2>
            <ul>
                <li><strong>Express.js: </strong>Is a server-side framework built upon Node.js. A server-side framework can handle 
                a lot of the back-end responsibilities without needing to come up with a custom solution, which
                saves a lot of time. This workflow might include things like accessing databases, generating HTML,
                handling URL routing, access to libraries built to work with the framework, existing resources and
                documentation for solving common problems, improved security.</li>
                <li>Express Documentation <a href="https://expressjs.com/en/4x/api.html" target="_blank">here</a>.</li>
                <li>Express simple explanation <a href="https://www.freecodecamp.org/news/going-out-to-eat-and-understanding-the-basics-of-express-js-f034a029fb66/" target="_blank">here</a>.</li>
                <li>Express API Project <a href="https://codecademy-content.s3.amazonaws.com/PRO/independent-practice-projects/quote-api/quote-api-solution.zip" target="_blank">here</a>.</li>
                <li>Boss machine full project<a href="https://content.codecademy.com/PRO/skill-paths/backend-javascript/projects/boss-machine/project-4-boss-machine-solution.zip" target="_blank">here</a></li>
                <hr/>
                <h3>Initiating</h3>
                <li>Express is a Node module, so in order to use it, we will need to import it into our program file
                with <i>require('express')</i>.</li>
                <li><strong>app.listen():</strong> The purpose of a server is to listen for requests, perform whatever action is required to satisfy 
                the request, and then return a response. In order for our server to start responding, as first argument
                we have to tell the server where to listen for new requests by providing a port number argument to a method called 
                <i>app.listen()</i>. The server will then listen on the specified port and respond to any requests that come 
                into it. The second argument is a callback function that will be called once the server is running and ready to receive responses.</li>
            </ul>
            <hr/>
            <h3>Routes</h3>
            <ul>
                <li><strong>Routes: </strong>registering a series of routes we tell our server how to deal with any given request. 
                It defines the control flow for requests based on the request's path and HTTP verb.
                For example, if your server receives a GET request at <i>/monsters</i>, we will use a route to
                define the appropriate functionality for that HTTP verb (GET) and path (/monsters).</li>
                <ul>
                    <li><i>localhost:4001/monsters</i>, the path is <i>/monsters</i>, hostname is <i>localhost</i>, the port
                    number is <i>4001</i>).</li>
                    <li>Express tries to match requests by route, meaning that if we send a request to 
                    < server address >:< port number ><i>/api-endpoint</i>, the Express server will search through any
                    registered routes in order that they are registered in your code and try to match <i>/api-endpoint</i>.
                    The first one that is matched will be used, and its callback will be called.</li>
                </ul>
                <li><strong>Route Parameters: </strong>Makes Routes dynamic. Parameters are route path segments 
                    that begin with <i>:</i> in their Express route definitions. They act as wildcards, matching any
                    text at that path segment. For example <i>/monsters/:id</i> will match <i>both/monsters/1</i>
                    and <i>/monsters/45</i>.</li>
                <ul>
                    <li>Express parses any parameters, extracts their actual values, and attaches them as an object
                    to the request object: <strong>req.params</strong>. This object’s keys are any parameter names
                    in the route, and each key’s value is the actual value of that field per request.</li>
                    <li>Not all APIs implement route parameters but when they do, it most commonly does not access
                    sensitive data, unless it also requires to have an API key to access the response from such route.</li>
                    <li><strong>router.param()</strong>: When working with routes that require parameters, we might find
                    ourselves in a position where multiple different routes require the same parameter and use it to 
                    identify the same piece of data.router.param.</li>
                </ul>
                <li><strong>Merge Parameters: </strong>When we’re building web endpoints, we might want to access 
                some property of a complex object. In order to do this in Express, we can design a nested router. 
                This would be a router that is invoked within another router. In order to pass parameters the parent 
                router has access to, we pass a special configuration object when defining the router.</li>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode38" onclick="showCode('displayCode38', 'showCode38')">Display</button>
                <div id="displayCode38">
                    <button onclick="closeCode('displayCode38', 'showCode38')">Close</button>
                    <ul>
                        <li><strong>router.param()</strong></li>
                        <pre>
                            <code>
                    app.param('spellId', (req, res, next, id) => {
                        let spellId = Number(id);
                        try {
                        const found = SpellBook.find((spell) => {
                            return spellId === spell.id;
                        })
                        if (found) {
                            req.spell = found;
                            next();
                        } else {
                            next(new Error('Your magic spell was not found in any of our tomes'));
                        };
                        } catch (err) {
                            next(err)
                        }
                    });
                            </code>
                        </pre>
                        <li><strong>Full example:</strong></li>
                        <pre>
                            <code>
                const express = require('express');
                const app = express();
                const bodyParser = require('body-parser');

                app.use(express.static('public'));

                const PORT = process.env.PORT || 4001;

                const spiceRack = [
                {
                    id: 1,
                    name: 'cardamom',
                    grams: 45,
                },
                {
                    id: 2,
                    name: 'pimento',
                    grams: 20,
                },
                {
                    id: 3,
                    name: 'cumin',
                    grams: 450,
                },
                {
                    id: 4,
                    name: 'sichuan peppercorns',
                    grams: 107,
                }
                ];

                let nextSpiceId = 5;

                app.use(bodyParser.json());

                // Add your code here:
                app.param('spiceId', (req, res, next, id) => {
                const spiceId = Number(id);
                const spiceIndex = spiceRack.findIndex(spice => spice.id === spiceId);
                
                if (spiceIndex !== -1){
                    req.spiceIndex = spiceIndex;
                    next();
                } else {
                    res.sendStatus(404);
                }
                })


                app.get('/spices/', (req, res, next) => {
                res.send(spiceRack);
                });

                app.post('/spices/', (req, res, next) => {
                const newSpice = req.body.spice;
                if (newSpice.name  && newSpice.grams) {
                    newSpice.id = nextSpiceId++;
                    spiceRack.push(newSpice);
                    res.send(newSpice);
                } else {
                    res.status(400).send();
                }
                });

                app.get('/spices/:spiceId', (req, res, next) => {
                res.send(spiceRack[req.spiceIndex]);
                });

                app.put('/spices/:spiceId', (req, res, next) => {
                spiceRack[req.spiceIndex] = req.body.spice;
                res.send(spiceRack[req.spiceIndex]);
                });

                app.delete('/spices/:spiceId', (req, res, next) => {
                spiceRack.splice(req.spiceIndex, 1);
                res.status(204).send();
                });

                app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
                });
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Merge Parameters:</strong></li>
                        <pre>
                            <code>
            const sorcererRouter = express.Router();
            const familiarRouter = express.Router({mergeParams: true});
                
            sorcererRouter.use('/:sorcererId/familiars', familiarRouter);
                
            sorcererRouter.get('/', (req, res, next) => {
                res.status(200).send(Sorcerers);
                next();
            });
                
            sorcererRouter.param('sorcererId', (req, res, next, id) => {
                const sorcerer = getSorcererById(id);   
                req.sorcerer = sorcerer;
                next();
            });
                
            familiarRouter.get('/', (req, res, next) => {
                res.status(200).send(`Sorcerer ${req.sorcerer} has familiars ${getFamiliars(sorcerer)}`);
            });
                
            app.use('/sorcerer', sorcererRouter);
                            </code>
                        </pre>
                    </ul>
                </div>
                <hr/>
            </ul>
            <h3>CRUD</h3>
            <ul>
                <li>app.get, app.put, app.post, app.delete are used to connect with api requests.
                This is the cleanest order to use:</li>
                    <ul>
                        <li>GET <i>/expressions/</i></li>
                        <li>GET <i>/expressions/:id</i></li>
                        <li>PUT <i>/expressions/:id</i></li>
                        <li>DELETE <i>/expressions/:id</i></li>
                    </ul>
                <li><strong>app.get():</strong> Registers routes to match GET requests. Express routes (including
                app.get()) usually take two arguments, a path (usually a string), and a callback function to handle
                the request and send a response.</li>
                <ul>
                    <li><strong>res: </strong>Facilitates how we can submit responses by providing a response 
                    object, commonly seen as: res, and it represents the HTTP response that we will emit when 
                    we receive an HTTP request to any of our endpoints. Inside of it, we just need to pass
                    the data of the response using:</li>
                    <ul>
                        <li><strong>.send()</strong>: Express servers send responses using the <i>.send()</i> method on the
                        response object. <i>.send()</i> will take any input and include it in the response body.</li>
                        <li><strong>.json()</strong>: can also be used to explicitly send JSON-formatted responses. 
                        <i>.json()</i> sends any JavaScript object passed into it.</li>
                    </ul>
                </ul>
                <li><strong>app.post(): </strong>POST request are use to create a new resource.
                The client does not know the id of the monster until it is created and sent back by the server, therefore
                POST /monsters/:id doesn’t make sense because a client couldn’t know the unique id of a monster before it
                exists.</li>
                <li><strong>app.put(): </strong>PUT requests are used for updating existing resources. 
                For this reason, it's needed to include a unique identifier 
                as a route parameter to determine which specific resource to update.</li> 
                <li><strong> app.delete(): </strong>Deletes currently existing data. Their paths should usually 
                end with a route parameter to indicate which resource to delete.</li>
                <li><strong>Query string: </strong>Is a part of a uniform resource locator (URL) that assigns values
                to specified parameters. Query strings appear at the end of the path in URLs, and they are indicated 
                with a <i>?</i> character. For instance, in <i>/monsters/1?name=chimera&age=1</i>, the query string is 
                <i>name=chimera&age=1</i> and the path is <i>/monsters/1/</i> Query strings do not count as part of the route path. I</li>    
                <ul>
                    <li><strong>req.query: </strong>This property is an object containing a property for each query string parameter 
                    in the route. When query parser is set to disabled, it is an empty object {}, otherwise it is the result of the 
                    configured query parser.</li>
                    <li><strong>req.param</strong> vs <strong>req.query</strong>: Both are closely related but they are not the same at all, params are parameters set for the route, query are 
                    values resembling variable assignment that provide extra information on what is being required for the route and
                    it will always start with a ? on the URL, inherently they are both string values that express extrapolates into
                    objects and key/value pairs from the req object.</li>
                    <ul>
                        <li><strong>req.param:</strong> <i>/lor/creatures/:name</i> if we were to make a request <i>/lor/creatures/gollum</i> gollum is the 
                        name parameter and so we could find it in the object as: req.params.name which equals to gollum.</li>
                        <li><strong>req.query:</strong> <i>/lor/creatures/hobbit?familyname=Baggins&home=Shire</i> we get two query parameters, familyname 
                        and home, this way we can get each as <i>req.query.familyname</i> which is Baggins and <i>req.query.home</i> which is Shire.</li>
                    </ul>
                </ul>
                <li><strong>app.use(express.static('public')):</strong> This is used to make sure that once the 
                server is started, you can reload the browser and render on it.
                The static method of express allows us to serve all the static files of our application, that is to say,
                all HTML, CSS, and JS files that will comprise the front end visuals on the browser. In our case:
                express.static('public');
                Public is the name of the directory where we find those files, for example, in our execise 37:</li>
                <li><strong>Status Codes: </strong> Response codes provide information to clients about how their 
                requests were handled. Any res.send() has by default sent a 200 OK status code.
                The res object has a <i>.status()</i> method to allow us to set the status code,
                and other methods like .send() can be chained from it.</li>
                <li><strong>Glossary of status code </strong><a href="https://www.webfx.com/web-development/glossary/http-status-codes/" target="_blank">here</a>.</li>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode34" onclick="showCode('displayCode34', 'showCode34')">Display</button>
                <div id="displayCode34">
                    <button onclick="closeCode('displayCode34', 'showCode34')">Close</button>
                    <li>In a real setting API server, <u>the data doesn't exist in arrays and objects within the file</u> as 
                    the examples underneath.
                    The reason is that it will not be <strong>persisting data</strong>, since if we keep it as an object, or an array of values 
                    or even an array of objects in the file, every time we were to stop the server, all changes will disappear since 
                    the file will only have whatever we wrote in it but not any further changes introduced.
                    That is why in real APIs we also implement storage technologies like <strong>SQL</strong> or <strong>NoSQL</strong> databases, 
                    <strong>yaml files</strong>, and <strong>cloud storage</strong> 
                    services for which we need to learn and implement other libraries or their documentation on how we communicate with them 
                    within our express server.</li>
                    <hr/>
                    <li><strong>Importing</strong> Express.js, <strong>app.listen()</strong>,
                    <strong>app.get()</strong>, <strong>send()</strong>,
                    <strong>app.put()</strong>, <strong>app.post()</strong>, <strong>app.delete()</strong> 
                    & <strong>app.use()</strong>.</li>
                    <pre>
                        <code>
            //Importing express.js
            const express = require('express');
            const app = express();

            // Use static server to serve the Express Yourself Website
                so to reload and render on the browser
            app.use(express.static('public'));

            const { getElementById, getIndexById, updateElement,
            seedElements, createElement } = require('./utils');

            const PORT = process.env.PORT || 4001;

            // Variables that stores data, that'll be 
                requested, created, updated and deleted
            const expressions = [];
            seedElements(expressions, 'expressions');
            const animals = [];
            seedElements(animals, 'animals');

            // Get all expressions
            app.get('/expressions', (req, res, next) => {
                res.send(expressions);
            });

            // Get a single expression (based on ID)
            app.get('/expressions/:id', (req, res, next) => {
                const foundExpression = getElementById(req.params.id, expressions);
                if (foundExpression) {
                    res.send(foundExpression);
                } else {
                    res.status(404).send();
                }
            });

            // Update an expression (based on ID)
            app.put('/expressions/:id', (req, res, next) => {
                const expressionIndex = getIndexById(req.params.id, expressions);
                //getIndexById will return -1 if the expressions array 
                    doesn’t contain an element with that id.
                //updateElement will throw an error if you pass in
                    an id that doesn’t exist in the array
                if (expressionIndex !== -1) {
                    updateElement(req.params.id, req.query, expressions);
                    res.send(expressions[expressionIndex]);
                } else {
                    res.status(404).send();
                }
            });

            // Create an expression
            app.post('/expressions', (req, res, next) => {
                const receivedExpression = createElement('expressions', req.query);
                if (receivedExpression) {
                    expressions.push(receivedExpression);
                    res.status(201).send(receivedExpression);
                } else {
                    res.status(400).send();
                }
            });

            // Delete an expression (based on ID)
            app.delete('/expressions/:id', (req, res, next) => {
                const expressionIndex = getIndexById(req.params.id, expressions);
                //getIndexById will return -1 for a non-existent ID,
                and the proper index if it exists. 
                Then you can use the splice method to remove the element.
                if (expressionIndex !== -1) {
                    expressions.splice(expressionIndex, 1);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            });

            // Get all animals
            app.get('/animals', (req, res, next) => {
                res.send(animals);
            });

            // Get a single animal
            app.get('/animals/:id', (req, res, next) => {
                const animal = getElementById(req.params.id, animals);
                if (animal) {
                    res.send(animal);
                } else {
                    res.status(404).send();
                }
            });

            // Create an animal
            app.post('/animals', (req, res, next) => {
                const receivedAnimal = createElement('animals', req.query);
                if (receivedAnimal) {
                    animals.push(receivedAnimal);
                    res.status(201).send(receivedAnimal);
                } else {
                    res.status(400).send();
                }
            });

            // Update an animal
            app.put('/animals/:id', (req, res, next) => {
                const animalIndex = getIndexById(req.params.id, animals);
                if (animalIndex !== -1) {
                    updateElement(req.params.id, req.query, animals);
                    res.send(animals[animalIndex]);
                } else {
                    res.status(404).send();
                }
            });

            // Delete a single animal
            app.delete('/animals/:id', (req, res, next) => {
                const animalIndex = getIndexById(req.params.id, animals);
                if (animalIndex !== -1) {
                    animals.splice(animalIndex, 1);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on ${PORT}`);
            });
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>app.put</strong> & <strong>req.params</strong>, <strong>req.query</strong>.</li>
                    <pre>
                        <code>
            const express = require('express');
            const app = express();

            const PORT = process.env.PORT || 4001;

            const currencies = {
                diram: {
                    countries: ['UAE', 'Morocco'],
                },
                real: {
                    countries: ['Brazil'],
                },
                dinar: {
                    countries: ['Algeria', 'Bahrain', 'Jordan', 'Kuwait'],
                },
                vatu: {
                    countries: ['Vanuatu'],
                },
                shilling: {
                    countries: ['Tanzania', 'Uganda', 'Somalia', 'Kenya'],
                },
            };

            app.put('/currencies/:name/countries', (req, res, next) => {
                const currencyName = req.params.name; //param ":name" from PUT request
                const countries = req.query; //value property from the key: value
                currencies[currencyName] = countries;  //query: value assign to parameter

                if(currencies[currencyName]){
                    res.send(currencies[currencyName]);
                } else {
                res.status(404).send();
                }
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });

                        </code>
                    </pre>
                    <li><strong>app.post</strong> & <strong>req.query</strong>.</li>
                    <pre>
                        <code>
            const express = require('express');
            const app = express();

            const PORT = process.env.PORT || 4001;

            const soups = ['gazpacho', 'borscht', 'primordial', 'avgolemono', 'laksa'];

            app.post('/soups', (req, res, next) => {
                const soup = req.query.name;
                soups.push(soup);
                res.status(201).send(soup);
            })

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });

                        </code>
                    </pre>
                    <li><strong>app.delete</strong> & <strong>req.params</strong></li>
                    <hr/>
            const express = require('express');
            const app = express();

            const PORT = process.env.PORT || 4001;

            const puddingFlavors = ['chocolate', 'banana', 'butterscotch', 'pistachio'];

            const findPuddingIndex = (name) => {
                return puddingFlavors.indexOf(name);
            }

            const deletePuddingAtIndex = (index) => {
                puddingFlavors.splice(index, 1);
            }

            app.delete('/puddings/:flavor', (req, res, next) => {
                const index = findPuddingIndex(req.params.flavor);
                if(index !== -1){
                    deletePuddingAtIndex(index);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            })

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });
                    <hr/>
                    <li><strong>Route Parameters</strong>:</li>
                    <ul>
                        <pre>
                            <code>
                const monsters = { 
                    hydra: { height: 3, age: 4 }, 
                    dragon: { height: 200, age: 350 } 
                };

                // GET /monsters/hydra
                app.get('/monsters/:name', (req, res, next) => {
                    console.log(req.params); // { name: 'hydra' }
                    res.send(monsters[req.params.name]);
                });
                            </code>
                        </pre>
                        <li>Another example:</li>
                        <pre>
                            <code>
            const express = require('express');
            const app = express();

            app.use(express.static('public'));

            const { getElementById, seedElements } = require('./utils');

            const expressions = [];
            seedElements(expressions, 'expressions');

            const PORT = process.env.PORT || 4001;

            app.get('/expressions', (req, res, next) => {
                res.send(expressions);
            });

            app.get('/expressions/:id', (req, res, next) => {
                const foundExpression = getElementById(req.params.id, expressions);
                res.send(foundExpression);
            });

            app.listen(PORT, () => {
                console.log(`Listening on port ${PORT}`);
            });
                            </code>
                        </pre>
                    </ul>    
                    <hr/>
                    <li><strong>Status Code:</strong></li>
                    <pre>
                        <code>
            const monsterStoreInventory = { fenrirs: 4, 
                                            banshees: 1, 
                                            jerseyDevils: 4, 
                                            krakens: 3 };
            
            app.get('/monsters-inventory/:name', (req, res, next) => {
                const monsterInventory = monsterStoreInventory[req.params.name];
                if (monsterInventory) {
                    res.send(monsterInventory);
                } else {
                    res.status(404).send('Monster not found');
                }
            });
                        </code>
                    </pre>
                </div>
            </ul>
                <hr/>
            <h3>Express.Router</h3>
                <ul>
                    <li>Routers are mini versions of Express applications — they provide functionality for handling 
                    route matching, requests, and sending responses.
                    Generally, we will keep each router in its own file, and require them in the main application. 
                    (because of reusability, scalability and cleaness). 
                    For example, having a router file that specifies all routes and depending on the main route, 
                    it will use the respective file that handles the request to that route.
                    We can use it with <strong>express.Router()</strong>.</li>
                    <li>Is very common having a <i>router.js</i> file that handles all the route connections.</li>
                    <li>Routers nested within nested routers <a href='https://discuss.codecademy.com/t/why-would-we-nest-routers-in-nested-routers/394943' target="_blank">here</a>.</li>
                    <li>To use a router, we mount it at a certain path using <strong>app.use()</strong> and pass in the router as the
                    second argument. This router will now be used for all paths that begin with that path segment.</li>
                    <li><strong>Documentation</strong> on Routing <a href="https://expressjs.com/en/guide/routing.html" target="_blank">here</a>.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode35" onclick="showCode('displayCode35', 'showCode35')">Display</button>
                <div id="displayCode35">
                    <button onclick="closeCode('displayCode35', 'showCode35')">Close</button>
                    <ul>
                        <li><strong>Express.Router</strong></li>
                        <ul>
                            <li>The code below contains all the monsters specific code. In a more full-fledged API, this file
                            would contain multiple routes. To use this router in another file, we use <strong>module.exports</strong>
                            so that other files can access monstersRouter. The only other new line of code required is
                            that Express must be required in each file, since we’ll need to create a router with 
                            <i>express.Router()</i>.</li>
                        </ul>
                        <pre>
                            <code>
                // monsters.js
                const express = require('express');
                const monstersRouter = express.Router();
                    
                const monsters = {
                    '1': {
                        name: 'godzilla',
                        age: 250000000
                    },
                    '2': {
                        Name: 'manticore',
                        age: 21
                    }
                }
                    
                monstersRouter.get('/:id', (req, res, next) => {
                    const monster = monsters[req.params.id];
                    if (monster) {
                        res.send(monster);
                    } else {
                        res.status(404).send();
                    }
                });
                    
                module.exports = monstersRouter;
                            </code>
                        </pre>
                        <li>Our <i>main.js</i> file could then be refactored to import the monstersRouter:</li>
                        <pre>
                            <code>
                            // main.js
                            const express = require('express');
                            const app = express();
                            const monstersRouter = require('./monsters.js');
                             
                            app.use('/monsters', monstersRouter);
                            </code>
                        </pre>
                    </ul>
                </div>
                <hr/>
                <h3>Middleware</h3>
                <ul>
                    <li><strong>DRY</strong>ing Routes With app.use().
                    A path can be written as optional, to write middleware that will run for every request at a specific 
                    path. It can also be even an array of routes to reference more than one path.</li>
                    <li><strong>Middleware</strong> is code that executes between a server receiving a request and
                    sending a response. It operates on the boundary, so to speak, between those two HTTP actions.
                    Middleware is a function that can perform logic on the request and response objects, such
                    as: inspecting a request, performing some logic based on the request, attaching information to the 
                    response, attaching a status to the response, sending the response back to the user, or simply passing
                    the request and response to another middleware. Middleware can do any combination of those things or
                    anything else a Javascript function can do.</li>
                    <li><strong>Middleware stack: </strong> Is a chain of middleware. Most of Express's functionality is 
                    chaining middleware. <u>Express routes are middleware</u>. Every route created in Express is also a 
                    middleware function handling the request and response objects at that part of the stack.</li>
                    <ul>
                        <li>The routes are called in the order that they appear in the file, provided the previous route
                        called <strong>next()</strong> and thus passed control to the next middleware.</li>
                        <li>An Express middleware is a function with three parameters: <i>(req, res, next)</i>.
                        The third argument to a middleware function, <i>next</i>, should get explicitly called as the last 
                        part of the middleware’s body. This will hand off the processing of the request and the construction
                        of the response to the next middleware in the stack.</li>
                        <li><u>We don’t always want to pass control to the <i>next</i> middleware in the stack.</u>
                        For example, when designing a system with confidential information, we want to be able to selectively 
                        show that information to authorized users. In order to do that, we would create middleware that tests 
                        a user’s permissions. If the user has the permission necessary, we would continue through the middleware 
                        stack by calling <i>next()</i>. If it fails, we would want to let the user know that they’re not allowed to see 
                        the information they’re trying to access.</li>
                    </ul>
                    <li>Since middleware is just a function with a specific signature, namely <i>(req, res, next)</i>, 
                    we can define functions and using them as middleware.
                    We can remove the <i>app.use()</i> line and replace it with a specific route method, or sprinkle it throughout
                    the application without it being universal.
                    With modular pieces like this, it is useful to know that methods such as <i>app.use()</i>, <i>app.get()</i>, 
                    <i>app.post()</i>, and so on all can take multiple callbacks as additional parameters.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode36" onclick="showCode('displayCode36', 'showCode36')">Display</button>
                <div id="displayCode36">
                    <button onclick="closeCode('displayCode36', 'showCode36')">Close</button>
                    <ul>
                        <li><strong>app.use()</strong> & <strong>next()</strong></li>
                        <pre>
                            <code>
            //A path can be written as optional 
                so to write middleware that will run
                for every request at a specific path.
                It can be even an array of routes
                to reference more than one path.
            app.use([path, anotherPath](req, res, next) => {
                console.log("A sorcerer approaches!");
                next();
            });
                
            app.get('/magic/:spellname', (req, res, next) => {
                console.log("The sorcerer is casting a spell!");
                next();
            });
                
            app.get('/magic/:spellname', (req, res, next) => {
                console.log(`The sorcerer has cast ${req.params.spellname}`);
                res.status(200).send();
            });
                
            app.get('/magic/:spellname', (req, res, next) => {
                console.log("The sorcerer is leaving!");
            });
                
            // Accessing http://localhost:4001/magic/fireball 
            // Console Output:
            // "A sorcerer approaches!"
            // "The sorcerer is casting a spell!"
            // "The sorcerer has cast fireball"
                                </code>
                            </pre>
                            <hr/>
                            <li>Other example:</li>
                            <pre>
                                <code>
            const express = require('express');
            const app = express();

            app.use(express.static('public'));

            const PORT = process.env.PORT || 4001;

            const jellybeanBag = {
                mystery: {
                    number: 4
                },
                lemon: {
                    number: 5
                },
                rootBeer: {
                    number: 25
                },
                cherry: {
                    number: 3
                },
                licorice: {
                    number: 1
                }
            };

            // Logging Middleware 
                (this below could be changed for Morgan)
            app.use((req, res, next) => {
                console.log(`${req.method} Request Received`);
                next('Bag with that name does not exist');
            });

            app.use('/beans/:beanName', (req, res, next) => {
                const beanName = req.params.beanName;
                if (!jellybeanBag[beanName]) {
                    res.status(404).send('Bag with that name does not exist');
                    return console.log('Response Sent');
                }
                req.bean = jellybeanBag[beanName];
                req.beanName = beanName;
                next();
            });

            app.get('/beans/', (req, res, next) => {
                res.send(jellybeanBag);
                console.log('Response Sent');
            });

            app.post('/beans/', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
            });

            // This below could be changed for bodyParser.
            req.on('end', () => {
                const body = JSON.parse(bodyData);
                const beanName = body.name;
                if (jellybeanBag[beanName] || jellybeanBag[beanName] === 0) {
                    return res.status(404).send('Bag with that name already exists!');
                }
                const numberOfBeans = Number(body.number) || 0;
                jellybeanBag[beanName] = {
                    number: numberOfBeans
                };
                res.send(jellybeanBag[beanName]);
                console.log('Response Sent');
                });
            });

            app.get('/beans/:beanName', (req, res, next) => {
                res.send(req.bean);
                console.log('Response Sent');
            });

            app.post('/beans/:beanName/add', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
            });

            req.on('end', () => {
                const numberOfBeans = Number(JSON.parse(bodyData).number) || 0;
                req.bean.number += numberOfBeans;
                res.send(req.bean);
                console.log('Response Sent');
                });
            });

            app.post('/beans/:beanName/remove', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
            });

            req.on('end', () => {
                const numberOfBeans = Number(JSON.parse(bodyData).number) || 0;
                if (req.bean.number < numberOfBeans) {
                    return res.status(400).send('Not enough beans in the jar to remove!');
                }
                req.bean.number -= numberOfBeans;
                res.send(req.bean);
                console.log('Response Sent');
                });
            });

            app.delete('/beans/:beanName', (req, res, next) => {
                jellybeanBag[req.beanName] = null;
                res.status(204).send();
                console.log('Response Sent');
            });

            app.put('/beans/:beanName/name', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
                });

                req.on('end', () => {
                    const newName = JSON.parse(bodyData).name;
                    jellybeanBag[newName] = req.bean;
                    jellybeanBag[req.beanName] = null;
                    res.send(jellybeanBag[newName]);
                    console.log('Response Sent');
                });
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });
                                </code>
                            </pre>
                            <li>In the below code sample, we created reusable middleware for authentication and data validation. 
                            We use the authenticate() middleware to verify a user is logged in before proceeding with the request
                            and we use the validateData() middleware before performing the appropriate create or update function.
                            Additional middleware can be placed at any point in this chain.</li>
                            <pre>
                                <code>
            const authenticate = (req, res, next) => {
            ...
            };
            
            const validateData = (req, res, next) => {
            ...
            };
            
            const getSpell = (req, res, next) => {
                res.status(200).send(getSpellById(req.params.id));
            };
            
            const createSpell = (req, res, next) => {
                createSpellFromRequest(req);
                res.status(201).send();
            };
            
            const updateSpell = (req, res, next) => {
                updateSpellFromRequest(req);
                res.status(204).send();
            }
            
            app.get('/spells/:id', authenticate, getSpell);
            
            app.post('/spells', authenticate, validateData, createSpell);
            
            app.put('/spells/:id', authenticate, validateData, updateSpell);
                                </code>
                            </pre>
                        </ul>
                    </div>
                <h3>Open-Source Middleware</h3>
                <ul>
                    <li>If we needed to write a web server from scratch every time we wanted to build a web application, 
                    we’d waste a lot of time solving problems that have been solved countless times before and ignoring
                    perfectly good pre-existing solutions. Luckily for us web developers, Express already exists as an
                    <strong>open-source package</strong> that we can install and use to build upon. There is a huge ecosystem of Javascript
                    packages that will solve so many of the problems that developers frequently run into.</li>
                    <li><strong>Morgan: </strong>Is an open-source library for logging (console.log) information about the HTTP request-response
                    cycle in a server application. <i>morgan()</i> is a function that will return a middleware function 
                    that will have the function signature <i>(req, res, next)</i> that can be inserted into an <i>app.use()</i>,
                    and that function will be called before all following middleware functions. Morgan takes an argument 
                    to describe the formatting of the logging output. For example, <i>morgan('tiny')</i> will return a middleware 
                    function that does a “tiny” amount of logging. With morgan in place, we’ll be able to remove the existing logging code.</li>
                    <ul>
                        <li>Morgan's <strong>documentation</strong> <a href="https://github.com/expressjs/morgan" target="_blank">here</a>.</li>
                    </ul>
                    <li><strong>Body-parser: </strong>Simplifies a perform request body parsing. That substituted a lot
                    of the req.on code from the previous examples.</li>
                    <ul>
                        <li>Body-parser <strong>documentation</strong> <a href="https://github.com/expressjs/body-parser#body-parser" target="_blank">here</a>.</li>
                    </ul>
                    <li><strong>List of middlewares</strong> <a href="https://expressjs.com/en/resources/middleware.html" target="_blank">here</a>.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode37" onclick="showCode('displayCode37', 'showCode37')">Display</button>
                <div id="displayCode37">
                    <button onclick="closeCode('displayCode37', 'showCode37')">Close</button>
                    <ul>
                        <li><strong>Morgan</strong></li>
                        <pre>
                            <code>
            const express = require('express');
            const morgan = require('morgan');
            const app = express();

            //This will console.log 
                (`${req.method} Request Received`) 
                to every router.
            app.use(morgan('tiny'));

            //This will console .log 
                :method :url :status :response-time ms - :res[content-length]
                to every router.
            app.use(morgan('dev')); 
                            </code>
                        </pre>
                        <li><strong>Body-Parser</strong></li>
                        <pre>
                            <code>
            const bodyParser = require('body-parser');

            app.use(bodyParser.json());
                            </code>
                        </pre>
                        <li>Full code example: <strong>Morgan</strong> & <strong>body-parser</strong></li>
                        <pre>
                            <code>
            const express = require('express');
            const app = express();
            const morgan = require('morgan');
            const bodyParser = require('body-parser');

            app.use(express.static('public'));

            const PORT = process.env.PORT || 4001;

            const cards = [
                {
                    id: 1,
                    suit: 'Clubs',
                    rank: '2'
                },
                {
                    id: 2,
                    suit: 'Diamonds',
                    rank: 'Jack'
                },
                {
                    id: 3,
                    suit: 'Hearts',
                    rank: '10'
                }
            ];
            let nextId = 4;

            // Logging
            if (!process.env.IS_TEST_ENV) {
                app.use(morgan('short'));
            }

            // Parsing
            app.use(bodyParser.json());

            // Find card
            app.use('/cards/:cardId', (req, res, next) => {
                const cardId = Number(req.params.cardId);
                const cardIndex = cards.findIndex(card => card.id === cardId);
                if (cardIndex === -1) {
                    return res.status(404).send('Card not found');
                }
                req.cardIndex = cardIndex;
                next();
            });

            const validateCard = (req, res, next) => {
            const newCard = req.body;
            const validSuits = ['Clubs', 'Diamonds', 'Hearts', 'Spades'];
            const validRanks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace'];
            if (validSuits.indexOf(newCard.suit) === -1 || validRanks.indexOf(newCard.rank) === -1) {
                return res.status(400).send('Invalid card!');
            }
                next();
            };

            // Get all Cards
            app.get('/cards/', (req, res, next) => {
                res.send(cards);
            });

            // Create a new Card
            app.post('/cards/', validateCard, (req, res, next) => {
                const newCard = req.body;
                newCard.id = nextId++;
                cards.push(newCard);
                res.status(201).send(newCard);
            });

            // Get a single Card
            app.get('/cards/:cardId', (req, res, next) => {
                res.send(cards[req.cardIndex]);
            });

            // Update a Card
            app.put('/cards/:cardId', validateCard, (req, res, next) => {
                const newCard = req.body;
                const cardId = Number(req.params.cardId);
                if (!newCard.id || newCard.id !== cardId) {
                    newCard.id = cardId;
                }
                cards[req.cardIndex] = newCard;
                res.send(newCard);
            });

            // Delete a Card
            app.delete('/cards/:cardId', (req, res, next) => {
                cards.splice(req.cardIndex, 1);
                res.status(204).send();
            });

            // Start the server
            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });
                            </code>
                        </pre>
                    </ul>
                </div>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Postman</h2>
            <ul>
                <li>Postman is a GUI that aids in the development of APIs by 
                making it easy to test requests and their responses in an organized way.</li>
                <li>API requests with <strong>Postman</strong>(GUI) & <strong>cURL</strong>(Command Line)
                <a href="https://www.taniarascia.com/making-api-requests-postman-curl/" target="_blank">here</a></li>
                <hr/>
                <h3>API Requests</h3>
                <li><strong>Initializing: </strong>
                Set the URL connected to the server & the HTTP method.</li>
                <li><strong>GET: </strong>
                Write proper URL to GET request.</li>
                <li><strong>POST: </strong> It is <u>non-idempotent</u>, meaning that two identical 
                POST requests will create two new resources.<br>
                Select <strong>POST</strong> method, Body => Raw (set to JSON), 
                write the Post request. As the output, an id will be created as a property
                inside "user". Example: </li>
                <pre><code>{"user": {"username": "Victor", "password": "Rego"}}</code></pre>
                <li><strong>PUT: </strong>It is <u>idempotent</u>, meaning that two identical PUT requests will modify the same
                resource.<br>
                A <strong>PUT</strong> request requires the entire body to be sent through; if any data 
                is missing, that data will be wiped (except automatic values like auto-incrementing 
                IDs and timestamps).</li>
                <li><strong>PATCH: </strong>Updates an existing resource, and does not require
                sending the entire body with the request.</li>
                <li><strong>DELETE: </strong>Removes a resource. No values to send.</li>
                <li><strong>Authentication: </strong>
                In Postman, you'll go to Headers and add Authorization as the key and Bearer < JWT_TOKEN > as
                the value to send authentication values. You can also go to Headers, click Presets, Manage
                Presets, and put your own reusable variables in for any headers or values you'll be reusing a lot.</li>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>CORS</h2>
            <ul>
                <li><strong>Cross-origin resource sharing (CORS)</strong> is a standard mechanism that allows JavaScript XMLHttpRequest 
                (XHR) calls executed in a web page to interact with resources from non-origin domains (different domains that are outside
                current). The CORS standard is needed because it allows servers to specify not only who can access the 
                assets, but also how they can be accessed.</li>
                <li>Servers will allow GET requests, meaning they will allow resources from external origins (say, a web page) 
                to read their assets. HTTP requests methods like PATCH, PUT, or DELETE, however, may be denied to prevent
                malicious behavior. For many servers, this is intentional. For example, it is likely that server A does not
                want servers B, C, or D to edit or delete its assets.
                <u>With CORS, a server can specify who can access its assets and which HTTP request methods are allowed 
                from external resources - like building with a security entrance. For example, if you need to borrow a 
                ladder, you could ask a neighbor in the building who has one. The building’s security would likely not 
                have a problem with this request (i.e., same-origin). If you needed a particular tool, however, and 
                you ordered it from an outside source like an online marketplace (i.e., cross-origin), the security 
                at the entrance may request that the delivery person provide identification when your tool arrives.</u></li>
                
                <li>An <strong>HTTP header</strong> is a piece of information associated with a request or a response.
                Headers are passed back and forth between your web browser (also referred to as a client) and a server when
                the web page you are on wants to use resources hosted on a different server. Headers are used to describe requests
                and responses. The CORS standard manages cross-origin requests by adding new HTTP headers to the standard list of headers. </li>
                <ul>
                    <li><strong>Access-Control-Allow-Origin:</strong> This header allows servers to specify how their resources are shared with external domains. 
                    When a GET request is made to access a resource on Server A, Server A will respond with a value for the Access-Control-Allow-Origin
                    header. Many times, this value will be *, meaning that Server A will share the requested resources with any domain on the 
                    Internet. Other times, the value of this header may be set to a particular domain (or list of domains), meaning that 
                    Server A will share its resources with that specific domain (or list of domains). The Access-Control-Allow-Origin 
                    header is critical to resource security.</li>
                    <li>List of <strong>Headers</strong><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#cors" target="_blank">here</a>.</li>
                </ul>
                <li><strong>Pre-flight request: </strong>
                Most servers will allow GET requests but may block requests to modify resources on the server. 
                Servers don’t just blindly block such requests; they have a process in place that first checks and then communicates 
                to the client (your web browser) which requests are allowed. When a request is made using any of the following HTTP request 
                methods, a standard preflight request will be made before the original request PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.    
                Preflight requests use the OPTIONS header. The preflight request is sent before the original request, 
                hence the term “preflight.” The purpose of the preflight request is to determine whether or not the original request is safe (for example, a 
                DELETE request). The server will respond to the preflight request and indicate whether or not the original request is safe. If the server specifies 
                that the original request is safe, it will allow the original request. Otherwise, it will block the original request.</li>
                <hr/>
                <h3>How to implement CORS?</h3>
                <li><strong>Cross-origin request</strong>s are made using the <strong>standard HTTP request</strong> methods. Most servers will allow 
                GET requests, meaning they will allow resources from external origins (say, a web page) to read their 
                assets. HTTP requests methods like PATCH, PUT, or DELETE, however, may be denied to prevent malicious 
                behavior. For many servers, this is intentional. For example, it is likely that server A does not want 
                servers B, C, or D to edit or delete its assets.
                <strong>Headers</strong> are passed back and forth between your web browser (also referred to as a client) and a server 
                when the web page you are on wants to use resources hosted on a different server. Headers are used to 
                describe requests and responses. The CORS standard manages cross-origin requests by adding new HTTP 
                headers to the standard list of headers. A descriptive list of all HTTP headers added by 
                the CORS standard. 
                <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS" target="_blank">here</a>.</li>
                <li>Implementing the request headers to set up CORS correctly depends on the language and framework of 
                the backend.</li>
                <ul>
                    <li>If you are using Node, you can use setHeader(), <i>response.setHeader('Content-Type', 'text/html');</i>.</li>
                    <li>If you are using Express, you can use CORS middleware: <i>$ npm install cors</i></li>
                </ul>
                <pre>
                    <code>                   
                    var express = require('express');
                    var cors = require('cors');
                    var app = express();
                     
                    app.use(cors());
                     
                    app.get('/hello/:id', function (req, res, next) {
                      res.json({msg: 'Hello world, we are CORS-enabled!'});
                    });
                     
                    app.listen(80, function () {
                      console.log('CORS-enabled web server is listening on port 80');
                    });
                    </code>
                </pre>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>User Authentication and Authorization</h2>
            <ul>
                <li><strong>Authentication</strong> determines identity, <strong>authorization</strong> determines the privileges associated with an 
                identity, and <strong>encryption</strong> ensures that data can only be accessed by authorized parties.</li>
            </ul>
            <hr/>
            <h3>Authentication</h3>
            <ul>
                <li><strong>Authentication</strong> is the verification of who you are. For example, let’s say you’ve gone to a concert. At the front door, the 
                security guard asks to see your ticket and ID in order to verify that the name on your ID matches the name on your ticket. 
                Authentication relies on one or more factors to verify identity, and these factors come in three main types:</li>
                <ul>
                    <li><strong>Knowledge</strong> is something you know, like a username and password.</li> 
                    <li><strong>Possession</strong> is something you have, like a security card or mobile device.</li> 
                    <li><strong>Inherence</strong> is something you are, which generally refers to biometric data such as fingerprints.</li>
                </ul>
                <li><strong>Single-Factor Authentication: </strong>Relies on a single factor, such as a simple username/password combo,
                and is becoming increasingly insecure.</li>
                <li><strong>Multi-Factor Authentication: </strong>requires multiple factors, such as a username/password combo and a code 
                sent to a mobile device. This is distinct from Multi-Step authentication, which requires multiple types of authentication 
                within a single factor, such as a password and a PIN.</li>
            </ul>
            <hr/>
            <h3>Authorization</h3>
            <ul>
                <li><strong>Authorization</strong> is the verification of what you are allowed to do. 
                It is responsible for everything from preventing users from modifying each other’s accounts, to protecting back-end assets 
                from attackers, to granting limited access to external services.
                Good authorization will allow you to limit users and services to the privileges they require; just because a user is authorized 
                to manage one group doesn’t mean they should be able to manage all groups, for example.</li>
            </ul>
            <hr/>
            <h3>Encryption</h3>
            <li><strong>Encryption</strong> enforces authentication and authorization is encryption. 
            Encryption is the process of transforming data into a format that is unreadable unless 
            you have the correct key to decrypt it.</li>
        </div>
        <div class="styleGuide">
            <h2>Web Sessions & Security</h2>
            <h3>Sessions & Cookies & Localstorage</h3>
            <ul>
                <li><strong>Sessions & Cookies & Localstorage </strong>
                <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-user-authentication-authorization/modules/wdcp-22-session-authentication-in-express/cheatsheet" target="_blank">here.</a></li>
                <li><strong>Web sessions: </strong>HTTP(S) protocol on its own is stateless, meaning requests and 
                responses are just relaying information back and forth with no knowledge of a specific user.
                But web developers want to create engaging, personalized experiences for users. This means there needs to 
                be a system that associates the requests with a specific user and does so in a secure.
                Without it, every time you reloaded the window you would be logged out or lose your cart!
                A <strong>web session</strong> refers to a series of user interactions over a time frame. 
                <u>Session data is stored server-side and associated with a session ID.</u>
                Think of a session as short-term memory for a web application.</li>
                <li><strong>Sessions Cookies:</strong> A cookie is a text file that stores stateful client data 
                in a key-pair format. It is stored by the web browser, aka client-side.
                Cookies store credentials for authentication, so the user doesn't need to send them every time 
                a button is clicked.</li>
                <li><strong>Sessions localStorage and sessionStorage: </strong>
                Client-side browser storage introduced with HTML5 that stores data in a key-pair format. 
                It does not interact with the server and is only changeable through JavaScript, with simple syntax.</li>
                <li>Ideally, all sessions-based web applications should enforce <strong>HTTPS</strong> for all communication. This 
                prevents common web attacks that could give the attacker access to the session.
                Security headers allow you to customize your web application’s security policy! They are an important 
                line of defense against web attacks. You should research each header, different options for each, 
                and find out how they can improve security while maintaining usability.</li>
                <ul>
                    <li>List of Security Headers
                    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#security" target="_blank">here</a>.</li> 
                    <li>You can use <a href="https://securityheaders.com/" target="_blank">https://securityheaders.com/</a> 
                    to check which headers are active on your web address.</li>
                </ul>
                <hr/>
                <h3>Express Session</h3>
                <li>In order to implement sessions within an Express application, we can use the NPM module, express-session, 
                as a middleware. Once the session middleware is implemented, each user that navigates to our app will have a 
                unique session generated for them. This allows us to store their session data server-side under a session 
                identifier and easily retrieve it.</li>
                <li><strong>Express Configure:</strong></li>
                <ul>
                    <li><strong>secret:</strong> The secret property is a key used for signing and/or encrypting 
                    cookies in order to protect our session ID.
                    <li><strong>resave:</strong> Setting this option to true will force a session to be saved 
                    back to the session data store, even when no data was modified. Typically, this option should 
                    be false, but also depends on your session storage strategy.</li>
                    <li><strong>saveUninitialized</strong>: This property is a boolean value. If it’s set to true,
                    the server will store every new session, even if there are no changes to the session object. 
                    This might be useful if we want to keep track of recurring visits from the same browser, but 
                    overall, setting this property to false allows us to save memory space.</li>
                    <li>The resave & saveUninitialized determine how often the session object will be saved.</li>
                </ul>
                <li><strong>Storing Session Data:</strong>
                Sessions are typically stored in three different ways:</li>
                <ul>
                    <li>In <strong>memory</strong> (this is the default storage)</li>
                    <li>In a <strong>database</strong> like MongoDB or MySQL</li>
                    <li>A <strong>memory cache</strong> like Redis or Memcached.</li>
                    <li>Whenever a user makes a request from the same client with a valid session identifier, the server 
                    retrieves the valid session information. express-session provides an in-memory store called, <strong>MemoryStore()</strong>. If no other store 
                    is specified, then this is set as the default storage.</li>        
                </ul>
                <li><strong>Sessions and Authentication (Cookies):</strong>
                We should make use of client-side storage so that the user’s browser can automatically send over the 
                session identifier with each incoming HTTP request.
                We’ll tell the client browser to create a cookie that stores the session ID. We can also modify cookie attributes to add a bit of security.
                Cookies will have a few default properties set, but we can specify them using key-value pairs. </li>
                <ul>
                    <li><strong>maxAge</strong> property sets the number of milliseconds until the cookie expires.</li> 
                    <li><strong>secure attribute</strong> makes it only send to the server via HTTPS.</li> 
                    <li><strong>sameSite</strong> property setted to 
                    "none" allows a cross-site cookie through different browsers.</li>
                    <li><strong>Other cookie</strong> properties include: cookie.expires, cookie.httpOnly, cookie.sameSite</li>
                </ul>
                <li><strong>Sessions and Authentication (Logging In):</strong>
                With a session middleware configured, we can now make use of the session and combine it with an authentication process.
                <ul>
                    <li>We can do this by first looking up the user in our database and then verifying that the password is correct.</li>
                    <li>Once credentials are confirmed, we’ll add data to our session.</li>
                    <li>Once the user is logged in we’ll add a property, authenticated within our session object and assign it to 
                    true. We’ll also set user in the session data and assign it the username and password we received.</li>
                    <li>Once the user is logged in, their session is created and stored in memory. The properties authenticated and user will 
                    be accessible and changeable as session data.</li>
                </ul>
                <li><strong>Accessing Session Data: </strong>
                Data in a session is serialized as JSON when stored, so we’re able to store and access data in nested objects. Let’s say we had 
                saved the number of items in a user’s cart in the session data: <i>req.session.user.cartCount = 2;</i>
                We can then access it by referring to <i>req.session.user.cartCount</i> when we need to display the correct number of items. We can also update its value.
                One common use case of session data is to protect specific routes. In the example below, we check that the authorized 
                property exists within the session, and if it’s set to true before we move on to the next route handler.
                </li>
                <li><strong>Download project</strong> with <strong>Sessions Authentication</strong> & <strong>Sessions Access</strong> <a href="https://static-assets.codecademy.com/content/paths/web-security/sessions-in-express/sessions-auth-data.zip" target="_blank">here</a>.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode39" onclick="showCode('displayCode39', 'showCode39')">Display</button>
            <div id="displayCode39">
                <button onclick="closeCode('displayCode39', 'showCode39')">Close</button>
                <ul>
                    <li>We can <strong>install</strong> the package by running the following command:</li>        
                    <pre>
                        <code>
            npm install express-session
                        </code>
                    </pre>    
                    <li>From here, we import the session module and <strong>store it in a variable</strong>:</li>
                    <pre>
                        <code>
            const session = require("express-session")
                        </code>
                    </pre>
                    <li><strong>Configure express-session</strong> & <strong>Storing Session Data</strong></li>
                    <pre>
                        <code>
            //instantiate a new store
            const store = new session.MemoryStore();
            
            app.use(
                session({
                  secret: "f4z4gs$Gcg",
                  cookie: { maxAge: 1000 * 60 *60 * 24, secure: true, sameSite: "none" },
                  saveUninitialized: false,
                  resave: false,
                })
            );
                        </code>
                    </pre>  
                    <li><strong>Sessions Authentication</strong> & <strong>Sessions Access</strong></li>
                    <pre>
                        <code>
                //app.js

                const express = require("express");
                const app = express();
                const session = require("express-session");
                const store = new session.MemoryStore();
                const db = require("./db");
                const PORT = process.env.PORT || 4001;
                
                app.set("trust proxy", 1);
                app.use(express.json());
                app.use(express.urlencoded({ extended: false }));
                app.set("view engine", "ejs");
                app.use(express.static(__dirname + "/public"));
                
                app.use(
                    session({
                        secret: "f4z4gs$Gcg",
                        cookie: { maxAge: 300000000, secure: true, sameSite: "none" },
                        saveUninitialized: false,
                        resave: false,
                        store,
                    })
                );
                
                function ensureAuthentication(req, res, next) {
                    // Check for the authorized property within the session
                    if (req.session.authenticated) {
                        return next();
                    } else {
                        res.status(403).json({ msg: "You're not authorized to view this page" });
                    }
                }
                
                // Add your ensureAuthentication middleware below:
                app.get("/shop", ensureAuthentication, (req, res) => {
                    // Send the user object to the view page:
                    // res.render() takes in a view page as the 
                        first argument and an object whose properties 
                        define local variables for the view as the second argument.
                    res.render("shop", { user: req.session.user });
                });
                
                app.get("/login", (req, res) => {
                    res.render("login");
                });
                
                // POST request for logging in
                // Sessions and Authentication (Logging In)
                app.post("/login", (req, res) => {
                    const { username, password } = req.body;
                    db.users.findByUsername(username, (err, user) => {
                        if (!user) return res.status(403).json({ msg: "No user found!" });
                        if (user.password === password) {
                                req.session.authenticated = true;
                                req.session.user = {
                                username,
                                password,
                            };
                            res.redirect("/shop");
                        } else {
                            res.status(403).json({ msg: "Bad Credentials" });
                        }
                    });
                });
                
                app.listen(PORT, () => {
                    console.log(`Server is listening on port ${PORT}`);
                });
                            
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>JSON Web Tokens (JWTs)</h3>
            <ul>
                <li><strong>JSON Web Tokens</strong> are self-contained JSON objects that compactly and securely transmit information between 
                two parties. They are secure because they are digitally signed using a secret or a public/private key pair.</li>
                <li>JWTs are used for authorization: They’re often used for SSO.
                Information Exchange: If a server received a valid JWT, it knows the sender is who they say they are and the information hasn’t been tampered with.
                <ul>
                    <li>Why <strong>use JWTs?</strong> Parsing JSON is easier than some alternatives like XML or SAML.
                    JWTs are small, scale well, and are easier for mobile devices to process.</li>
                    <li>Why <strong>not use JWT</strong>?
                    A mix of a public and private key-pair adds security, but can also add complexity.
                    Sensitive information, like passwords or Social Security Numbers, should not be stored client-side, even if it is encoded.</li>
                </ul>
                <li>A JWT is made up of three components:</li>
                <ul>
                    <li><strong>JWT Header: </strong>A JWT header contains the type of the token we’re creating and the signing algorithm 
                    that will be used. <strong>Type:</strong> The type of this token will always be “JWT”. The Internet Assigned Numbers Authority, or IANA, coordinates internet 
                    protocol resources across the globe. The “JWT” type aligns with the media type “application/jwt“.
                    <strong>Algorithm:</strong> The signing, or hashing, algorithm used might vary. Some commonly used algorithms are HMAC-SHA256, 
                    represented by "HS256", RSA with SHA-256, represented by "RW256", and ECDSA with SHA-256, represented by "ES256".</li>
                    <li><strong>JWT Payload: </strong>A JWT payload contains claims about an entity. A claim is a statement or piece of 
                    information and the entity is often a user. There are three types of claims a JWT payload can contain:
                    <strong>Registered Claims:</strong> These are predefined claim types that anyone can use in a JWT.
                    <strong>Public Claims:</strong> These are custom claim types that are created by a developer and can be used 
                    publicly. They should be registered to avoid collisions, also known as repeated claims.
                    <strong>Private Claims:</strong> These are custom claim types that are not registered or public. They are only 
                    used between parties that have agreed to use them. List of registered claims and public claims 
                    <a href="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" target="_blank">here</a>.</li>
                    <li><strong>JWTSignature: </strong>Is used to verify that the JWT wasn’t tampered with or changed. 
                    It can be created taking the encoded header, the encoded payload, a secret, and using the hashing algorithm 
                    to create a hash from those elements.</li>
                </ul>
                <li><strong>Do not store your JWT in localStorage</strong> as an attacker could use Cross-Site Scripting 
                attacks to steal local data.
                <strong>Storing your JWT in a cookie could expose your data to a Cross-Site 
                Resource Forgery attack</strong>. Additionally, if a user has disabled cookies in their browser, 
                the application is now unable to store the JWT.</li>
                <li>JWT documentation <a href="https://jwt.io/" target="_blank">here</a>.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode40" onclick="showCode('displayCode40', 'showCode40')">Display</button>
            <div id="displayCode40">
                <button onclick="closeCode('displayCode40', 'showCode40')">Close</button>
                <ul>
                    <li>JWS <strong>Header</strong> specifying the <strong>HMAC-SHA256</strong> algorithm:</li>
                    <pre>
                        <code>
                {
                    'alg': 'HS256',  
                    'typ': 'JWT'
                }
                        </code>
                    </pre>
                    <li>JWS <strong>Payload</strong> using some common registered claims:</li>
                    <pre>
                        <code>
                
            {
                'sub': '1234567890',
                'name': 'Harine Cooper',
                'admin': false,
                'iat': 1620924478,
                'exp': 1620939187
            }
                        </code>
                    </pre>
                    <li>In this example, we will use <strong>jwt.io’s JWT debugger</strong> to create our <strong>final JWT</strong>.</li>
                    <ul>
                        <li>The secret is a symmetric key known by the sender and receiver of this token. </li>
                        <li>The <strong>Base64Url encoding of our header</strong> is: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</li>
                        <li>The <strong>Base64Url encoding of our payload</strong> is:<br/>
                        <i>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkhhcmluZSBDb29wZXIiLCJhZG1pbiI6ZmFsc2UsI<br/>mlhdCI6MTYyMDkyNDQ3OCwiZXhwIjoxNjIwOTM5MTg3fQ</i></li>
                        <li>Finally, we use the HMAC-SHA256 algorithm we defined in our header to create our signature:</li>
                        <pre>
                            <code>
                        HMACSHA256(
                            base64UrlEncode(header) + "." +
                            base64UrlEncode(payload),
                            secret)
                            </code>
                        </pre>
                        <li>Which gives us: <i>3B-FLgPETrExxlDKW30AoU7KGE6xuZodw79TQR8_mwM</i></li>
                        <li>Concatenating our encoded header, our encoded payload, and our signature, and separating each with a “.”, gives us our final token:
                        <i>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikhh<br/>cmluZSBDb29wZXIiLCJhZG1pbiI6ZmFsc2UsImlhdCI6MTYyMDkyNDQ3OCwiZXhwIjoxNjIwOTM5MTg3fQ.3B-FLgPETrExxlDKW30AoU7KGE6xuZodw79TQR8_mwM</i></li>
                    </ul>
                </ul>
            </div>
            <hr/>
            <h3>Protecting information (Encryption, Hashing, Encoding, Obfuscation)</h3>
            <ul>
                <li><strong>Encryption: </strong>
                    Encryption Cryptography is the science of hiding data and making it available again. In 
                    cryptography, hiding data is called encryption and unhiding it is called decryption. When data is
                    securely exchanged, it is first encrypted by the sender, and then decrypted by the receiver using 
                    a special key. There are two main types of encryption: symmetric and asymmetric.
                    Asymmetric encryption is the most secure way to transmit data; however, it is slower and more complex than
                    symmetric encryption. Therefore, it is primarily used to exchange smaller pieces of data.</li>
                    <ul>
                        <li><strong>Symmetric</strong> encryption uses the same key to both encrypt and decrypt data.</li>
                        <li><strong>Asymmetric</strong> encryption uses two different keys to encrypt and decrypt data.</li>
                    </ul>
                <li><strong>Hashing: </strong>
                Hashing does not encrypt data. Instead, hashing is a one-way process that takes a piece of data of any size 
                and uses a mathematical function to represent that data with a unique hash value of a fixed size. You cannot 
                compute the original data from its hash.
                Because each hash should be unique, hashing allows us to see if changes have been made to documents.
                <ul>
                    <li>Hashes are widely used in order to <strong>store passwords in online databases</strong>. If passwords are stored in plaintext 
                    and a database is breached, so are all of the passwords! However, if they are stored as hash values, even if 
                    someone hacks into a website’s database, only the password hashes are exposed.</li>
                    <li><strong>For example</strong>, let’s suppose a user’s password is: <i>CodecademyIsGr8t</i>
                    Now, if the website storing the password is using a SHA-256 hash, even if someone hacked into that website, 
                    all the hacker would see is the hash value:
                    <i>d04f855e71ad9d495d91e666175d593b669f45970f885a258f6dbbaab262ac8b</i>
                    Remember, an attacker has no way of decrypting a hash value to get the original value. Hashing is a one-way process.</li>
                </ul>
                <li><strong>Encoding: </strong>While it may sound similar to encryption, encoding is not actually used to hide 
                data. Encoding transforms data into a form that can be used by a different type of system. Some different types 
                of encoding are: <strong>ASCII, Unicode, Base64</strong>. Encoded information is easily reversed and only requires 
                knowledge of the algorithm used to decode information.</li>
                <li><strong>Obfuscation: </strong>Obfuscation is less about data security and more about securing code. Developers might 
                obfuscate their code in order to hide what their code is actually doing. Obfuscate means to hide the meaning of something 
                by making it difficult to understand.
                Developers might want to hide trade secrets or intellectual property from others who can access their code. 
                Obfuscating their code makes it difficult for others to steal code and use it for their own purposes. Obfuscation can also make 
                it harder for users to hack software or get around licensing requirements needed to use programs.
                Malicious actors might also use obfuscation to make it hard for users or antivirus software to detect a virus they are 
                planting on a system. If you don’t know what an application is for, be very careful before downloading or opening it.</li>
            </ul>
            <hr/>
            <h3>Passport.js</h3>
            <ul>
                <li>Passport.js is a flexible authentication middleware for Node.js that can be added to any Express-based 
                application. With Passport.js we can implement authentication using the concept of strategies.
                Passport strategies are separate modules created to work with different means of authentication. Passport is a very extensible 
                middleware, and it allows you to plug in over 300 different authentication providers like Facebook, Twitter, Google, and more.</li>
                <ul>
                    <li>Passport.js <strong>documentation</strong> <a href="http://www.passportjs.org/docs/" target="_blank">here</a>.</li>
                </ul>
                <li><strong>Serializing and Deserializing Users: </strong>
                If authentication succeeds, a session will be established and maintained via a cookie set in the user’s browser. 
                However, if a user logs in and refreshes the page, the user data won’t persist across HTTP requests. We can fix 
                this by <strong>serializing</strong> and <strong>deserializing</strong> users.
                Serializing a user determines which data of the user object should be stored in the session, usually the user id. 
                The <i>serializeUser()</i> function sets an id as the cookie in the user’s browser, and the <i>deserializeUser()</i> function 
                uses the id to look up the user in the database and retrieve the user object with data.</li>
                <li><strong>Logging In:</strong> In order to log in a user we need a POST request (with a logging end-point)
                that takes in user credentials & a GET request, to retrieve data. Steps on how to Implement within "Example".</li>
                <li><strong>Register:</strong> In order to register a user we need a POST request (with a register end-point).
                Steps on how to Implement within "Example".</li>
                <li><strong>Logging out: </strong>Passport.js exposes a logout function within the request object: <i>req.logout</i>.
                The function can be called from any route handler in order to terminate a login session. It essentially removes 
                the <i>req.user</i> property and clears the login session (if any). 
                By terminating the session, the user will have to re-authenticate in order to create a new session.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode41" onclick="showCode('displayCode41', 'showCode41')">Display</button>
            <div id="displayCode41">
                <button onclick="closeCode('displayCode41', 'showCode41')">Close</button>
                <ul>
                    <li><strong>Configuring Passport.js: </strong>
                    One of the great things about using Passport.js is that a lot of the heavy lifting is taken care of 
                    by the module. In order to use it, we need to configure it and implement cookies and sessions for 
                    persistent logins.</li>
                    <ul>
                        <li>To start using the traditional authentication module, we <strong>install the passport</strong> and the <strong>passport-local</strong> 
                        packages via the terminal: <i>npm install passport passport-local</i>
                        <li>Once imported, <strong>we require the passport and passport-local</strong> packages in our JavaScript file as below.
                        We’re importing the passport-local package with its Strategy instance to authenticate users with 
                        a username and password.</li>
                        <pre>
                            <code>
                const passport = require("passport");
                const LocalStrategy = require("passport-local").Strategy;
                            </code>
                        </pre>    
                        <li>Now that we have the package installed, we can <strong>initialize</strong> it by calling the initialize() method:
                        <i>app.use(passport.initialize());</i>
                        passport is a middleware and must be implemented using <i>app.use()</i>. The <i>initialize()</i> method initializes 
                        the authentication module across our app.</li>
                        <li>Next, we want to <strong>allow for persistent logins</strong>, and we can do this by calling <i>session()</i> on our passport 
                        module: <i>app.use(passport.session());</i>
                        The <i>session()</i> middleware alters the request object and is able to attach a ‘user’ value that can be 
                        retrieved from the session id.</li>
                    </ul>
                    <hr/>
                    <li><strong>Passport's Local Strategy</strong></li>
                    <ul>
                        <li>With Passport configured, we can now set up the passport-local strategy for authenticating with a username and password.
                        First, we can configure the local strategy by creating a new instance of it and passing it as middleware into passport:</li>
                        <pre>
                            <code>
                    passport.use(new LocalStrategy(
                        function(username, password, done) {
                        // …
                        }
                    ));
                            </code>
                        </pre>
                        <li>The new LocalStrategy object will take in an anonymous function with the following parameters:</li>
                        <ul>
                            <li>username</li>
                            <li>password</li>
                            <li>A callback function called done.</li>
                        </ul>
                        <li>The purpose of the done callback is to supply an authenticated user to Passport if a user is authenticated. 
                        The logic within the anonymous function follows this order:</li>
                        <ol>
                            <li>Verify login details in the callback function.</li>
                            <li>If login details are valid, the done callback function is invoked and the user is authenticated.</li>
                            <li>If the user is not authenticated, pass false into the callback function.</li>
                        </ol>
                        <li>The done callback function takes in two arguments:</li>
                        <ul>
                            <li>An error or null if no error is found.</li>
                            <li>A user or false if no user is found.</li>
                        </ul>
                        <li>With those steps implemented our updated strategy should look like:</li>
                        <pre>
                            <code>
                    passport.use(new LocalStrategy(
                        function (username, password, done) {
                            // Look up user in the db
                            db.users.findByUsername(username, (err, user) => {
                            // If there's an error in db lookup, 
                            // return err callback function
                            if(err) return done(err);
                        
                            // If user not found, 
                            // return null and false in callback
                            if(!user) return done(null, false);
                        
                            // If user found, but password not valid, 
                            // return err and false in callback
                            if(user.password != password) return done(null, false);
                        
                            // If user found and password valid, 
                            // return the user object in callback
                            return done(null, user)
                            });
                        })
                    );
                            </code>
                        </pre>
                        <li>We’re looking for potential errors during the authentication process and addressing them before the next request handler is reached.</li>
                        <li>Once the local strategy is configured, the Express application will have user authentication implemented!</li>
                    </ul>
                    <hr/>
                    <li><strong>Serializing</strong> and <strong>Deserializing Users</strong></li>
                    <ul>
                        <li>When we <strong>serialize a user</strong>, Passport takes that user id and stores it internally on <i>req.session.passport </i>
                        which is Passport’s internal mechanism to keep track of things.
                        In the code example below, we pass a user object and a callback function called done after successful authentication.</li>
                        <pre>
                            <code>
                    passport.serializeUser((user, done) => {
                        done(null, user.id);
                    });
                            </code>
                        </pre>
                        <li>The first argument in the <i>done()</i> function is an error object. In this case, since there was no error we pass null 
                        as the argument. For the second argument, we pass in the value that we want to store in our Passport’s internal session, 
                        the user id. Once configured, the user id will then be stored in Passport’s internal session:
                        <i>req.session.passport.user = {id: 'xyz'}</i>
                        For any subsequent request, the user object can be retrieved from the session via the <i>deserializeUser()</i> function. 
                        We can implement the deserializeUser function as follows:</li>
                        <pre>
                            <code>
                passport.deserializeUser((id, done) => {
                // Look up user id in database. 
                db.users.findById(id, function (err, user) {
                        if (err) return done(err); 
                        done(null, user);
                    });
                });
                            </code>
                        </pre>
                        <li>For the <strong>deserializeUser function</strong>, we pass the key that was used when we initially serialized a user (id). 
                        The id is used to look up the user in storage, and the fetched object is attached to the request object as 
                        req.user across our whole application.
                        This way we’re able to access the logged-in user’s data in req.user on every subsequent request!</li>
                    </ul>
                    <hr/>
                    <li><strong>Logging In</strong></li>
                    <ul>
                        <li>In order to log in a user we first need a POST request that takes in user credentials. 
                        We can add passport middleware in order to process the authentication and, if successful, serialize the user for us:</li>
                    <pre>
                        <code>
            app.post("/login",
                passport.authenticate("insertStrategyHere", 
                { failureRedirect : "/insertPathHere"}),
                (req, res) => {
                    res.redirect("profile");
                }
            );
                        </code>
                    </pre>
                    <li>We’re passing in <i>passport.authenticate()</i> as middleware. Using this middleware allows Passport.js 
                    to take care of the authentication process behind the scenes and creates a user session for us.
                    passport.authenticate() takes in:</li>
                    <ul>
                        <li>A string specifying which strategy to employ. In this case, we should use a local strategy.</li>
                        <li>An optional object as the second argument. In this case, we should set the failureRedirect key 
                            to "/login". This will redirect the user to the /login page if the login process fails.</li>
                    </ul>
                    <li>Once implemented, we can update the "/profile" endpoint to make use of the serialized user found in the request object, req.user:</li>
                    <pre>
                        <code>
            app.get("/profile", (req, res) => {
                res.render("insertDashboardNameHere", { user: req.user });
            }); 
                        </code>
                    </pre>
                    <li>This will render our profile view page along with the user data stored in the session!</li>
                    </ul>
                    <hr/>
                    <li><strong>User Registration</strong></li>
                    <ul>
                        <li>Let’s learn how to register a user without a database. In a real production environment, you should 
                        use a database, but we’ve simplified this example to focus on the creation of new users.                    
                        Instead of a database, we’ll use an array holding data:</li>
                        <pre>
                            <code>
                    // users:
                    let records = [
                        {
                            id: 1,
                            username: "sam",
                            password: "codec@demy10",
                        },
                        {
                            id: 2,
                            username: "jill",
                            password: "p@ssword123!",
                        },
                    ];
                            </code>
                        </pre>
                        <li>Using a custom helper function we can retrieve user data upon registration 
                        and update the records array:</li>
                        <pre>
                            <code>
                    function createUser(user) {
                        return new Promise((resolve, reject) => {
                        const newUser = {
                            // getNewId creates an updated ID 
                            // for the new user
                            id: getNewId(records),
                            ...user,
                        };
                        records = [newUser, ...records];
                        resolve(newUser);
                        });
                    };
                            </code>
                        </pre>
                        <li>In the <strong>createUser()</strong> function, we’re creating a Promise in order to prevent events from becoming blocked 
                        when running the application. <i>createUser()</i> creates a new user and inserts them into our database, records. Once created, we resolve the 
                        Promise and send back the newly created user. Let’s use the <i>createUser()</i> helper function in our routes. We’ll add the logic to create users in a POST 
                        request to </i>"/register"</i>.
                        Since we’re working with promises, we can create an asynchronous route handler by using <i></i>async/await</i>:</li>
                        <pre>
                            <code>
                        app.post("/register", async (req, res) => { ... })
                            </code>
                        </pre>
                        <li>We’ll retrieve the user data from <i></i>req.body</i> and await as we call our helper function to create the new user:</li>
                        <pre>
                            <code>
                        app.post("/register", async (req, res) => {
                            const { username, password } = req.body;
                            // imported helper function: 
                            // db.users.createUser
                            const newUser = await db.users.createUser({ username, password });
                            </code>
                        </pre>

                        <li>If a newUser is successfully created, we send a status code of 201 and a json response back to the client:</li>
                        <pre>
                            <code>
                app.post("/register", async (req, res) => {
                    const { username, password } = req.body;
                    const newUser = await db.users.createUser({ username, password });
                    if (newUser) {
                        res.status(201).json({
                        msg: "Insert Success Message Here",
                        insertDataHere
                    });
                }
                            </code>
                        </pre>
                        <li>Lastly, we want to handle potential errors that might occur. In an else statement we can 
                        return a status code of 500 indicating that there was a relevant error message:</li>
                        <pre>
                            <code>
                app.post("/register", async (req, res) => {
                    const { username, password } = req.body;
                    const newUser = await db.users.createUser({ username, password });
                    if (newUser) {
                        res.status(201).json({
                        msg: "Insert Success Message Here",
                        insertDataHere
                    });
                    } else {
                        res.status(500).json({ msg: "Insert Failure Message Here" });
                }
                            </code>
                        </pre>
                        <li>NOTE: In a real development environment, passwords would be hashed whenever a new user registers.</li>
                        <li>With the route completed, users will now be able to register and log in!</li>
                    </ul>
                    <hr/>
                    <li><strong>Logging out</strong></li>
                    <ul>
                        <pre>
                            <code>
                    app.get("/logout", (req, res) => {
                        req.logout();
                        res.redirect("/");
                    });
                            </code>
                        </pre>
                    </ul>
                    <hr/>
                    <li><strong>Passport Implementation: </strong></li>
                    <pre>
                        <code>    
                const express = require("express");
                const app = express();
                const session = require("express-session");
                const store = new session.MemoryStore();
                const db = require("./db");
                const passport = require("passport");
                const LocalStrategy = require("passport-local").Strategy;
                const PORT = process.env.PORT || 4001;
                
                app.use(express.json());
                app.use(express.urlencoded({ extended: false }));
                app.set("view engine", "ejs");
                app.use(express.static(__dirname + "/public"));
                
                app.use(
                  session({
                    secret: "f4z4gs$Gcg",
                    cookie: { maxAge: 300000000, secure: false },
                    saveUninitialized: false,
                    resave: false,
                    store,
                  })
                );
                
                app.use(passport.initialize());
                app.use(passport.session());
                
                //Serialize User
                passport.serializeUser((user, done) => {
                  done(null, user.id);
                });
                
                //Deserialize User
                passport.deserializeUser((id, done) => {
                  db.users.findById(id, function (err, user) {
                    if (err) {
                      return done(err);
                    }
                    done(null, user);
                  });
                });
                
                // Passport local strategy below:
                passport.use(
                    //cb is callback
                    new LocalStrategy(function (username, password, cb) {
                        db.users.findByUsername(username, function (err, user) {
                            // There was an error in the database lookup
                            if (err) {
                                return cb(err);
                            }
                            // A user was NOT found and there was NO error
                            if (!user) {
                                return cb(null, false);
                            }
                            // A user was found, but the password was NOT valid
                            if (user.password != password) {
                                return cb(null, false);
                            }
                            // There was no error, the user and password are valid
                            return cb(null, user);
                        });
                    })
                );
                
                // Logout handler below:
                app.get("/logout", (req, res) => {
                  req.logout();
                  res.redirect("/login");
                });
                
                app.get("/login", (req, res) => {
                  res.render("login");
                });
                
                //Logging
                app.post(
                  "/login",
                  passport.authenticate("local", { failureRedirect: "/login" }),
                  (req, res) => {
                    res.redirect("profile");
                  }
                );
                
                app.get("/profile", (req, res) => {
                  res.render("profile", { user: req.user });
                });
                
                //Register
                app.post("/register", async (req, res) => {
                  const { username, password } = req.body;
                  const newUser = await db.users.createUser({ username, password });
                  if (newUser) {
                    res.status(201).json({
                      msg: "New user created!",
                      newUser,
                    });
                  } else {
                    res.status(500).json({ msg: "Unable to create user" });
                  }
                });
                
                app.listen(PORT, () => {
                  console.log(`Server is listening on port ${PORT}`);
                });


                        </code>
                    </pre> 
                    <hr/>
                    <li><strong>Helper Function: </strong>
                    Using a custom helper function, 
                    we can retrieve user data upon registration and update the records array:</li>
                    <pre>
                        <code>
                let records = [
                    {
                        id: 1,
                        username: "sam",
                        password: "codec@demy10",
                    },
                    {
                        id: 2,
                        username: "jill",
                        password: "birthday",
                    },
                ];

                const getNewId = (array) => {
                    if (array.length > 0) {
                        return array[array.length - 1].id + 1;
                    } else {
                        return 1;
                    }
                };

                exports.createUser = function (user) {
                    return new Promise((resolve, reject) => {
                        const newUser = {
                            id: getNewId(records),
                            ...user,
                        };
                        records = [newUser, ...records];
                        console.log(records);
                        resolve(newUser);
                    });
                };

                exports.findById = function (id, cb) {
                    process.nextTick(function () {
                        var idx = id - 1;
                        if (records[idx]) {
                            cb(null, records[idx]);
                        } else {
                            cb(new Error("User " + id + " does not exist"));
                        }
                    });
                };

                exports.findByUsername = function (username, cb) {
                    process.nextTick(function () {
                        for (var i = 0, len = records.length; i < len; i++) {
                            var record = records[i];
                            if (record.username === username) {
                                return cb(null, record);
                            }
                        }
                        return cb(null, null);
                    });
                };
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>BCRYPT</h3>
            <ul>
                <li>When practicing new concepts, we might store plaintext passwords in a local database, but this is 
                incredibly insecure. <u>One should never do this in a production environment</u>. 
                You should <strong>hash passwords</strong> before storing them in a database in order to protect 
                your users from being hacked. There are plenty of cryptographic hashing functions to choose from, 
                such as the SHA-3 or MD-5 algorithms, but they are quite fast (the faster the function, the faster 
                a hacker can retrieve a hashed password). 
                Using a function that is slower at hashing passwords can actually protect your users.
                We can accomplish this by using the <strong>bcrypt</strong> algorithm and library. 
                Using bcrypt, we can protect our users by <strong>hashing and salting passwords</strong>.
                Using multiple rounds of hashing ensures that an attacker must deploy massive funds and 
                hardware to be able to crack your passwords.</li>
                <li><strong>bcrypt is hashing algorithm</strong>. This means you cannot easily retrieve 
                the plaintext password without already knowing the salt, rounds, and key (password).
                A hash function only works one-way, which means that once a value is hashed it can’t be unhashed
                (this helps to avoid exposing password if a server attack happens). 
                This is different from encryption, because, if you know which algorithm was used to encrypt a value, 
                you can use that same algorithm to decrypt it.</li>
                <li>On a typical website, when a user first signs up, we retrieve their password and run it through a 
                hashing algorithm. The hashed password is then stored in the database. Whenever the same user 
                logs in, we hash the password they tried to log in with and compare it to the already stored hash 
                value. If the values match, the user is authenticated.</li>
                <li>A <strong>salt</strong> is a random value that is added to the input of a hashing function in order to make each 
                password hash unique even in the instance of two users choosing the same passwords. Salts help 
                us mitigate hash table (like Rainbow Table) attacks by forcing attackers to re-compute them using the salts for each 
                user.</li>
                <li>The <strong>process of comparing</strong> passwords should look as follows:</li>
                <ol>
                    <li><strong>Retrieve</strong> plain text password.</li>
                    <li><strong>Hash</strong> the password.</li>
                    <li><strong>Compare</strong> the hashed password with the one stored in our DB. 
                    (Since we’re using the same hash, it should return the same value if the password is correct.)</li>
                </ol>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode42" onclick="showCode('displayCode42', 'showCode42')">Display</button>
            <div id="displayCode42">
                <button onclick="closeCode('displayCode42', 'showCode42')">Close</button>
                <ul>
                    <li>Bcrypt to<strong> Hash Passwords:</strong></li>
                    <ul>
                        <li>A <strong>salt</strong> is a value that is concatenated to a password before hashing in order to make it less 
                        vulnerable to rainbow table and brute-force attacks.</li>
                        <li>A <strong>salt round</strong> can be described as the amount of time needed to calculate a single bcrypt hash. 
                        The higher the salt rounds, the more time is necessary to crack a password.</li>
                        <li>The built-in <strong><i>genSalt()</i></strong> function automatically generates a salt for us. Since we’re using an 
                        asynchronous function we can await this function call.</li>
                    </ul>
                    <pre>
                        <code>
                const bcrypt = require("bcrypt");

                const passwordHash = async (password, saltRounds) => {
                    try {
                        const salt = await bcrypt.genSalt(saltRounds);
                        return await bcrypt.hash(password, salt);
                    } catch (err) {
                        console.log(err);
                    }
                    return null;
                };
                        </code>
                    </pre>
                    <li><strong>Verifying password:</strong></li>
                    <ul>
                        <li>The built-in function <strong><i>compare()</i></strong> 
                        takes in a plaintext password, password and a hashed password, hash.
                        <i>bcrypt.compare()</i> deduces the salt from the provided hash and is able to then 
                        hash the provided password correctly for comparison.</li>
                        <pre>
                            <code>
                const bcrypt = require("bcrypt");

                const comparePasswords = async (password, hash) => {
                    try {
                        const matchFound = await bcrypt.compare(password, hash);
                        return matchFound;
                    } catch(err) {
                        console.log(err);
                    }
                    return false;
                };
                            </code>
                        </pre>
                    </ul>
                    <hr/>
                    <li><strong>Implementation bcrypt:</strong></li>
                    <pre>
                        <code>
            const express = require("express");
            const router = express.Router();
            const helper = require("../helpers/helpers");
            let users = require("../data/users.json");
            const filename = "./data/users.json";
            const bcrypt = require("bcrypt");

            /* Register a user */
            router.post("/register", async (req, res) => {
                const { email, password } = req.body;
                const id = { id: helper.getNewId(users) };
                
                try {
                    const user = await helper.findUser(users, email);
                    if (user) {
                        console.log("User already exists!");
                        return res.redirect("login");
                    }
                    
                    // Generate salt
                    const salt = await bcrypt.genSalt(10);
                    
                    // Hash password
                    const hashedPassword = await bcrypt.hash(password, salt);
                    
                    const newUser = {
                    ...id,
                    email,
                    password: hashedPassword,
                    };

                    await users.push(newUser);
                    await helper.writeJSONFile(filename, users);

                    res.redirect("login");
                } catch (err) {
                    res.status(500).json({ message: err.message });
                }
            });

            /* Log in user */
            router.post("/login", async (req, res) => {
                const { password, email } = req.body;

                try {
                    const user = await helper.findUser(users, email);

                    if (!user) {
                    console.log("User does not exist!");
                    return res.redirect("login");
                    }

                    // Compare passwords
                    const matchedPassword = await bcrypt.compare(password, user.password);

                    if (!matchedPassword) {
                        console.log("Passwords did not match!");
                        return res.redirect("login");
                    }
                    // return res.status(401).json({
                    //   token: null,
                    //   message: "Invalid password",
                    // });
                    res.render("profile", { user });
                } catch (err) {
                    res.status(500).json({ message: err.message });
                }
            });

            router.get("/login", (req, res) => {
                res.render("login");
            });

            router.get("/register", (req, res) => {
                res.render("register");
            });

            router.get("/profile", (req, res) => {
                res.render("profile");
            });

            module.exports = router;
                        </code>
                    </pre>
                    <li>Previous example <i>user.json</i></li>
                    <pre>
                        <code>
            [
                {
                    "id":1,
                    "email":"lucinda90@codecademy.com",
                    "password":"$2b$10$3euPcmQFCiblsZeEu5s7p.9OVHgeHWFDk9nhMqZ0m/3pd/lhwZgES"
                },
                {
                    "id":2,"email":"enrique10@email.com",
                    "password":"$2b$10$69SrwAoAUNC5F.gtLEvrNON6VQ5EX89vNqLEqU655Oy9PeT/HRM/a"},
                {
                    "id":3,
                    "email":"lola@codecademy.com",
                    "password":"$2b$10$9PU0sCJU201C3lO41bsOIu.HRrik7Alv2ZlxwM9A8lGr/clLK6D0m"},
                {
                    "id":4,"email":"joan@gmail.com",
                    "password":"$2b$10$EQSDN0hNs.7TFzQPetYKVerxMpzOLYrP3dp2W82AGXSgUuWU9YuPC"
                }
            ]
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>OAuth 2.0</h3>
            <ul>
                <li>There are three main types of <strong>API authentication:</strong> HTTP Basic Auth, API Keys, OAuth.</li>
                <li>Sometimes we don’t have to create a username and password for a new account. Instead, we can
                sign in with Google, LinkedIn, Twitter, and more. This is possible because of OAuth. 
                <strong>OAuth</strong> is an authorization framework that provides specific authorization flows 
                which allow unrelated servers to access authenticated resources without sharing any passwords. 
                It works by allowing applications to authenticate with third-party services in exchange for an 
                access token which can be passed with an HTTP request to access protected content.
                All methods of authorization have advantages and vulnerabilities and OAuth is no exception; however, it remains 
                a generally secure and convenient way to authenticate yourself on trusted applications.</li>
                Here're the steps on how it works:</li>
                <ul>
                    <li>Redirect user to provider for authorization -> User grants authorization -> Redirect user to application 
                    -> Exchange for access grant -> Grant access token -> Create connection.</li>
                </ul>
                <li><strong>Access Tokens: </strong>Authentication in OAuth is facilitated by the use of access tokens. 
                Access tokens are used to make API requests on behalf of the user and represent the authorization of a specific
                application to access specific parts of a user’s data. These API requests are made over HTTPS connections.
                Access tokens are very short-lived, and they only last anywhere from a few minutes to just hours. Their
                ephemeral nature limits the amount of time an attacker can use a stolen token.</li>
                <li><strong>Refresh tokens: </strong>Are longer lived than access tokens and are used by applications to get new access tokens 
                without prompting the user. Refresh tokens can expire, like access tokens, but they can also be revoked by
                the authorization server.</li>
                <li><strong>Grant Types: </strong>OAuth 2.0 grant types, <u>also known as flows</u>, describe multiple ways to 
                obtain access tokens. Flows involve two main parts: Redirecting the user to the OAuth provider and obtaining 
                an access token & using the access token to gain restricted access.</li>
                <ul>
                    <li>Some <strong>OAuth grant types: </strong>Client Credentials Grant; Authorization Code;
                    Proof Key for Code Exchange (PKCE); Implicit Grant - Deprecated; Device Code Grant;
                    Resource Owner Password Credential Grant - Deprecated.</li>
                    <li><strong>In the Client Credentials flow</strong>, permissions are granted directly to the application itself by 
                    an administrator. When the app presents a token to a resource, the resource enforces that the app 
                    itself has authorization to perform an action since there is no user involved in the authentication</li>
                    <li><strong>The Authorization Code Grant</strong> is the most widely used grant for publicly available applications. 
                    This was the grant type we showed earlier in this article. To use this grant type, the webserver must have the 
                    capability to store client credentials securely.
                    This approach uses browser redirection to communicate between the resource server and the authorization server. 
                    The client will obtain an authorization code and then exchange it for an access token.</li>
                </ul>
                <li>The <strong>four OAuth Roles</strong>:</li>
                <ul>
                    <li><strong>Resource Owner</strong>: the user who authorizes an application to an account (user);</li>
                    <li><strong>Resource Server</strong>: the API server that accepts access tokens and verifies their validity (server side, where resource relies);</li>
                    <li><strong>Authorization Server:</strong> the server that issues access tokens (auth server, like google, github, facebook...);</li>
                    <li><strong>Client:</strong> the application that requests the access tokens (client side).</li>
                </ul>
                <li>OAuth defines <strong>two types of clients:</strong></li>
                <ul>
                    <li><strong>Public clients</strong> are NOT able to store credentials securely and 
                    can only use grant types that do not use their client secret.</li>
                    <li><strong>Confidential clients</strong> are applications that can be registered to 
                    an authorization server using credentials. Those credentials, a client ID and a client secret, 
                    can be secured without exposing them to a third party. They require a backend server to store the credentials. 
                    A client’s ability to securely store credentials determines which type of OAuth authorization flows should be 
                    used. More information <a href="https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/" target="_blank">here</a>.</li>
                </ul>              
                <li><strong>Material on OAuth </strong><a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-user-authentication-authorization/modules/wdcp-22-oauth-2/cheatsheet" target="_blank">here</a>.</li>
                <li><strong>Download</strong> github-oauth-app project <a href="https://static-assets.codecademy.com/content/paths/web-security/oauth2/github-oauth-app.zip" target="_blank">here</a>.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode43" onclick="showCode('displayCode43', 'showCode43')">Display</button>
            <div id="displayCode43">
                <button onclick="closeCode('displayCode43', 'showCode43')">Close</button>
                <ul>
                    <li><strong>Implementing OAuth</strong></li>
                    <ul>
                        <li><strong>Install:</strong> We will use the oauth2-server module to implement 
                        an OAuth 2.0 provider in Node.js utilizing 
                        the client credentials grant type to demonstrate obtaining an access token and using it in request.
                        The package can be installed in the terminal using npm with the command: <strong><i>npm install oauth2-server</i></strong></li>
                        <li>From here, we instantiate the oauth2-server module and store it in a variable like below: <strong><i>const OAuth2Server = require('oauth2-server')</i></strong>;</li>
                        <li>We’ll create an <strong>instance of the OAuth2Server</strong> object and store it in a variable named oauth.
                        The OAuth2Server object requires a model object which contains functions to access, store, and validate our access tokens. 
                        We’ll be writing them separately in a file named model.js.</li>
                        <ul>
                            <li>OAuth2Server can be supplied with additional options in the constructor. To pass tokens inside the URL, we’ll set the 
                            <strong>allowBearerTokensInQueryString</strong> attribute to true.</li>
                            <li>The access token lifetime can also be configured as an option using the <strong>accessTokenLifetime</strong> attribute. 
                            The lifetime is set in seconds.</li>
                        </ul>
                        <pre>
                            <code>
                //app.js

                const oauth = new OAuth2Server({
                    model: require('./model.js'),
                    allowBearerTokensInQueryString: true,
                    accessTokenLifetime: 60 * 60
                })
                            </code>
                        </pre>
                    </ul>
                    <hr/>
                    <li><strong>Registering Client to Application</strong></li>
                    <ul>
                        <li>We'll implement the <strong>Client Credentials</strong> flow to obtain an access token
                        for authentication. When a developer registers a client in an OAuth application, they’ll need:</li>
                        <ul>
                            <li><strong>A Client ID:</strong> a public identifier for apps that is unique across all clients and the authorization server.</li>
                            <li><strong>A Client Secret:</strong> a secret key known only to the application and the authorization server.</li>
                            <li>More about <a href="https://www.oauth.com/oauth2-servers/client-registration/client-id-secret/" target="_blank">here</a>.</li>
                        </ul>
                        <li>For our example application, we use an in-memory database defined in db.js. Inside db.js, 
                        we use modules.exports to create a module to hold our <strong>confidential client 
                        credentials</strong> and <strong>access tokens</strong>.
                        We can register an application to the list of confidentialClients in db.js. Inside the module.exports 
                        object, we create an attribute named <strong>confidentialClients</strong> and set it equal to an array. Within the array,
                        we create an object with the <i>clientId</i> and <i>clientSecret</i>, and specify 'client_credentials' 
                        in our array of grant types.</li>
                        <li>In our database, we’ll create a location to store access tokens. Within the module.exports object, we create another 
                        property named tokens and set it equal to an empty array.</li>
                        <pre>
                            <code>
                //db.js

                module.exports = {
                    // Add confidential clients[]
                    confidentialClients: [{
                        clientId: 'codecademy',
                        clientSecret:'codec@demy',
                        grants: [
                            'client_credentials'
                        ]
                    }],
                    // Add tokens[]
                    tokens: []
                }
                            </code>
                        </pre>
                        <li>OAuth2Server requires certain functions implemented in the model regardless 
                        of the authorization flow used. The <strong><i>getClient()</i></strong> function is an example of a required model function for all flows. 
                        The function is used to retrieve a client using a Client ID and/or a Client Secret combination.
                        The <i>getClient()</i> function takes two arguments: <i>clientId</i> and <i>clientSecret</i>. 
                        We must write a database query to match 
                        the provided arguments and its implementation will vary depending on the type of database used. Since we are 
                        using JavaScript as our in-memory database, we can use the <i>.filter()</i> method to evaluate if the clientId and 
                        clientSecret match any confidential clients in db.js and return the matching client.</li>
                        <li>We <strong>iterate over each element</strong> in the confidentialClients array inside db.js. Each element’s clientId
                        and clientSecret is tested to match against the clientId and clientSecret of the client that is passed 
                        and will return the client that matches both values in an array. Finally, the <i>getClient()</i> function returns 
                        the first element in confidentialClients.
                        Finally, we export the function from model.js so that it can be used from other files. We can do 
                        this using module.exports object.</li>
                        <li>The <strong><i>saveToken()</i></strong> function must be implemented for all grant types 
                        in the model used by OAuth2Server. This function stores the access token as an object to a 
                        database when an access token is obtained.
                        The <i>saveToken()</i> function is implemented with three arguments: token, client, and user.
                        We’ll also export the saveToken() function from models.js using module.exports.</li>
                        <ul>
                            <li>The <strong>token.user</strong> is set equal to an object with the username attribute. We set the 
                            username attribute equal to the username of the passed user object.</li>
                            <li>The <strong>token.client</strong> equal an object in which the id attribute is equal 
                            to the passed client’s clientId.</li>
                            <li>With the token formatted, we can save the token to our database by pushing the token 
                            to our db.tokens array and returning the token.</li>        
                        </ul>
                        <li>Certain grant types have specific functions that must be implemented for them to work. The Client Credentials 
                        grant type must have the <strong>getUserFromClient()</strong> function implemented to be used.
                        The <i>getUserFromClient()</i> function is invoked to retrieve the user associated with the specified 
                        client. We are not using a user in our application so we can return an empty object. However, 
                        leaving out this function declaration will throw an error when using the Client Credentials 
                        grant type. Finally, we export the function from model.js so that it can be used from other files. 
                        We can do this using <i>module.exports</i> object.</li>
                        <pre>
                            <code>
                //model.js

                let db = require('./db.js');

                // getClient() function
                const getClient = (clientId, clientSecret) => {
                        let confidentialClients = db.confidentialClients.filter((client) => {
                        return client.clientId === clientId && client.clientSecret === clientSecret
                    });
                    return confidentialClients[0];
                }
                
                // saveToken() function
                const saveToken = (token, client, user) => {
                        token.client = {
                        id: client.clientId
                    }
                    token.user = {
                        username: user.username
                    }
                    db.tokens.push(token);
                    return token;
                }

                const getUserFromClient = (client) => {
                    return {}
                  }
                
                // Export saveToken() here
                module.exports = {
                    getClient: getClient,
                    saveToken: saveToken,
                    getUserFromClient: getUserFromClient
                }
                            </code>
                        </pre>
                        <li>Now that our model functions for generating and saving access tokens are implemented 
                        in model.js, we need to create a callback function to handle obtaining the access token whenever 
                        a URL is requested in our application. Within app.js, we create a function named <strong>obtainToken()</strong> 
                        that takes the HTTP request and HTTP response as arguments—req and res.
                        <li>Inside <i>obtainToken()</i>, we create a new variable named request and set it to a new instance 
                        of <i>OAuth2Server.Request()</i>, passing the HTTP request, req, as the argument.
                        We’ll also create a new variable named response and set it to a new instance of OAuth2Server.Response(), 
                        taking in res as the argument.</li>
                        
                        <li>The <i>.token()</i> method of the oauth object returns the access token. The method passes the OAuth2Server‘s 
                        request and response stored in response and request variables. We use the <i>.then()</i> method to return a promise. 
                        If the token method is successful, we will send the access token back to the client using the <i>.json()</i> Express method.                        
                        We’ll chain the <i>.catch()</i> method to handle any errors if the <i>.token()</i> method fails. If the <i>.token()</i> method returns 
                        an error code or an HTTP 500 status, the error can be sent back to the client using the <i>.json()</i> method.</li>
                        
                        <li>Note, must declare our function expressions before they can be used. To make use of our 
                        <i>obtainToken()</i> function, we can define a new route and pass <i>obtainToken()</i> as a callback 
                        function. We use the <i>.all()</i> method to handle all types of HTTP requests since we will 
                        eventually use a POST request on the route. The route name can be anything we’d like—we’ll 
                        use /auth for our example.
                        Now the client can make an HTTP request with the Client Secret to /auth and receive an access token.</li>
                        <pre>
                            <code>
                //app.js

                // btainToken()
                const obtainToken = (req, res) => {
                    let request = new OAuth2Server.Request(req);
                    let response = new OAuth2Server.Response(res);
                    return oauth.token(request, response)
                    .then((token) => {
                        res.json(token);
                    }).catch((err) => {res.json(err)})
                }
                
                // '/auth' route
                app.all('/auth', obtainToken);                
                            </code>
                        </pre>
                        <li><strong>getAccessToken(): </strong>
                        Now that we’ve written the code to obtain an access token, <u>we can use it to restrict access 
                        to content unless a user is authenticated with a valid access token</u>. Inside <i>model.js</i>, we implement 
                        the <i>getAccessToken()</i> function to retrieve existing tokens that were previously saved when the 
                        <i>saveToken()</i> function is invoked.
                        
                        The <i>getAccessToken()</i> function is required when the <i>.authenticate()</i> method is used on an 
                        OAuth2Server instance. <i>getAccessToken()</i> is declared with one parameter—accessToken.
                        
                        When the function is invoked the accessToken is checked against the tokens stored inside the db.js to 
                        see if there is a match. We can use JavaScript’s <i>.filter()</i> method to each token in the database against 
                        the access token that is passed. If there is a match, the access token can be returned.</li>
                        <li>The <i>getAccessToken()</i> function expression is called with an access token as an argument. 
                        The <i>.filter()</i> method is used to check each token saved in the tokens array in the database 
                        to match the access token passed to the function. Finally, we return the matching access token from the array.
                        We export the function from <i>model.js</i> so that it can be used from other files. We can do this using module.exports object.</li>
                        <pre>
                            <code>
                //model.js

                const getAccessToken = (accessToken) => {
                let tokens = db.tokens.filter((savedToken)=>{
                    return savedToken.accessToken === accessToken;
                })
                return tokens[0];
                }
                            </code>
                        </pre>
                        <li><strong>module.export</strong> will look like this</li>
                        <pre>
                            <code>
                module.exports = {
                    getClient: getClient,
                    saveTokens: saveTokens,
                    getUserFromClient: getUserFromClient,
                    getAccessToken: getAccessToken
                }
                            </code>
                        </pre>
                        <li><strong>Authentication Middleware: </strong>
                        With the model function for checking access tokens implemented, let’s create a middleware function 
                        to handle authenticating access tokens inside our application. Inside <i>app.js</i>, we will create a function 
                        named <i>authenticateRequest()</i> that takes three arguments: <i>req</i>, <i>res</i>, <i>next</i>.

                        Inside the function, we create a new variable named request and set it to a new instance of 
                        <i>OAuth2Server.Request()</i>, taking in the HTTP request, req, as the argument.
                        We’ll create a new variable named response and set it to a new instance of <i>OAuth2Server.Response()</i>, 
                        passing in the HTTP response, res.

                        We then return <i>.authenticate()</i> method, that is provided by the OAuth2Server object, on oauth, 
                        passing in response and request. The method returns a Promise that resolves to the access token object 
                        returned from the <i>.getAccessToken()</i> method we defined in model.js. We’ll use a promise chain to handle the flow.
                        We use the <i>.then()</i> method, and if the access token is valid, we can call the <i>next()</i> function to call the 
                        next function. We’ll chain the .catch() method to handle an error or if the access token is invalid. 
                        Inside <i>.catch()</i> method, we can send a response back to the client using the </i>.send()</i> method.
                        Finally, we can add <i>authenticateRequest</i> as a middleware function to a route to restrict access. 
                        Now the client must include the bearer token in the header when making a request to the route to 
                        gain authenticated access.</li>
                        <pre>
                            <code>
            //app.js
                                
            const authenticateRequest = (req, res, next) => {
            
            let request = new OAuth2Server.Request(req);
            let response = new OAuth2Server.Response(res);
            
            return oauth.authenticate(request, response)
                .then(()=>{
                    next();
                })
                .catch((err) => {
                    res.send('You are not allowed')
                })
            }
                            </code>
                        </pre>
                        <li><strong>authenticateRequest as middleware</strong> to '/secret'</li>
                        <pre>
                            <code>
            // app.js                    
                        
            app.get('/secret', authenticateRequest, (req, res)=>{
                res.send('Welcome to the secret area.');
            })
                            </code>
                        </pre>
                    </ul>
                    <hr/>
                    <li><strong>Full</strong> <i>app.js</i> implementation:</li>
                    <pre>
                        <code>
            const express = require('express');
            const path = require('path');
            const OAuth2Server = require('oauth2-server');

            const app = express();

            app.use(express.json());
            app.use(express.urlencoded({extended: true}));

            const PORT = 4001;

            const oauth = new OAuth2Server({
                model: require("./model"),
                allowBearerTokensInQueryString: true
            })

            const authenticateRequest = (req, res, next) => {
            
            let request = new OAuth2Server.Request(req);
            let response = new OAuth2Server.Response(res);
            
            return oauth.authenticate(request, response)
                .then(()=>{
                    next();
                })
                .catch((err) => {
                    res.send('You are not allowed')
                })
            }

            const obtainToken = (req, res) => {
                let request = new OAuth2Server.Request(req);
                let response = new OAuth2Server.Response(res);

                return oauth.token(request, response)
                .then((token) => {
                    res.json(token);
                })
                .catch((err) => {
                    res.json(err);
                })
            }

            app.all('/auth', obtainToken);

            app.get('/', (req, res)=>{
                res.sendFile(path.join(__dirname, 'public/home.html'));
            })
            app.get('/login', (req, res)=>{
                res.sendFile(path.join(__dirname, 'public/login.html'));
            })

            app.get('/public', (req, res)=>{
                res.sendFile(path.join(__dirname, 'public/allowed.html'));
            })

            app.get('/secret', authenticateRequest, (req, res)=>{
                res.send('Welcome to the secret area.');
            })

            app.listen(PORT, ()=>console.log(`Listening on port ${PORT}`));

                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Testing Endpoints with HTTP</strong></li>
                    We’ve implemented the Client Credentials OAuth 2.0 flow in our application! The handling 
                    of access tokens is done with HTTP requests. We can make an HTTP POST request to the /auth 
                    route to obtain an access token.
                    <pre>
                        <code>
                    POST http://localhost:4001/auth
                    Content-Type: application/x-www-form-urlencoded
                    Authorization: Basic Y29kZWNhZGVteTpjb2RlY0BkZW15
                    
                    grant_type=client_credentials
                        </code>
                    </pre>
                    <li>In the HTTP header, we set Authorization to Basic and the base64 encoded Client ID and Client 
                    Secret. In the POST request data, we provide grant_type=client_credentials. The server will 
                    respond with an access token that looks like this:</li>
                    <pre>
                        <code>
                    {
                        "accessToken":" "<access token>",
                        "accessTokenExpiresAt":"2021-06-17T01:02:37.272Z",
                        "client": {
                            "id": "codecademy"},
                            "user":{}
                        }
                    }
                        </code>
                    </pre>
                    <li>To use the access token while requesting authenticated content, we pass the bearer token in 
                    the Authentication request header, replacing < Access Token > with the token returned from the 
                    request to /auth like so: < /Access >
                    <pre>
                        <code>
                    GET http://localhost:4001/secret
                    Authorization: Bearer < Access Token >
                        </code>
                    </pre>
                    <li><strong>In resume: </strong>
                    On the /login page, the login button sends a POST request to /auth with the Authorization header 
                    already populated with the Client ID. When the server receives the request, the Client ID is passed 
                    to the <i>obtainToken()</i> callback function where the <i>.token()</i> method is called and returns the access 
                    token to the client.
                    Now, when we click the link to /secret the client passes the access token as a URL parameter, and the server 
                    calls the <i>authorizeHandler()</i> callback function where the <i>.authorize()</i> method is called to verify whether 
                    the access token is valid. If the access token is valid, then secret.html is sent to the client, otherwise 
                    <i>error.html</i> is sent.</li>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>Test-driven development (TDD)</h2>
            <ul>
                <li><strong>TDD: </strong> 
                When software engineers and development teams build new features, they’re faced with challenging 
                questions along the way. Where do we start development? (Do I start writing HTML, or adding server implementation?).
                What is the most efficient implementation? (Is X implementation faster than Y implementation?).
                How will the new feature impact our existing code? (Will new code introduce a bug?).
                <strong>TDD</strong> is the process of writing tests before implementation code. You use the 
                feedback from your tests to inform the implementation of a feature or outcome.</li>
                <li><strong>Red, Green, Refactor approach:</strong> A common approach to TDD is the <strong>red, green, refactor cycle</strong>. When you write a test before the implementation 
                exists you start “in the <strong>red</strong>” phase, because your test fails and outputs a red error message. 
                Next, you write the minimum implementation code to get your test to pass. This puts you “in the <strong>green</strong>” phase, 
                because your test passes and outputs a green message.
                Once you are in the green, you should consider whether your implementation is the best or most efficient 
                approach. If you think your code could be written more efficiently or cleaner, then you enter the 
                <strong>refactor</strong> phase. You can refactor your code with confidence, because you have tests that cover the 
                expected behavior.</li>
                <li><strong>Outside-in TDD:</strong> Is an approach that developers use to build full-stack 
                web applications. It leverages the same red, green, refactor steps that we covered above, but with one caveat — a 
                failing test does not always inform you to write new implementation code. Instead, it may require that you implement 
                new functionality at a different level. </li>
                <ul>
                    <li>You start at the top of the stack, the view, and write 
                    tests as you work your way towards the database layer. If a test pushes you to a lower level, 
                    you restart your red, green, refactor cycle by writing a new test. This test informs the 
                    implementation at your new layer. You continue the TDD cycle at this lower level until: 
                    You need to drop another layer to implement the desired behavior /
                    You have addressed the reason for dropping to the current layer.</li>
                    <li>Once you address the reason for dropping a layer, you can start working your way back up the <strong>testing pyramid</strong>. 
                    If you’re in the model/database layer, you step up to the server, and run your server tests to see if you get 
                    a different response. The response should be one of the following:</li>
                    <ul>
                        <li><strong>The test passes</strong> — you can start another red, green, refactor cycle at the server level or step up to the view layer.</li>
                        <li><strong>The test fails</strong> — the server test that pushed you to the model layer fails, but for a different reason.
                        This is common, and indicates that you’re making progress. This failure may indicate that you need to write 
                        additional implementation at the server level, or drop back to the model.</li>
                    </ul>
                </ul>
                <p class="center"><strong>Outside-in TDD example:</strong></p>
                <button id="showCode44" onclick="showCode('displayCode44', 'showCode44')">Display</button>
                <div id="displayCode44">
                    <button onclick="closeCode('displayCode44', 'showCode44')">Close</button>
                    <li><strong>Outside-in Example</strong></li>
                    <ul>
                        <li>We’re going to use the following as an example of how to develop a new feature with 
                        outside-in TDD: You have a movie blog and want to develop a feature that renders user comments 
                        under your blog posts. The application should render no more than ten comments when a user lands
                        on the web page. The application should present the comments in reverse chronological order 
                        (i.e. the most recent comment should be first).
                        Let’s assume the web application generates HTML at the server — any updates to the view require 
                        implementation at the server level.</li>
                        <li><strong>Feature Testing: </strong>
                        The first step is to write a feature test that checks if your web application is rendering 
                        comments to the browser. Let’s use the following outside-in TDD approach:</li>
                        <ol>
                            <li>Write a test that checks for the presence of a comment under a blog post.</li>
                            <li>The test fails, because your web application does not render comments.</li>
                            <li>Because your web application generates HTML at the server layer, you drop to the server to address the error.
                            Although we could continue to write feature tests to check for the number of rendered comments, 
                            we know server tests are cheaper, so we can test those details when we drop a layer.</li>
                        </ol>
                        <li><strong>Server Testing: </strong>
                        At the server layer, we start by writing a test that informs the implementation of our 
                        -generated HTML. Because our web application renders unique comments from the database, 
                        we want to check that the server-generated HTML is dynamic.</li>
                        <ol>
                            <li>Write a test that checks for the presence of a dynamically generated comment element in the server HTML.</li>
                            <li>The test fails, so we add implementation for a server-generated comment.</li>
                            <li>Once we’re in the green and consider refactoring, we want to write a test that calls a method at the model 
                            layer, let’s call it <i>Comment.latest()</i>. At the server layer, we’ll check if the method returns comments from the database.</li>
                            <li>Because this method doesn’t exist, we must drop to the model/database layer.</li>
                        </ol>
                        <li><strong>Model and Database Testing:</strong>
                        At the model layer, we start by writing a test that informs the implementation of our Comment.latest method. This method requires that 
                        you interface with the web application’s database.</li>
                        <ol>
                            <li>Write a test that checks if the Comment.latest method returns ten comments when the database has eleven comments.</li>
                            <li>Implement the Comment.latest method to return ten comments, so the test is green.</li>
                            <li>Once you’ve considered refactoring, write a test that checks whether the method returns the last ten comments in reverse chronological order.</li>
                            <li>Implement and refactor.</li>
                            <li>Write a test that checks if Comment.latest() returns an empty array when your database is empty.</li>
                            <li>Implement and refactor.</li>
                            <li>Write a test that checks if Comment.latest returns the correct number and order of comments when your database has between zero and ten comments in it.</li>
                            <li>Implement and refactor.</li>
                        </ol>
                        <li><strong>Taking Stock:</strong> At this point, your entire test suite should be green. You have written seven new tests, and the implementation code to make them pass — your web application 
                        should render the last ten comments from your database in reverse chronological order.
                        Let’s take stock of our seven new tests:</li>
                        <ol>
                            <li><strong>Feature:</strong> Comments are rendered to a user’s browser.</li>
                            <li><strong>Server:</strong> The server generates an HTML field for comments.</li>
                            <li><strong>Server:</strong> The server has access to ten comments from the database.</li>
                            <li><strong>Model:</strong> The Comment.latest method returns ten comments from your database.</li>
                            <li><strong>Model:</strong> The Comment.latest method returns the last ten comments in your database in reverse chronological order.</li>
                            <li><strong>Model:</strong> The Comment.latest method returns an empty array when your database has zero comments.</li>
                            <li><strong>Model:</strong> The Comment.latest method returns all of the comments when your database has between zero and ten comments.</li>
                        </ol>    
                        <li>Once your feature is working as expected, you should consider how your new tests fit into the broader test suite. The rest of the test suite could have few tests, 
                        or over one hundred. It’s time to refactor.</li>
                        <li><strong>Refactoring Your Test Suite: </strong>
                        The way you approach refactoring will vary based on the size and types of tests in your suite. One guiding light in refactoring is to optimize the suite for confidence and speed. Because we used TDD to implement our comment feature, 
                        we should feel confident that our comments are working as expected, and the feature is fully covered.
                        Consider the questions below when deciding how to refactor your suite:</li>
                        <ul>
                            <li>How much longer does it take to run my test suite with these new tests?</li>
                            <li>Is the additional amount of time that your test suite takes to run acceptable?</li>
                            <li>Is there overlap between any of my new tests?</li>
                            <li>Is there overlap between my new tests and existing tests?</li>
                        </ul>   
                        <li>Let’s take a moment to consider a few of these questions in the context of our test suite.</li>
                        <i>How much longer does it take to run my test suite with these new tests?</i>
                        <ul>
                            <li>You can calculate this value by running your test suite before and after writing the new tests, 
                            and calculate the difference. Seven new tests, like the ones above may only add a few seconds to your suite. 
                            Let’s use our next question to think about how you can evaluate what an acceptable amount of time may be.</li>
                        </ul>
                        <i>Is the additional amount of time that your test suite takes to run acceptable?</i>
                        <ul>
                            <li>Although a few seconds may seem acceptable, this time can add up as your suite grows. 
                            if you’re comfortable with the additional time, you should always consider whether you 
                            can make speed improvements that don’t impact confidence.</li>
                        </ul>
                        <i>Is there overlap between any of my new tests?</i>
                        <ul>
                            <li>You should consider if any new tests, especially in the feature or server level, can be 
                            deleted without impacting your confidence that the comments feature works as expected. 
                            For example, our first server test checks if the server generates an HTML field for comments. 
                            Your feature-level test checks the same functionality — it also takes longer, but provides a 
                            higher level of confidence. We decide to delete the server test for reasons we will investigate 
                            when we consider our next question.</li>
                        </ul>
                        <i>Is there overlap between my new tests and existing tests?</i>
                        <ul>
                            <li>Next, you should look outside your seven (now six) new tests to consider the coverage offered 
                            by the other tests in your suite. Often, your test suite will have a feature test that checks 
                            whether the web page renders as expected — this is usually good enough coverage for most new 
                            features. Given the cost of feature-level tests, and the coverage of your lower-level tests, 
                            it often makes sense to delete the new feature-level test.</li>
                        </ul>
                    </ul>
                </div>
                <li><strong>Headless browser testing: </strong>
                Headless testing is a way of running browser UI tests without the head, which in this case means that there’s no 
                browser UI, no GUI of any sorts. This is useful since when running tests, especially in a CI environment, there is 
                nobody “watching” the visuals, so there is no need to have the extra overhead of the browser GUI.
                One of the biggest reasons for using a headless browser/carrying out headless testing is performance, since it lets 
                you run tests more quickly in a real browser environment. 
                <strong>More about it</strong> <a href="https://blog.logrocket.com/introduction-to-headless-browser-testing-44b82310b27c/" target="_blank">here</a>.
                <hr/>
                <h3><strong>Outside-in TDD approach</strong></h3>
                <li><strong>Feature Test Toolbelt: </strong>To write the most effective feature tests, we are going to 
                employ a few additional tools. These tools are meant to support JavaScript testing. We will cover their 
                uses in the scope of building a feature test that drives implementation.
                <strong>Video implementation</strong> <a href="https://www.youtube.com/watch?v=eGcPoUfm6Ow&embeds_euri=https%3A%2F%2Fwww.codecademy.com%2F&embeds_origin=https%3A%2F%2Fwww.codecademy.com&feature=emb_imp_woyt" target="_blank">here</a>.</li>
                <ul>
                    <li><strong>Chai: </strong>
                    Node.js has a default assertion library that provides enough functionality to write basic test code. The Chai testing library extends the types of assertions we can make.
                    Chai is an assertion library for Node.js and browsers that can be paired with any JavaScript testing framework. <strong>Documentation</strong> <a href="https://www.chaijs.com/" target="_blank">here</a>.</li>
                    <li><strong>PhantomJS: </strong>Is a headless browser scriptable with a JavaScript API, which allows us to write tests that mimic user interaction and then evaluate the results. It does not require us to render the application in a browser.
                    A browser runs “headless” when it doesn’t render anything to the screen, but runs in the background. <strong>Documentation</strong> <a href="https://phantomjs.org/documentation/" target="_blank">here</a>.</li>
                    <li><strong>WebdriverI/O: </strong>
                    WebdriverIO provides methods that allow us to programmatically interact with the user-facing elements 
                    of our app in the headless browser that PhantomJS runs. <strong>Documentation</strong> <a href="https://webdriver.io/docs/why-webdriverio/" target="_blank">here</a>.</li>
                    <li><strong>Toolbelt High-Level Summary: </strong>
                    Phantom allows us to run an instance of a headless browser so you can run tests that mimic user 
                    interaction with a web application. WebdriverIO provides the methods to interact with browser values 
                    programmatically. We can make assertions against these tests using the Chai assertion library.</li>
                </ul>
            </ul>
            <p class="center"><strong>Feature Test Example:</strong></p>
            <button id="showCode45" onclick="showCode('displayCode45', 'showCode45')">Display</button>
            <div id="displayCode45">
                <button onclick="closeCode('displayCode45', 'showCode45')">Close</button>
                <li><strong>Feature Test I: </strong>
                Feature tests exercise behavior by simulating a user navigating the application in a web browser.
                Imagine we wanted to create a simple web-based poetry writing application.
                The first feature test we want to write is to check our application’s empty state. 
                The functionality we want to test is:</li>
                <ul>
                    <li>When a user visits the homepage, the poems section is empty.</li>
                    <li>We want to make sure that when there are no poems in the database, there are no poems rendered on the homepage. This is the application’s empty state.</li>
                </ul>
                <li>The term ‘root’, refers to our application’s entry point, which in this example is the home page 
                that users will visit in their browser.</li>
                <li>Next, we add an it block to describe the behavior we want to test in our app.
                When a user visits the root of our app, they should have a blank page on which to write their own poem.</li>
                <li><strong>The Plumbing:</strong>
                Next, we reach for our feature testing toolbelt. We start by to using the global browser variable
                that is provided by WebdriverI/O.
                The browser variable is powerful because it gives us access to the browser that Phantom 
                is running in the background. We can simulate a user interacting with our website by calling 
                different methods on the global browser variable in our test suite.
                For example, we can use browser.url() to simulate a user visiting the home page of our application, 
                which is the first behavior we want to test.
                The .url method navigates to the URL that is passed to it as an argument. The following line of code
                would navigate to the Codecademy website in the Phantom browser.
                In the case of our poetry web app, we will pass in '/' as the argument, which will point the browser to the root file of our project, which in this case is our index.html.</li>
                <li><strong>Assert: </strong>
                The last thing our test needs is an assert statement to verify that the behavior we 
                expect is equal to the actual behavior of our code. We want to make sure our app is in an empty state.
                We can write a test for this behavior by deciding that poems will be listed in an HTML element 
                with an id attribute set to poems. Then, write an assert statement to verify that the element with the ID poems is empty.
                We can do this using the Chai assert.equal method, which evaluates if the two arguments are equal.
                Because we will render the poetry onto the page as text, we can evaluate the contents of the HTML 
                element as a string. The .getText method, from WebdriverI/O, gets the text content from the selected DOM element.
                Here we are using browser.getText() to evaluate if the text in the element with the ID poems is equal 
                to an empty string. Our final code for this feature test would look like this:                            
                <pre>
                    <code>
            describe('User visits root', () => {
                describe('without existing poems', () => {
                    it('page starts blank', () => {
                    browser.url('/');
                
                    assert.equal(browser.getText('#poems'), '');
                    });
                });
            });              
                    </code>
                </pre>
                <li>index.js should be, so test <strong>passes</strong>:</li>
                <pre>
                    <code>
                    < section id="poems" >< /section >
                    </code>
                </pre>
                <hr/>
                <li><strong>Feature Test II: </strong>Now we want to write a test to check if the application saves 
                the title and text of a user’s poem when they press the submit button.
                The functionality we want to test is:</li>
                <ol>
                    <li>The user enters text into a text input element (the poem).</li>
                    <li>The user enters text into a second text input element (the title of the poem).</li>
                    <li>The user presses a submit button</li>
                </ol>
                <li>Next, we want to write the setup, exercise, and verification phases of our test.
                In the setup phase for this test, we create variables to represent a user’s input
                to the title and poem fields on the home page. The second test will look like this:</li>
                <li>The next step for our poetry web app is to use our browser variable for the exercise phase of the test.
                First, we will set the URL of the browser to go to the root of our project using the .url method.
                Next, we will use the .setValue method, which sends a sequence of keystrokes to an element, based 
                on a string argument.
                We will use .setValue() to mimic a user entering the title and poem into the corresponding HTML 
                input elements at the root of our web app.
                The first argument passed to .setValue() is the CSS selector that references an HTML element, and the 
                second argument is the value you want to assign that element.</li>
                <pre>
                    <code>
            browser.setValue('input[id=title]', title);
            browser.setValue('textarea[id=poem]', poem);
                    </code>
                </pre>
                <li>In the example above, a text input with the ID of title will be set to a value of title. Also, the 
                textarea with ID poem will be set to the value poem. The variables referenced here are the ones we 
                created in the setup phase.
                To complete the exercise phase of our test we would use the .click method to mimic a user clicking
                on a submit button. browser.click('input[type=submit]');
                Now that we have programmed the behavior we want to test in the exercise phase, we will write the 
                verification phase of our test. We will compare the actual results of exercising the code with the 
                expected results.
                In the case of our poetry app, we want to verify that once a user submits a poem, the section of the 
                app’s webpage that we have decided will display the poems includes that poem.
                We have created that element already to make our first feature test pass. It is the following line 
                of code in our index.html file:</li>
                <pre>
                    <code>
                < section id="poems" >< /section >
                    </code>
                </pre>
                <li>To add an assert statement to evaluate the behavior of our feature, we will use the browser 
                variable, and .getText() to return the text contents of the element, with the id poem.
                The Chai Assertion Library allows us to use the .include method to check if the string that is returned
                from .getText() includes the substrings of the title and poem that the user has submitted:
                assert.include(browser.getText('#poems'), title);
                assert.include(browser.getText('#poems'), poem);
                In both assert statements the first argument we pass to .include() is the function we created above it.</li>
                <pre>
                    <code>
            describe('demo poetry web app', () => { 
                it('saves the user poem and title', () => {
                    // Setup
                    const title = 'Words Birth Worlds';
                    const poem = 'Our words are marvelous weapons with which we could behead the sun';
                    // Exercise
                    browser.url('/');
                    browser.setValue('input[id=title]', title);
                    browser.setValue('textarea[id=poem]', poem);
                    browser.click('input[type=submit]');
                    // Verify
                    assert.include(browser.getText('#poems'), title);
                    assert.include(browser.getText('#poems'), poem);
                });
            });
                    </code>
                </pre>
                <li>On <strong>index.js:</strong></li>
                <pre>
                    <code>

                < label for="title" >Title< /label >
                < input id="title" >
                    
                < label for="poem" >Your poem:< /label >
                < textarea id="poem" >< /textarea >
                    
                < input type="submit" >
                    </code>
                </pre>
                <li>This will run an error. While this error message looks similar to the ones before, 
                it is a different type of error message, and it signals the need for a shift in our TDD process.
                What’s different here is that the failure comes from the verification phase instead of the exercise 
                phase. While this isn’t always the case, that means that we’ve changed the implementation code enough 
                to get to the part of the test where we’re specifying behavior, not just the existence of elements.                  
                The kind of test we need to write in response to this error will force us to drop levels in the TDD 
                Testing Pyramid.</li>
            </div>
            <ul>
                <li><strong>Server Testing Stack: </strong>
                Server tests are used to test the server response only, not any front-end rendering of code or user interactions. 
                We “disconnect” the browser and interact directly with the server using requests. The tests define the expected 
                behavior of the interactions and check the actual responses against what we expect.
                Server tests are commonly used to test API responses, but we also use server tests for any server response 
                that our application relies on. This can include checking status codes and error messages. <strong>Video Implementation</strong>
                <a href="https://www.youtube.com/watch?v=2E88EjDJgkw&embeds_euri=https%3A%2F%2Fwww.codecademy.com%2F&embeds_origin=https%3A%2F%2Fwww.codecademy.com&source_ve_path=MjM4NTE&feature=emb_title" target="_blank">here</a>.
                What we use:</li>
                <ul>
                    <li><strong>Chai</strong> - a library for extending the built in Node assertion library</li>
                    <li><strong>jsdom</strong> - a library for interacting and testing the DOM returned by the server
                    (this functionality is encapsulated in our parseTextFromHTML helper function).
                    <strong>Documentation </strong><a href="https://github.com/jsdom/jsdom#readme" target="_blank">here</a>.</li>
                    <li><strong>async / await</strong> - a pattern for making asynchronous code more readable</li>
                    <li><strong>SuperTest</strong> - a library for making Node server requests and testing their 
                    responses. <strong>Tutorial </strong>
                    <a href="https://hackernoon.com/api-testing-using-supertest-1f830ce838f1" target="_blank">here</a>.
                    <strong>Documentation </strong><a href="https://www.codecademy.com/paths/full-stack-engineer-career-path/tracks/fscp-22-back-end-and-feature-testing/modules/wdcp-22-server-testing-with-tdd/external_resources/ext-doc-supertest" target="_blank">here.</a></li>
                </ul>
            </ul>
            <p class="center"><strong>Server Test Example:</strong></p>
            <button id="showCode46" onclick="showCode('displayCode46', 'showCode46')">Display</button>
            <div id="displayCode46">
                <button onclick="closeCode('displayCode46', 'showCode46')">Close</button>
                <ul>
                    <li><strong>Testing Framework (Chai):</strong>When writing tests, sometimes you’ll find that 
                    the tests require calculation steps or inline code to determine if the test is passing. 
                    For example, to test if an array foo includes an element bar using Mocha with the built-in 
                    Node assertion library, we use the JavaScript includes helper:</li>
                    <ul>
                        <pre>
                            <code>
                    assert.ok(foo.includes(bar));
                            </code>
                        </pre>
                        <li>To improve the readability and flow of our tests, we extend the built-in Node assertion library with Chai.</li>
                        <pre>
                            <code>
                    const {assert} = require('chai'); 
                            </code>
                        </pre>
                        <li>The main function in Chai we are using is .include(). This allows us to rewrite the previous example as:</li>
                        <pre>
                            <code>
                    assert.include(foo, bar); 
                            </code>
                        </pre>
                        <li>Include also works to check that text contains certain values:</li>
                        <pre>
                            <code>
                    assert.include('foobar', 'bar'); // Evaluates to true  
                            </code>
                        </pre>
                        <li>The large set of assertion methods in the chai library enable us to write more expressive tests that
                        are easy for developers to understand. Example:</li>
                        <pre>
                            <code>
                const {assert} = require('chai');
                describe('Array', () => {
                    describe('.pop()', () => {
                        it('should return a value and remove the element from the array', () => {
                        // setup
                        const foo = [4];
                        const includedNumber = 4; 
                        // check setup
                    assert.include(foo, includedNumber)
                        // exercise
                        const fooPop = foo.pop();

                        // asserts
                        assert.equal(fooPop, includedNumber)
                        assert.equal(foo.length, 0)
                        });
                    });
                });
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Testing HTML Responses: </strong>
                Our back-end server is serving dynamic HTML to the user. For the homepage, this is located in 
                the jsdom-test.js file to the right. It is possible to use .include() to verify that the HTML
                response contains certain Strings, but gets cumbersome to verify the hierarchical relationships of DOM elements.

                We can use the <strong>jsdom library</strong> to improve this type of assertion. It allows us to 
                select elements of the DOM and check relationships and content. To increase the readability of our 
                tests, we abstracted the jsdom functionality into a custom function, parseTextFromHTML:</li>
                <ul>
                    <pre>
                        <code>   
                const parseTextFromHTML = (htmlAsString, selector) => {
                    const selectedElement = jsdom(htmlAsString).querySelector(selector);
                    if (selectedElement !== null) {
                        return selectedElement.textContent;
                    } else {
                        throw new Error(`No element with selector 
                        ${selector} found in HTML string`);
                    }
                };

                        </code>
                    </pre>
                    <li>This function takes the HTML response as a string and the desired selector as inputs and 
                    returns the textContent of the corresponding element. If no element is found, it will return
                    a TypeError.</li>
                    <pre>
                        <code>

                
                describe('HTML tests', () => {
                    describe('#bar', () => {
                        it('should include the string "Hello"', () => {
                            // setup
                            const foo = '< html >< div id="bar">Hello< /div >< div id="buzz">Hello< /div>< html>';
                            //asserts     
                            assert.include(parseTextFromHTML(foo, "#bar"), 'Hello'); 
                        });
                    });
                });
                        </code>
                    </pre>
                    <li><strong>Async / Await: </strong>
                    A server typically handles many requests at a time, but may be only capable of processing a subset 
                    of the requests concurrently. One side effect of this is that the server response time is neither 
                    instant nor predictable. If no other processes are occurring on the server, requests are handled 
                    quickly, but if the server is close to full capacity, the request can take a few seconds or even timeout.
                    We need a way to receive asynchronous responses from the server and then act on them. The async/await pattern introduced in Node 8 helps us write readable descriptions of the behavior of our application which is an important part of writing good tests.                  
                    To use this pattern, define the function with the async keyword. Then, within the function, use the await keyword in front of the asynchronous function you are calling.
                    Here, we are waiting for someAsyncThing() to return before logging the result to the console:</li>
                    <pre>
                        <code>
                const request = require('supertest');
                const app = require('../../app');
                
                describe('the homepage', () => {
                    it('returns the correct content', async () => {
                    const response = await request(app)
                        .get('/')
                        .send();
                        console.log(response.text);
                    });
                });                            
                        </code>
                    </pre>
                    </ul>
                    <li><strong>SuperTest:</strong>
                    As you may have noticed in the previous exercise, we are using the function request to make 
                    server calls to support our tests. This is actually a reference to the SuperTest library:
                    <i>const request = require('supertest');</i>This library was specifically designed for testing Node server responses and integrates well with 
                    Mocha and Chai. To use SuperTest, we pass the app object from our app into the request function. 
                    To make a GET request, we use .get() with the desired route as the argument:</li>
                    <ul>
                        <pre>
                            <code>                
                await request(app)
                        .get('/')
                        .send();
                            </code>
                        </pre>    
                        <li>It is also possible to perform a POST using SuperTest. We chain any desired properties or 
                        inputs to the HTTP call, and use .send() to make the request:</li>
                        <pre>
                            <code>
                await request(app)
                        .post('/messages')
                        .type('form')
                        .send({author, message});
                            </code>
                        </pre>    
                    </ul>
                    <hr/>
                    <li><strong>Server Testing Patterns: </strong></li>
                    <ul>
                        <li><strong>Status Codes: </strong>
                        Server tests are slightly faster than browser-driven feature tests. Since the web browser is cut 
                        out of the test, we are not testing how things are rendered for the user. Instead, we are focused 
                        on the server response.
                        One use of TDD at the server level is to ensure that the HTTP status codes are returned as 
                        expected. Verifying status codes provide the most basic level of confidence that the server 
                        is functioning correctly. Having a test suite that includes status codes provides a quick check 
                        when implementing a new feature that we haven’t accidentally caused a request for valid routes to 
                        respond not authorized (401) or not found (404). 
                        To verify status codes, we are asserting that the response status is equal to the status code 
                        integer that our application requires: <i>assert.equal(response.status, 200);</i>
                        If we use the “red, green, refactor” approach to implement our server behavior we would start out 
                        with an assertion like this and expect it to fail (“red”). We then implement the behavior to pass
                        the test (“green”) and continue to refactor if needed, ensuring the test remains passing.</li>
                        <pre>
                            <code>
                        //index-test.js
            
                        const {assert} = require('chai');
                        const request = require('supertest');
                        
                        const app = require('../../app');
                        
                        describe('root page', () => {
                            describe('GET request', () => {
                                it('returns a 200 status', async () => {
                                    const response = await request(app).
                                    get('/');
                                    assert.equal(response.status, 200);
                                });
                            });
                        });
                            </code>
                        </pre>
                        <pre>
                            <code>
                    //index.js
            
                    const express = require('express');
                    const router = express.Router();
            
                    router.get('/', (req, res) => {
                    res.send()
                    });
            
                    module.exports = router;
            
                            </code>
                        </pre>
                        <li><strong>Response Content:</strong>
                        In the previous exercise, we checked that the server responded with specific status codes. Now we need to 
                        make sure the server is responding with the correct content. Specifically, we are looking at HTML responses 
                        that are rendered by the front-end.
                        Many servers return dynamic HTML content based on the user, the URL accessed, header values, and more. 
                        We use TDD to ensure the server responds correctly for each case. When designing our tests, it is 
                        important to consider both the intended and unintended user behavior.
                        We can organize our tests into two categories:</li>
                        <ul>
                            <li>tests that exercise the “Happy Path” — expected use cases of our application</li>
                            tests that exercise the “Sad Path” — unexpected or invalid use of our application
                            <li>For our tests, once we retrieve the response from the server, we use assert.include() 
                            from the Chai library to check the response.</li>
                        </ul>
                        <li>As an example, after requesting a valid profile page for “My Name”, you may receive the following 
                        response content:</li>
                        <pre>
                            <code>
            response.text = '< div>< div id="my-name">My Name< /div>< /div>';
                            </code>
                        </pre>
                        <li>You can retrieve the content of #my-name and check it using the following:</li>
                        <pre>
                            <code>
            assert.include(parseTextFromHTML(response.text, '#my-name'), "My Name"); //True
                            </code>
                        </pre>
                        <li>We could also write a separate test to check the corresponding “sad path”. Perhaps there is not yet a page for “Your Name”, so you should not receive a response containing similar HTML. We use .notInclude() to verify that the response is not including “Your Name” :</li>
                        <pre>
                            <code>
            assert.notInclude(parseTextFromHTML(response.text, '#my-name'), "Your Name"); //True
                            </code>
                        </pre>
                        <li>Note that here we are identifying the HTML elements by their ID using our parseTextFromHTML() helper but you can use any selectors supported by the jsdom library. This helper is returning the text content of the corresponding HTML element only, but you could write a separate helper for accessing other attributes.</li>        
                    </ul>
                    <li><strong>Refactoring: Route Parameters</strong>
                    In the previous exercise, we checked that the server responded with a specific message. On our home page, the title is constant for everyone, “Messaging App”.
                    What if we want to create a profile page that is customized for each user?
                    A straightforward implementation would be to generate hard coded routes for every single user of our app. Think: 'welcome/alice' => '< h1>Your Name is alice< /h1>', 'welcome/bob' => '< h1>Your Name is bob< /h1>', etc.
                    Hopefully if you see repetitive code like this, you’ll have an urge to refactor it to something more elegant using a variable route parameter. This allows us to put any username into the url and have the server generate the appropriate response. Think: 'welcome/:username' => '< h1 >Your Name is ' + req.params.username +'< /h1 >'.
                    If you are using the red, green, refactor approach, you will start with a set of passing (“green”) assertions for the section of code you are looking to improve. With the current behavior captured, you can begin refactoring, knowing that your tests will “catch” you by turning red if you miss something in your approach.</li>
                    <pre>
                        <code>
                //profile-test.js
    
                const {assert} = require('chai');
                const request = require('supertest');
                const {jsdom} = require('jsdom');
    
                const app = require('../../app');
    
                const parseTextFromHTML = (htmlAsString, selector) => {
                    const selectedElement = jsdom(htmlAsString).querySelector(selector);
                    if (selectedElement !== null) {
                        return selectedElement.textContent;
                    } else {
                        throw new Error(`No element with selector ${selector} found in HTML string`);
                    }
                };
    
                describe('profile page', () => {
                    describe('GET request', () => {
                        it('greets alice', async () => {
                            const response = await request(app).
                            get('/profile/alice');
                            assert.equal(parseTextFromHTML(response.text, '#welcome-message'), 'Welcome alice!');
                        });
                        it('greets bob', async () => {
                            const response = await request(app).
                            get('/profile/bob');
                            assert.equal(parseTextFromHTML(response.text, '#welcome-message'), 'Welcome bob!');
                        });
                    });
                });
                        </pre>
                    </code>
                    <pre>
                        <code>
                //profile.js
    
                const express = require('express');
                const router = express.Router();
    
    
                router.get('/:username', (req, res) => {
                    res.send('< h1 id="welcome-message">Welcome ' + req.params.username + '!< /h1>');
                });
    
                module.exports = router;
                        </code>
                    </pre>
                    <li><strong>Refactoring: Handlebars</strong>
                    Sometimes during the reflection of the refactor phase, you will realize that you can implement something better or more efficiently. In the code so far, we have been responding with inline HTML strings. On a large project, this could make it difficult for the front end developer to organize and maintain.
                    An improved approach to this is using a templating library like Handlebars to separate the HTML view from the JavaScript controller.
                    In the web app that you’ve built in this lesson, we’ve placed the templates in the /views folder and have an extension of .handlebars. Our controller will now use render to create the view and pass in any variables:</li>
                    <ul>
                        <pre>
                            <code>
                        const param = 'Foo';
                        res.render('templateName', {param});
                            </code>
                        </pre>
                        <li>The templates are written like regular HTML, but variables can be accessed within the view using 
                        double curly braces: <i>< h1 >{{ param }}< /h1></i> 
                        When the view is rendered, it will replace {{ param }} with its actual value:
                        <i>< h1>Foo< /h1></i></li>
                    </ul>
                    <li><strong>API Errors: </strong>
                    As mentioned earlier, one of the use cases for server testing is for checking API responses, 
                    especially the “sad path” where a user interacts with the server in an unexpected or disallowed 
                    manner. We need to make sure our server properly handles invalid passwords, form field errors, etc.
                    Ensuring the app is designed to withstand these issues and that the error interactions are well 
                    bounded is important.
                    Keep in mind that while there may only be one “happy path” for an interaction (user submits a 
                    valid password), there can be many corresponding “sad paths” (password is too short, doesn’t 
                    contain special characters, etc). By testing the majority of these on the server level, it saves 
                    us from testing them at a more resource intensive level including the user view.</li>
                    <li><strong>Summary</strong>
                    We used several technologies to write tests for both “happy” and “sad” paths of:
                    <ul>
                        <li>Server status codes</li>
                        <li>Server response content</li>
                        <li>Error cases</li>
                    </ul>
                    <li>We also saw how TDD can be used at the server level to guide the implementation of the server code:</li>
                    <ul>
                        <li>We wrote a failing test</li>
                        <li>We wrote the minimal required server code to pass the test</li>
                        <li>When we decided or needed to refactor to meet external requirements, we used the existing tests to make sure our refactored code maintained the same end behavior</li>
                    </ul>
                </ul>
                <hr/>
            </div>
            <li><strong>Is it worth a server test?: </strong>In general, it is up to the developer to make a judgement call on how in depth to write a test. Every test 
            written adds time to the testing cycle and can require maintenance if changes are made to the server 
            behavior. For example, extensively testing failure cases at the feature level might be more than is needed 
            if the error behavior can be fully tested and described at the server level.
            As you develop an application, you may realize that you can replace feature tests or reduce them with equal 
            coverage at a lower level. One question to ask when deciding between a full feature test versus a server 
            test is:
            “Is it worth trading a slow feature test for a faster server test that doesn’t test the UI?”
            Based on the context of the different levels of testing, you should aim to pick the set of tests that gives you the best combination of reliable, complete and fast tests.</li>
        </div>
        <div class="styleGuide">
            <h2>Database</h2>
            <ul>
                <li><strong>Database</strong> is a set of data stored in a computer. This data is usually structured in 
                a way that makes the data easily accessible. <strong>DBMS</strong> is the specific software that allows 
                you to interact with a database.</li>
                <li><strong>Relational Database: </strong>
                A relational database is a type of database. It uses a structure that allows us to identify and access
                data in relation to another piece of data in the database. Often, data in a relational database is 
                organized into tables.</li>
                <ul>
                    <li><strong>Tables (Rows and Columns):</strong>
                    Tables can have hundreds, thousands, sometimes even millions of rows of data. These rows are often called 
                    records. Tables can also have many columns of data. Columns are labeled with a descriptive name 
                    (say, age for example) and have a specific data type.
                    For example, a column called age may have a type of INTEGER (denoting the type of data it is meant to hold).
                    In the table above, there are three columns (name, age, and country).
                    The name and country columns store string data types, whereas age stores integer data types. The set of 
                    columns and data types make up the schema of this table.
                    The table also has four rows, or records, in it (one each for Natalia, Ned, Zenas, and Laura).</li>
                </ul>
                <li><strong>NoSQL: </strong>
                Any database technology that stores data differently from relational.
                databases can be categorized as a NoSQL database.</li>
                <li><strong>Relational database VS NoSQL: </strong>Using a <strong>relational</strong> database structure, we might separate the information for each person, having 
                their id, name, and email, in one table named customers, and then another table for the subscriptions,
                having the newsletter name, and other information associated with the subscriptions.
                With a <strong>NoSQL database</strong>, instead of separating information in this way, 
                we might just have a single document with the person’s information, as well as the subscription 
                information, all in one document. Article about
                <a href="https://www.digitalocean.com/community/tutorials/a-comparison-of-nosql-database-management-systems-and-models" target="_blank">here</a>.</li>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>SQL</h2>
            <ul>
                <h3>Relational Database Management System (RDBMS)</h3>
                <li><strong>Relational Database Management System (RDBMS):</strong>
                A relational database management system (RDBMS) is a program that allows you to create, update, and 
                administer a relational database. Most relational database management systems use the SQL language to 
                access the database. <strong>SQL (Structured Query Language)</strong> is a programming language used 
                to communicate with data stored in a relational database management system. SQL syntax is similar to 
                the English language, which makes it relatively easy to write, read, and interpret.
                Many RDBMSs use SQL (and variations of SQL) to access the data in tables. For example, SQLite is a 
                relational database management system. SQLite contains a minimal set of SQL commands (which are the 
                same across all RDBMSs). Other RDBMSs may use other variants.
                (SQL is often pronounced in one of two ways. You can pronounce it by speaking each letter individually 
                like “S-Q-L”, or pronounce it using the word “sequel”.)
                By learning the fundamentals with one RDBMS, you can easily begin work in another. Here are some popular RDBMSs:</li>
                <ul>               
                    <li><strong>MySQL:</strong> Is the most popular open source SQL database. It is typically used for web 
                    application development, and often accessed using PHP.
                    The main advantages of MySQL are that it is easy to use, inexpensive, reliable (has been around 
                    since 1995), and has a large community of developers who can help answer questions.                   
                    Some of the disadvantages are that it has been known to suffer from poor performance when scaling,
                    open source development has lagged since Oracle has taken control of MySQL, and it does not 
                    include some advanced features that developers may be used to.</li>
                    <li><strong>PostgreSQL</strong> Is an open source SQL database that is not controlled by any corporation. It is typically used for web application development.
                    PostgreSQL shares many of the same advantages of MySQL. It is easy to use, inexpensive, reliable and has a large community of developers. It also provides some additional features such as foreign key support without requiring complex configuration.                   
                    The main disadvantage of PostgreSQL is that it can be slower in performance than other databases such as MySQL. It is also slightly less popular than MySQL.
                    For more information about PostgreSQL including installation instructions, read this 
                    <a href="https://www.postgresql.org/" target="_blank">article</a>.</li>
                    <p class="center"><strong>Postgre Implementation:</strong></p>
                    <button id="showCode49" onclick="showCode('displayCode49', 'showCode49')">Display</button>
                    <div id="displayCode49">
                        <button onclick="closeCode('displayCode49', 'showCode49')">Close</button>
                        <li>In order to run and use Postgres on your own computer, you will need to <strong>set up both 
                        a Postgres server and a client.</strong></li>
                        <li><strong>Setting Up PostgreSQL (server): </strong>
                        Installation 
                        <a href="https://www.postgresql.org/download/windows/" target="_blank">here</a>.
                        You’ll be prompted to enter in a password for the postgres user: for now, set the password 
                        as “postgres”. If you are asked to enter a port, you can use the default of “5432”.
                        After completing the installation, you may be asked whether you would like to use Stack 
                        Builder to install additional software. You shouldn’t need to install anything else for now.</li>
                        <li><strong>Setting up PostgresSQL (client): </strong>
                        Now that Postgres is running locally, we can connect to it via a “client” – a graphical or 
                        command-line interface that enables us to connect to the Postgres server, write and execute 
                        SQL commands as input, and see the resulting output.
                        While you can have only one instance of Postgres running per port (typically 5432), you 
                        can have multiple open connections to the same database with different interfaces. 
                        There are many options; our preferences are listed below. <strong>Instructions and project 
                        to set-up Postgree Locally</strong>
                        <a href="https://content.codecademy.com/programs/data-engineering-postgres/Movies_Off_Platform_Project/Movies_Off_Platform_Project.zip" target="_blank">here</a>.</li>
                        <ul>
                            <li><strong>GUI: </strong>Our preference for a cross-platform software to visually 
                            interact with Postgres is <a href="https://github.com/Paxa/postbird" target="_blank">Postbird</a>.
                            A strong runner up is <u>PgAdmin</u>, one of the most popular and feature-rich open source 
                            administration and development platforms for Postgres.                        
                            Postbird will automatically open, and from there you can enter in the username (postgres) and password 
                            (postgres) to connect to your locally running Postgres instance.
                            From there you can now use Postbird to start writing SQL queries. You can select the database you want to 
                            work in using the dropdown menu in the top left corner, you can add tables to that database using the plus 
                            sign in the bottom left corner, and you can use the query tab to write SQL queries to manipulate and investigate
                            tables that you create!
                        </li>
                            <li><strong>Command Line: </strong>
                            You can also connect using the command line tool <a href="https://www.postgresql.org/docs/9.3/app-psql.html" target="_blank">psql</a>.</li>
                        </ul>
                        <hr/>
                    </div>
                    <li><strong>Oracle DB: </strong>Oracle Corporation owns Oracle Database, and the code is not open sourced.
                    Oracle DB is for large applications, particularly in the banking industry. Most of the world’s 
                    top banks run Oracle applications because Oracle offers a powerful combination of technology and 
                    comprehensive, pre-integrated business applications, including essential functionality built specifically for banks.                   
                    The main disadvantage of using Oracle is that it is not free to use like its open source 
                    competitors and can be quite expensive.</li>
                    <li><strong>SQL Server</strong>
                    Microsoft owns SQL Server. Like Oracle DB, the code is close sourced.                   
                    Large enterprise applications mostly use SQL Server.
                    Microsoft offers a free entry-level version called Express 
                    but can become very expensive as you scale your application.</li> 
                    <li><strong>SQLite</strong> is a popular open source SQL database. It can store an entire database 
                    in a single file. One of the most significant advantages this provides is that all of the data can be stored locally without having to connect your database to a server.
                    SQLite is a popular choice for databases in cellphones, PDAs, MP3 players, set-top boxes, and 
                    other electronic gadgets. The SQL courses on Codecademy use SQLite.                   
                    For more info on SQLite, including installation instructions, read this article.</li>
                </ul>
                <li>More info:</li>
                <ul>
                    <li><strong>Material</strong> <a href="https://www.codecademy.com/resources/docs/general/relational-database?page_ref=catalog" target="_blank">here</a>.</li>
                    <li><strong>Tool</strong> for easy online testing and sharing of database problems and their solutions 
                        <a href="http://sqlfiddle.com/" target="_blank">here</a>.
                    </li>
                    <li>
                        <strong>Guidelines</strong> for SQL use
                        <a href="https://gist.github.com/fredbenenson/7bb92718e19138c20591#file-kickstarter_sql_style_guide-md" target="_blank"> here</a>.
                    </li>
                </ul>
                <p class="center"><strong>Creating, Querying & Manipulating Tables:</strong></p>
                <button id="showCode47" onclick="showCode('displayCode47', 'showCode47')">Display</button>
                <div id="displayCode47">
                    <button onclick="closeCode('displayCode47', 'showCode47')">Close</button>
                    <li><strong>List of SQL Commands</strong> <a href="https://www.codecademy.com/article/sql-commands" target="_blank">here</a>.</li>
                    <hr/>
                    <li><strong>Creating Tables</strong></li>
                    <ul>
                        <li><strong>Creating Table Video Implementation</strong> <a href="https://www.youtube.com/watch?v=nwLV5Txc8jM&embeds_euri=https%3A%2F%2Fwww.codecademy.com%2F&embeds_origin=https%3A%2F%2Fwww.codecademy.com&source_ve_path=MjM4NTE&feature=emb_title" target="_blank">here</a>.</li>
                        <li><strong>Statements:</strong>
                        The code below is a SQL statement. A statement is text that the database recognizes as a 
                        valid command. Statements always end in a semicolon <i>;</i>.</li>
                        <pre>
                            <code>
                CREATE TABLE table_name (
                    column_1 data_type, 
                    column_2 data_type, 
                    column_3 data_type
                );

                //Example
                CREATE TABLE book (
                    title varchar(100),
                    isbn varchar(50) PRIMARY KEY,
                    pages integer,
                    price money,
                    description varchar(256),
                    publisher varchar(100)
                );

                //Create table from existing columns
                    (It's easier to create in first place) 
                CREATE TABLE majors AS
                SELECT distinct major_1, major_1_credits_reqd
                FROM college;

                //Then DROP the previous college columns
                    We just need a cross-reference 
                    between tables
                ALTER TABLE college
                DROP COLUMN major_1, 
                DROP COLUMN major_1_credits_reqd;
                            </code>
                        </pre>
                        <ol>
                            <li><strong>CREATE TABLE</strong> is a clause.  
                            Clauses perform specific tasks in SQL. By convention, clauses are 
                            written in capital letters. Clauses can also be referred to as commands.
                            CREATE TABLE tells SQL you want to create a new table.</li>
                            <li><strong>table_name</strong> refers to the name of the table that the command is 
                            applied to.</li>
                            <li><strong>(column_1 data_type, column_2 data_type, column_3 data_type)</strong> 
                            is a parameter. A parameter 
                            is a list of columns, data types, or values that are passed to a clause as an argument. 
                            Here, the parameter is a list of column names and the associated data type.</li>
                        </ol>
                    </ul>
                    <hr/>
                    <li><strong>Querying Tables</strong></li>
                    <ul>
                        <li><strong>Querying Table Video Implementation</strong> <a href="https://www.youtube.com/watch?v=gQ58W7v8qyA&ab_channel=Codecademy" target="_blank">here</a>.</li>
                        <li><strong>SELECT</strong> statements are used to fetch data from a database:</li>
                        <pre>
                            <code>
                SELECT name FROM celebs;

                //We can select individual columns by their names (separated by a comma):
                SELECT column1, column2 
                FROM table_name;

                //WHERE & LIKE
                SELECT * FROM movies
                WHERE name LIKE 'Se_en';

                //CASE & WHEN
                SELECT name,
                    CASE
                        WHEN imdb_rating > 8 THEN 'Fantastic'
                        WHEN imdb_rating > 6 THEN 'Poorly Received'
                        ELSE 'Avoid at All Costs'
                    END AS 'Review'
                FROM movies;

                SELECT name AS 'Titles'
                FROM movies;

                //Multiple aliases
                SELECT course_id AS "Course ID", exercise_id AS "Exercise ID" FROM bugs;

                SELECT tools FROM inventory;
                //might produce: tools, Hammer, Nails, Nails, Nails
                //By adding DISTINCT before the column name,
                SELECT DISTINCT tools FROM inventory;
                //the result would now be: tools, Hammer, Nails
                            </code>
                        </pre>
                        <ol>
                            <li><strong>SELECT</strong> is a clause that indicates that the statement is a query. You will use SELECT every 
                            time you query data from a database. SELECT statements always return a new table called the result set.</li>
                            <li>name specifies the column to query data from (we can use * to select every column in a table).</li>
                            <li><strong>FROM</strong> celebs specifies the name of the table to query data from. In this statement, data is 
                            queried from the celebs table.</li>
                            <li>You can add a WHERE clause to filter your results. For example, adding WHERE 
                            release_year = 1999 to the end of your SELECT statement will find all of the movies
                            released in 1999. We can combine multiple conditions in a WHERE clause 
                            to make the result set more specific and useful, one way of doing this is to use 
                            the <strong>AND</strong> & <STRONG>OR</STRONG>operator (we can combine both).
                            <strong>AND</strong> operator displays a row if all the conditions are true.
                            <strong>OR</strong> operator displays a row if any condition is true.</li>
                            <li><strong>LIKE</strong> is a special operator used with the WHERE clause to search for a specific 
                            pattern in a column. name LIKE 'Se_en' is a condition evaluating the name column for a specific pattern.
                            Se_en represents a pattern with a wildcard character.
                            The _ means you can substitute any individual character here without breaking the pattern.
                            <i>%</i> is a wildcard character that matches zero or more missing letters in the pattern. For example:
                            A% matches all movies with names that begin with letter ‘A’
                            %a matches all movies that end with ‘a’
                            We can also use % both before and after a pattern.</li>
                            <li><strong>BETWEEN</strong> sets a condition between two values.</li>
                            <li><strong>ORDER BY</strong> sorts the results either alphabetically or numerically.
                            <strong>DESC</strong> is a keyword used in ORDER BY to sort the results in descending order (high to low or Z-A).
                            <strong>ASC</strong> is a keyword used in ORDER BY to sort the results in ascending order (low to high or A-Z).</li>
                            <li>LIMIT is a clause that lets you specify the maximum number of rows the result set will have. This saves space on 
                            our screen and makes our queries run faster. LIMIT always goes at the very end of the query.</li>
                            <li>A <strong>CASE</strong> statement allows us to create different outputs (usually in the SELECT statement). 
                            It is SQL's way of handling if-then logic. 
                            Each <strong>WHEN</strong> tests a condition and the following THEN gives us the string if the condition is true.
                            The <strong>ELSE</strong> gives us the string if all the above conditions are false.
                            The CASE statement must end with <strong>END</strong>. To shorten it, we can rename the column to ‘Review’ using AS</li>
                            <li><strong>AS</strong> is a keyword in SQL that allows you to rename a column or table using an alias. The new 
                            name can be anything you want as long as you put it inside of single quotes.
                            When using AS, the columns are not being renamed in the table. The aliases only appear in the result.</li>
                            <li><strong>DISTINCT</strong> is used to return unique values in the output. It filters out 
                            all duplicate values in the specified column(s). For instance:</li>
                        </ol>         
                    </ul>
                    <hr/>
                    <li><strong>Manipulating Tables</strong></li>
                    <ul>
                        <li>The <strong>INSERT</strong> statement inserts a new row into a table.
                        (id, name, age) is a parameter identifying the columns that data will be inserted into.
                        <strong>VALUES</strong> is a clause that indicates the data being inserted.</li>
                        <pre>
                            <code>
                INSERT INTO celebs (id, name, age)
                VALUES (1, 'Justin Bieber', 22);

                //For multiple insertion
                INSERT INTO table (col1, col2, col3)
                VALUES
                (row1_val1, row1_val2, row1_val3),
                (row2_val1, row2_val2, row2_val3),
                (row3_val1, row3_val2, row3_val3);
                            </code>
                        </pre>
                        <ul>
                            <li><strong>INSERT INTO nested tables</strong>:
                                You can use a single SQL statement to insert the data into both the parent and child 
                                tables using the RETURNING clause to retrieve the generated ID. For example:</li>
                            <pre>
                                <code>
            WITH new_address AS (
                INSERT INTO addresses (street, city, state, country)
                VALUES ('123 Main St', 'Anytown', 'CA', 'USA')
                RETURNING id
                )
                INSERT INTO users (name, email, address_id)
                VALUES ('John Doe', 'jdoe@example.com', (SELECT id FROM new_address));          
                                </code>
                            </pre>
                        </ul>
                        <li>The <strong>ALTER TABLE:</strong> statement adds a new column to a table. You can use this command 
                        when you want to add columns to a table.
                        The ALTER statement is used to modify columns. With ALTER, you can add columns, remove them, 
                        or even modify them.</li>
                        <ul>
                            <pre>
                                <code>
                    //Add column
                    ALTER TABLE celebs 
                    ADD COLUMN twitter_handle TEXT;

                    //Rename column                
                    ALTER TABLE table_name
                    RENAME COLUMN old_name TO new_name;
                                </code>
                            </pre>
                            <li><strong>ADD COLUMN</strong> is a clause that lets you add a new column to a table:</li>
                            <ul>
                                <li>twitter_handle is the name of the new column being added</li>
                                <li>TEXT is the data type for the new column</li>
                            </ul>
                            <li>NULL is a special value in SQL that represents missing or unknown data. Here, the 
                            rows that existed before the column was added have NULL (∅) values for twitter_handle.</li>
                        </ul>
                        <li>The <strong>UPDATE</strong> statement edits a row in a table. You can use the UPDATE statement when you 
                        want to change existing records.
                        The UPDATE statement is used to modify rows. However, UPDATE can only update a row, and cannot 
                        remove or add rows.</li>
                        <ul>
                            <pre>
                                <code>
                UPDATE celebs 
                SET twitter_handle = '@taylorswift13' 
                WHERE id > 4; 
                                </code>
                            </pre>
                            <li>SET is a clause that indicates the column to edit.</li>
                            <ul>
                                <li>twitter_handle is the name of the column that is going to be updated</li>
                                <li>@taylorswift13 is the new value that is going to be inserted into the twitter_handle column.</li>
                            </ul>
                            <li><strong>WHERE</strong> is a clause that indicates which row(s) to update with the new 
                            column value. Here the row with a 4 in the id column is the row that will have the twitter_
                            handle updated to @taylorswift13.</li>
                        </ul>
                        <li>The <strong>DELETE FROM</strong> statement deletes one or more rows from a table. You can use the 
                        statement when you want to delete existing records. The statement below deletes all 
                        records in the celebs table with no twitter_handle:</li>
                        <ul>
                            <pre>
                                <code>
                DELETE FROM celebs 
                WHERE twitter_handle IS NULL;

                DELETE FROM employees
                WHERE employee_id IS NOT NULL;
                                </code>
                            </pre>
                            <li><strong>WHERE</strong> is a clause that lets you select which rows you want to delete. Here we want to delete all of the rows where the twitter_handle column IS NULL.</li>
                            <li><strong>IS NULL</strong> is a condition in SQL that returns true when the value is NULL and false otherwise.
                            There's also <strong> IS NOT NULL</strong> </li>
                        </ul>
                        <li><strong>Constraints</strong> that add information about how a column can be used are invoked 
                        after specifying the data type for a column. They can be used to tell the database to reject 
                        inserted data that does not adhere to a certain restriction. The statement below sets 
                        constraints on the celebs table.</li>
                        <pre>
                            <code>
                CREATE TABLE celebs (
                    id INTEGER PRIMARY KEY, 
                    name TEXT UNIQUE,
                    date_of_birth TEXT NOT NULL,
                    date_of_death TEXT DEFAULT 'Not Applicable'
                );

                // If we don't need a constraint, we can
                   use DROP in place of SET                
                ALTER TABLE talks
                ALTER COLUMN session_timeslot SET NOT NULL;
   
                //BACKFILL table, so error doesn't occur.            
                UPDATE talks
                SET title = 'TBD'
                WHERE title IS NULL;

                //CHECK
                ALTER TABLE talks 
                ADD CHECK (estimated_length > 0 AND estimated_length < 120);

                //another CHECK example              
                ALTER TABLE attendees 
                ADD CHECK (standard_tickets_reserved + vip_tickets_reserved = total_tickets_reserved);

                //Delete Cascade for referenced Foreign keys
                ALTER TABLE registrations
                ADD FOREIGN KEY (talk_id)
                REFERENCES talks (id) ON DELETE CASCADE

                            </code>
                        </pre>
                        <ul>
                            <li><strong>PRIMARY KEY</strong> columns can be used to uniquely identify the row. Attempts to insert a 
                            row with an identical value to a row already in the table will result in a constraint 
                            violation which will not allow you to insert the new row.</li>
                            <li><strong>UNIQUE</strong> columns have a different value for every row. This is similar to 
                            PRIMARY KEY except a table can have many different UNIQUE columns.</li>
                            <li><strong>NOT NULL</strong> columns must have a value. Attempts to insert a row without a value for a 
                            NOT NULL column will result in a constraint violation and the new row will not be inserted.</li>
                            <li><strong>CHECK</strong> statements can be used to implement more precise constraints on our table.
                            In some situations, we might want to establish specific rules to determine what makes a row valid.
                            A CHECK constraint can be written into a CREATE TABLE statement, or added to an existing table with 
                            ALTER TABLE.
                            As a general rule, any logic that you might use in a WHERE statement to filter 
                            individual rows from an existing table can be applied within a CHECK</li>
                            <li><strong>FOREIGN KEY</strong>
                            Values inserted into child table must be validated by data that’s already present in a parent table.
                            Formally, this property that ensures data can be validated by referencing another table in the data model 
                            is called referential integrity. Referential integrity can be enforced by adding a FOREIGN KEY on the child 
                            table that references the primary key of a parent table.
                            By default, a foreign key constraint will prevent an engineer from deleting or updating a row of a parent table 
                            that is referenced by some child table. This behavior is sometimes explicitly specified in a CREATE TABLE statement 
                            using REFERENCES talks (id) ON DELETE RESTRICT or REFERENCES talks (id) ON UPDATE RESTRICT.
                            Another way is using <strong>CASCADE</strong> clause.
                            Rather than preventing changes, CASCADE clauses (ON UPDATE CASCADE, ON DELETE CASCADE) cause 
                            the updates or deletes to automatically be applied to any child tables- once we right that statement,
                            we're able to delete normally.</li>
                            <li><strong>DEFAULT</strong> columns take an additional argument that will be the assumed value for an 
                            inserted row if the new row does not specify a value for that column.</li>
                            <li>We can use <strong>ALTER TABLE</strong> statements to add or remove constraints from existing 
                            tables. If the table we’re attempting to add a constraint on doesn’t meet the constraint, 
                            an error will occur, but we  can backfill the table so that it does adhere to the constraint.
                            <strong>Backfilling</strong> is a term
                            occasionally used in DB engineering to refer to the process of adding or updating past 
                            values. In this case, we can fill our target column’s NULL values with a placeholder 
                            value using the query below.</li>
                        </ul>
                        <li><strong>Information schema</strong> is a database containing meta information about 
                        objects in the database including tables, columns and constraints. This schema provides users 
                        with read-only views of many topics of interest.
                        To determine if a column has been designated correctly as a primary key, we can query a 
                        special view, key_column_usage, generated from this database. This view identifies all 
                        columns in the current database that are restricted by some constraint such as primary 
                        key or foreign key.</li>
                        <pre>
                            <code>
                //Only table_name needs to be
                   written based on the database
                SELECT
                    constraint_name, table_name, column_name
                FROM
                    information_schema.key_column_usage
                WHERE
                    table_name = 'recipe';
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Auto-incrementing:</strong> Many times we need to automatically increment a 
                    column, for example an id, so we don't need to do it manually for each new insert.</li>
                    <pre>
                        <code>
            CREATE TABLE table_name(
                    id SERIAL
            );

            //Alter existing table to use auto-incrementing.
            // t = table, c = column                
            CREATE SEQUENCE "public"."t_c_seq" OWNED BY "public"."t"."c";
           
            ALTER TABLE "public"."t" ALTER COLUMN "c" SET DEFAULT nextval('"public"."t_c_seq"');
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Aggregates Functions</strong></li>
                    <ul>
                        <li><strong>Aggregating Functions Video Implementation I</strong> <a href="https://www.youtube.com/watch?v=-7fN2eWUTmI&ab_channel=Codecademy" target="_blank">here</a>.</li>
                        <li><strong>Aggregating Functions Video Implementation II</strong><a href="https://www.youtube.com/watch?v=CQA_c6nqLvw&ab_channel=Codecademy" target="_blank">here</a>.</li>   
                        <li>Calculations performed on multiple rows of a table are called aggregates.</li>
                        <ul>
                            <li><strong>COUNT():</strong> count the number of rows</li>
                            <pre>
                                <code>
                    SELECT COUNT(*)
                    FROM table_name;
                                </code>
                            </pre>
                            <li><strong>SUM():</strong> calculates the sum of the values in a column</li>
                            <pre>
                                <code>
                    SELECT SUM(downloads)
                    FROM fake_apps;
                                </code>
                            </pre>
                            <li><strong>MAX()/MIN():</strong> return the highest and lowest values in a column, respectively.</li>
                            <pre>
                                <code>
                    SELECT MAX(downloads)
                    FROM fake_apps;
                                </code>
                            </pre>
                            <li><strong>AVG():</strong> calculates  the average of the values in a column</li>
                            <pre>
                                <code>
                    SELECT AVG(downloads)
                    FROM fake_apps;
                                </code>
                            </pre>
                            <li><strong>ROUND():</strong> round the values in the column</li>
                            <pre>
                                <code>
                    SELECT ROUND(price, 0)
                    FROM fake_apps;
                                </code>
                            </pre>
                            <li><strong>GROUP BY: </strong>Oftentimes, we will want to calculate an aggregate for data with certain characteristics.
                            GROUP BY is a clause in SQL that is used with aggregate functions. It is used in collaboration with the SELECT 
                            statement to arrange identical data into groups.
                            Aggregate functions combine multiple rows together to form a single value of more meaningful information.
                            The GROUP BY statement comes after any WHERE statements, but before ORDER BY or LIMIT.</li>
                            <pre>
                                <code>
                    SELECT AVG(imdb_rating)
                    FROM movies
                    WHERE year = 1999;
                        
                    SELECT AVG(imdb_rating)
                    FROM movies
                    WHERE year = 2000;
                        
                    SELECT AVG(imdb_rating)
                    FROM movies
                    WHERE year = 2001;

                    //CAN BE WRITTEN AS
                    SELECT year,
                        AVG(imdb_rating)
                    FROM movies
                    GROUP BY year
                    ORDER BY year;
                                </code>
                            </pre>
                            <li>Sometimes, we want to <strong>GROUP BY</strong> a calculation done on a column.
                            SQL lets us use column reference(s) in our GROUP BY.</li>
                            <pre>
                                <code>
                    SELECT ROUND(imdb_rating), COUNT(name)
                    FROM movies
                    GROUP BY ROUND(imdb_rating)
                    ORDER BY ROUND(imdb_rating);
                    However, this query may be time-consuming to write and more prone to error.
                    
                    //The following query is equivalent to the one above
                    //The 1 refers to the first column in our 
                        SELECT statement, ROUND(imdb_rating).
                    SELECT ROUND(imdb_rating), COUNT(name)
                    FROM movies
                    GROUP BY 1
                    ORDER BY 1;

                    //1 refers to category, 2 refers to price
                    SELECT category, price,
                        AVG(downloads)
                    FROM fake_apps
                    GROUP BY 1, 2;
                                </code>
                            </pre>
                            <li><strong>HAVING: </strong>filters groups.
                            HAVING is very similar to WHERE. In fact, all types of WHERE clauses you learned about thus far can 
                            be used with HAVING.
                            <strong>WHERE</strong>When we want to limit the results of a query based on values of the individual rows.
                            <strong>HAVING</strong>When we want to limit the results of a query based on an aggregate property.</li>
                            <pre>
                                <code>
                SELECT year,
                    genre,
                    COUNT(name)
                FROM movies
                GROUP BY 1, 2
                HAVING COUNT(name) > 10;


                //GROUP BY & CASE
                SELECT CASE
                    WHEN url LIKE '%github.com%' THEN 'Github'
                    WHEN url LIKE '%medium.com%' THEN 'Medium'
                    WHEN url LIKE '%newyorktimes.com%' THEN 'New York Times'
                    ELSE 'NO URL'
                END AS 'SOURCE',
                COUNT(*) 
                FROM hacker_news
                GROUP BY 1;
                                </code>
                            </pre>
                            <li>SQLite Documentation about <strong>timestamps</strong> <a href='https://www.sqlite.org/lang_datefunc.html'>here</a></li>
                        </ul>
                    </ul>
                </div>
                <p class="center"><strong>Multiple Tables:</strong></p>
                <button id="showCode50" onclick="showCode('displayCode50', 'showCode50')">Display</button>
                <div id="displayCode50">
                    <button onclick="closeCode('displayCode50', 'showCode50')">Close</button>
                    <li><strong>Introduction</strong></li>
                    <ul>
                        <li>In order to efficiently store data, we often spread related information across <strong>multiple tables</strong>.
                        For instance, imagine that we’re running a magazine company where users can have different types 
                        of subscriptions to different products. Different subscriptions might have many different properties. 
                        Each customer would also have lots of associated information.
                        We could have one table with all of the following information:</li>
                        <ul>
                            <li>order_id</li>
                            <li>customer_id</li>
                            <li>customer_name</li>
                            <li>customer_address</li>
                            <li>subscription_id</li>
                            <li>subscription_description</li>
                            <li>subscription_monthly_price</li>
                            <li>subscription_length</li>
                            <li>purchase_date</li>
                        </ul>
                        <li>However, a lot of this information would be repeated. If the same customer has multiple subscriptions, that customer’s name and address will be reported multiple times. If the same subscription type is ordered by multiple customers, then the subscription price and subscription description will be repeated. This will make our table big and unmanageable.
                        So instead, we can split our data into three tables:</li>
                        <ol>
                            <li><strong>orders</strong> would contain just the information necessary to describe what was ordered:</li>
                            <ul>
                                <li>order_id, customer_id, subscription_id, purchase_date</li>
                            </ul>
                            <li><strong>subscriptions</strong> would contain the information to describe each type of subscription:
                            <ul>
                                <li>subscription_id, description, price_per_month, subscription_length</li>
                            </ul>
                            <li><strong>customers</strong> would contain the information for each customer:</li>
                            <ul>
                                <li>customer_id, customer_name, address</li>
                            </ul>
                        </ol>
                    </ul>
                    <li><strong>Database Normalization </strong>is a concept that most programmers use to refer 
                    to restructuring a database in this manner. It's so that databases tables are structured to 
                    avoid data redundancy and keep the data accurate and consistent.
                    More info <a href="https://www.1keydata.com/database-normalization/" target="_blank">here</a>.
                    Introduction to database normalization<a href="https://mikehillyer.com/articles/an-introduction-to-database-normalization/" target="_blank">here</a>.</li>
                    <ul>
                        <li>Say for example, we added 1 million rows to this table. Some values like customer_address
                        might end up being stored many thousands of times, when we really only need to store it once 
                        per customer.
                        If we need the customer information, we can obtain it from the customers table, by their 
                        customer_id. And, if we need the information for a subscription, all of its information is 
                        stored in the subscriptions table. We only need the customer_id and subscription_id in the 
                        orders table, and we can obtain their information from their respective tables.</li>
                    </ul>
                    <li>A <strong>database key</strong> is a column or group of columns in a table 
                    that uniquely identifies a row in a table.</li>
                    <ul>
                        <li><strong>Primary keys: </strong>Each of these tables has a column that uniquely identifies each row of that table:
                        <strong>order_id</strong> for orders; <strong>subscription_id</strong> for subscriptions;
                        <strong>customer_id</strong> for customers. These special columns are called <strong>primary 
                        keys</strong>. Sometimes, none of the columns in a table can uniquely identify a record. When 
                        this happens, we can designate multiple columns in a table to serve as the primary key,
                        also known as a <strong>composite primary key.</strong> Primary keys have a few requirements:</li>
                        <ul>       
                            <li>None of the values can be NULL.</li>
                            <li>Each value must be unique (i.e., you can’t have two customers with the same customer_id in the customers table).</li>
                            <li>A table can not have more than one primary key column.</li>
                        </ul>
                        <pre>
                            <code>
                //Composite primary key
                CREATE TABLE popular_recipes (
                    recipe_id varchar(20),
                    ingredient_id varchar(20),
                    downloaded integer,
                    PRIMARY KEY (recipe_id, ingredient_id)
                );
                            </code>
                        </pre>
                        <li><strong>Foreign keys: </strong>When the primary key for one table appears in a different 
                        table, it is called a foreign key.
                        The most common types of joins will be joining a foreign key from one table with the primary 
                        key from another table. Generally, the primary key will just be called <i>id</i>. 
                        Foreign keys will have more descriptive names.
                        To designate a foreign key on a single column in PostgreSQL, we use the <strong>REFERENCES</strong> keyword.</li>
                        <pre>
                            <code>
                CREATE TABLE person (
                    id integer PRIMARY KEY,
                    name varchar(20),
                    age integer
                );
                
                CREATE TABLE email (
                    email varchar(20) PRIMARY KEY,
                    person_id integer REFERENCES person(id),
                    storage integer,
                    price money
                );
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Database Relationship</strong></li>
                    <ul>
                        <li><strong>One-to-one relationship: </strong> A row of table A is associated with exactly 
                        one row of table B and vice-versa. 
                        Use a foreign key to the referenced table.
                        To enforce a strictly one-to-one relationship in PostgreSQL, we need another keyword, UNIQUE. 
                        By appending this keyword and adding repeated rows, it will throw an error.
                        </li>
                        <pre>
                            <code>
                                CREATE TABLE driver (
                                    license_id char(20) PRIMARY KEY,
                                    name varchar(20),
                                    address varchar(100),
                                    date_of_birth date
                                );      
                                 
                                CREATE TABLE license (
                                    id integer PRIMARY KEY,
                                    state_issued varchar(20),
                                    date_issued date,
                                    date_expired  date,
                                    license_id char(20) REFERENCES driver(license_id) UNIQUE
                                ); 
                            </code>
                        </pre>
                        <li><strong>One-to-Many Relationship: </strong>
                        Analogous to a parent-child relationship where a parent can have multiple children, a parent table will house 
                        a primary key and the child table will house both primary and foreign keys. The foreign key binds the child 
                        table to the parent table. A one-to-many relationship exists when one row in a table links to many rows in another table.
                        Use a foreign key on the many side of the relationship linking back to the "one" side:</li>
                        <li><strong>Many-to-Many Relationship: </strong>
                        Many-to-many relationship can be broken into two one-to-many relationships.
                        To implement a many-to-many relationship in a relational database, we would create a third 
                        cross-reference table also known as a <strong>join table</strong>. It will have these two constraints:
                        <u>foreign keys</u> referencing the primary keys of the two member tables.
                        a <u>composite primary key</u> made up of the two foreign keys.
                        </li>
                    </ul>
                    <hr/>
                    <ul>
                        <li><strong>Joining: </strong>If we just look at the orders table, we can’t really tell 
                        what’s happened in each order. However, if we refer to the other tables, we can get a 
                        complete picture.</li> 
                        <ul>
                            <li>E.g: Related to order_id, we find a customer_id, 
                            that has a customer_name stored in the customer table;</li>
                            <li>E.g: Within order_id, we find the related subscritpion_id. Inside the 
                            subscription table we reach the description from that subscription_id.</li>
                        </ul>
                        <li><strong>JOIN:</strong> Combining tables manually is time-consuming. SQL gives 
                        us an easy sequence to join tables: JOIN.
                        When we perform a simple JOIN (often called an inner join) 
                        our result only includes rows that match our ON condition.
                        if we want to combine two tables and keep un-matched rows,
                        we use <strong>LEFT JOIN</strong>. A left join will keep all rows from the first table, 
                        regardless of whether there is a matching row in the second table,
                        but will omit the un-matched row from the second table.</li>
                        <pre>
                            <code>
                SELECT * 
                FROM orders
                JOIN customers
                    ON orders.customer_id = customers.customer_id;


                //if we only wanted to select orders table's 
                    order_id column and customers table's 
                    customer_name column:

                SELECT orders.order_id,
                    customers.customer_name
                FROM orders
                JOIN customers
                    ON orders.customer_id = customers.customer_id;

                //JOIN Multiple
                SELECT 
                    AVG(people.weight), 
                    teams.name, 
                    batting.yearid 
                FROM people 
                INNER JOIN batting 
                    ON people.playerid = batting.playerid
                INNER JOIN teams
                    ON batting.team_id = teams.id
                GROUP BY 
                    teams.name,
                    batting.yearid
                ORDER BY
                    AVG(people.weight) 
                    DESC;

                //LEFT JOIN
                SELECT *
                FROM table1
                LEFT JOIN table2
                    ON table1.c2 = table2.c2;
                            </code>
                        </pre>
                        <ul>
                            <li>The first line selects all columns from our combined table. If we only want to select 
                            certain columns, we can specify which ones we want.</li>
                            <li>The second line specifies the first table that we want to look in, orders</li>
                            <li>The third line uses JOIN to say that we want to combine information from 
                            orders with customers.</li>
                            <li>The fourth line tells us how to combine the two tables. We want to match orders 
                            table’s customer_id column with customers table’s customer_id column.</li>
                        </ul>
                        <li><strong>CROSS JOIN: </strong>Sometimes, we just want to combine all rows of one table with all rows of another table.
                        A more common usage of CROSS JOIN is when we need to compare each row of a table to a list of values.
                        For instance, if we had a table of shirts and a table of pants, we might want to know all the possible combinations to create different outfits. 
                        Our code might look like this:</li>
                        <pre>
                            <code>
                SELECT shirts.shirt_color, pants.pants_color
                FROM shirts
                CROSS JOIN pants;
                            </code>
                        </pre>
                        <ul>
                            <li>The first two lines select the columns shirt_color and pants_color.</li>
                            <li>The third line pulls data from the table shirts.</li>
                            <li>The fourth line performs a CROSS JOIN with pants.</li>
                        </ul>
                        <li><strong>UNION</strong> operator allows us to stack one dataset on top of the other. 
                        SQL has strict rules for appending data:
                        Tables must have the same number of columns.
                        The columns must have the same data types in the same order as the first table.
                        Duplicate rows will be excluded. If, however, you want to include duplicates, certain versions 
                        of SQL provides the UNION ALL operator.</li>
                        <pre>
                            <code>
                SELECT *
                FROM table1
                UNION
                SELECT *
                FROM table2;
                            </code>
                        </pre>
                        <li>Often times, we want to combine two tables, but one of the tables is the result of another calculation.
                        The <strong>WITH</strong> statement allows us to perform a separate query (such as aggregating customer’s subscriptions)
                        previous_results is the alias that we will use to reference any columns from the query inside of the WITH clause.
                        We can then go on to do whatever we want with this temporary table (such as join the temporary table with another table)
                        Essentially, we are putting a whole first query inside the parentheses () and giving it a name. After that, we can use 
                        this name as if it’s a table and write a new query using the first query.
                        You can use WITH for more than one nested query using commas after the WITH.</li>
                        <pre>
                            <code>
                WITH previous_results AS (
                    SELECT ...
                    ...
                    ...
                    ...
                )
                SELECT *
                FROM previous_results
                JOIN customers
                ON _____ = _____;
                            </code>
                        </pre>
                        <li><strong>Associating Tables: </strong>
                        We have a person table and an email table, where a person can have many email addresses, but 
                        an email address can only belong to one person. To implement this type of relationship, we 
                        need to apply a constraint on the email table by adding another column to it and designating 
                        it to associate with the person table.

                        Let’s say we have a hobby table as well and populate it with all kinds of hobbies. If we try 
                        to query both the hobby and person tables, how do we know for sure that a hobby is tied to a 
                        particular person? There is nothing in the person table that links it to a hobby.

                        To associate a hobby with a person, we need to relate the person table to the hobby table 
                        with the type of relationship they have. Can a person have only one hobby or multiple hobbies?
                        Can a hobby apply to only one person or can it be shared by multiple people?</li>
                    </ul>
                    <hr/>
                </div>
                <hr/>
                <li><strong>Database Trigger: </strong>
                Is procedural code that is automatically executed in response to certain events on a particular 
                table or view in a database. The trigger is mostly used for maintaining the integrity of the information 
                on the database. When you want something to happen every time someone makes a specific change to a table 
                or view, a trigger is placed on that table or view. That trigger will call a function when the conditions 
                for the trigger are met - triggers run in alphabetic order from their names. Adding a trigger saves people from forgetting to do that action, and ensures consistent rules are applied.
                Triggers are very customizable. You have control over when they get called, when they run, along with what 
                happens when they are called. There are two common options: BEFORE and AFTER.</li>
                <p class="center"><strong>Database Trigger:</strong></p>
                <button id="showCode51" onclick="showCode('displayCode51', 'showCode51')">Display</button>
                <div id="displayCode51">
                    <button onclick="closeCode('displayCode51', 'showCode51')">Close</button>
                    <li><strong>BEFORE</strong> calls your trigger before the query that fired the trigger runs.</li>
                    <li><strong>AFTER</strong> occurs once the query finishes its work.
                    This is quite useful for logging purposes, such as inserting into an audit table 
                    to track who did a change and when.</li>
                    <pre>
                        <code>
            //Newer versions of Postgre
                may use EXECUTE FUNCTION instead.
            CREATE TRIGGER < trigger_name >
                BEFORE UPDATE ON < table_name >
                FOR EACH ROW
                EXECUTE PROCEDURE< function >;
                        </code>
                    </pre>
                    <li><strong>FOR EACH ROW:</strong> The trigger will fire and call the function for every row that is 
                    impacted by the related query - therefore is called once for every row modified.
                    The other option is to have it set to FOR EACH STATEMENT.</li> 
                    <li><strong>FOR EACH STATEMENT: </strong> 
                    calls the function in the trigger once for each query, not for each record -
                    executes once for the entire operation (0 modified rows would still trigger this).</li>
                    <li>You can use a WHEN clause to filter when a trigger calls its related function.
                    You can use NEW and OLD to get records from the table before and after the query. Logically, INSERT 
                    can not refer to OLD (nothing existed before the insert) and DELETE can not refer to NEW (nothing 
                    exists after the delete).</li>
                    <pre>
                        <code>
                            CREATE TRIGGER < trigger_name >
                                BEFORE UPDATE ON < table_name >
                                FOR EACH ROW
                                WHEN (NEW.< column_name > < 13)
                                EXECUTE PROCEDURE < procedure_name >();
                        </code>
                    </pre>
                    <li><strong>DROP TRIGGER</strong> removes a trigger.</li>
                    <pre>
                        <code>    
        DROP TRIGGER < trigger_name > 
            ON < table_name >;</li>
                        </code>
                    </pre>
                    <li>To find what triggers exists, you can use <strong>information_schema.triggers</strong></li>
                    <pre>
                        <code>
        SELECT * FROM information_schema.triggers;
                        </code>
                    </pre>
                </div>
                <hr/>
                <li><strong>Designing</strong> Relational Databases</li>
                <ul>
                    <li><strong>Database Schema: </strong>Like an architectural blueprint, a database schema is documentation that helps its audience 
                    such as a database designer, administrator and other users interact with a database. It gives 
                    an overview of the purpose of the database along with the data that makes up the database, 
                    how the data is organized into tables, how the tables are internally structured and how they 
                    relate to one another. 
                    An <strong>Entity Relationship Diagram</strong>, or ERD, is a method of diagramming a database with a little more 
                    description put into it to allow a designer to better understand the database and the relationships 
                    between the tables - more info <a href="https://www.lucidchart.com/pages/er-diagrams#section_5" target="_blank">here</a>.</li>
                </ul>
                <p class="center"><strong>How to design:</strong></p>
                <button id="showCode52" onclick="showCode('displayCode52', 'showCode52')">Display</button>
                <div id="displayCode52">
                    <button onclick="closeCode('displayCode52', 'showCode52')">Close</button>
                    <li>When designing a database schema consider the following steps:</li>
                    <ul>
                        <li><strong>Define the purpose</strong> of your database</li>
                        <li><strong>Find the information</strong> that make up the database</li>
                        <li><strong>Organize</strong> your information into <strong>tables</strong></li>
                        <li><strong>Structure</strong> your tables into columns of information</li>
                        <li><strong>Avoid redundant data</strong> that leads to inaccuracy and waste in space</li>
                        <li><strong>Identify the relationships</strong> between your tables and implement them.</li>
                    </ul>
                    <li><strong>Three Tier Architecture:</strong> When discussing a new application or program that will be built, the number of tiers an 
                    application will need is going to likely be discussed. A tier is used to help separate the 
                    different processes that will be used within an application. This can be through the use of 
                    different tech stacks or by simply dividing into separate teams for each tier. These tiers are 
                    easier to understand after viewing a few examples which will be seen later in the article.
                    The three tiers are: </li> 
                    <ul>
                        <li><strong>Presentation tier: </strong>
                        This tier is the one most people will be familiar with as it represents items such as 
                        the user interface or GUI. It represents how the user will interact with the application.
                        This tier consists mostly of markup languages including HTML, JavaScript, and CSS,
                        This is because this tier is mainly for presenting and gathering information from the user, 
                        and less about processing the data in this tier.</li>
                        <li><strong>Data tier: </strong>
                        This is the tier that stores all of the data. Data at this level is not manipulated and is 
                        strictly for storage. This is usually just a database to store the data on. The data tier can 
                        only interact with the application tier, and is unable to communicate directly to the 
                        presentation tier. This is because of the fact that the data tier is strictly for storage and 
                        not manipulation. The data tier of applications is usually a database, meaning that services 
                        like SQL, MongoDB, and PostgreSQL are used to create the database and assist with querying later.
                        However, any querying done to the database is not considered to be a part of the data tier and is 
                        instead a part of the application tier.</li>
                        <li><strong>Application tier: </strong>
                        This is where the bulk of the application will go. This tier will deal with processing data 
                        gathered from the presentation tier and modifies the data within the data tier. It acts like a 
                        bridge connecting the two other tiers.  
                        For example, the application tier represents the process performed when you first opened an website's article. 
                        The data for a article is grabbed from the data tier and then converted into a form you 
                        can see in the presentation tier. The middle work between the two tiers is all done in the 
                        application tier.
                        Most of the work performed inside of the application tier will be done in programming languages 
                        such as Java, Python, Perl, and other popular programming languages. This is because they are 
                        best at manipulating the data into a number of different forms.</li>
                    </ul>
                    <li>An application can have as many tiers as wanted. 
                    Two tiered can hold only presentation and data tiers (it can be used for very simplistic websites).
                    More than three tiers can be used (but as more tiers are added though, it can become harder to maintain the project 
                    and can even slow it down due to all of the tiers the project has to manage).
                    A three tiered application is a nice middle ground for building a project. It allows for complex 
                    applications without slowing down the application. Through the use of a presentation tier, 
                    application tier, and data tier, full projects can be built and managed with different teams. 
                    The different tiers also help allow for improved scalability for when an application grows and is 
                    easier to manage than higher tiered application.</li>
                    <li><strong>Free online database design tools:</strong></li>
                    <ul>
                        <li><a href="https://dbdiagram.io/home" target="_blank">DbDiagram.io</a> is simple tool to 
                        draw ER diagrams by just writing code, designed for developers and data analysts.</li>
                        <li><a href="https://sqldbm.com/home" target="_blank">SQLDBM</a> is a SQL Database Modeler</li>
                        <li><a href="https://www.dbdesigner.net/" target="_blank">DB Designer</a> is a online database schema design and modeling tool</li>
                        <li><a href="https://www.lucidchart.com/pages/" target="_blank">Lucidchart</a> 
                        is the intelligent diagramming application that brings teams together to make better 
                        decisions and build the future.</li>
                    </ul>
                    <li><strong>More info: </strong></li>
                    <ul>
                        <li>Video information database-design <a href="https://www.youtube.com/watch?v=h0j0QN2b57M&list=PL_c9BZzLwBRK0Pc28IdvPQizD2mJlgoID&index=2" target="_blank">here</a></li>
                    </ul>
                    <li><strong>Users table: </strong>The columns that are usually put in a users table 
                    depend on the specific requirements of the Application
                    Some applications may require additional columns, such as a user's role, account status,
                    or other information relevant to the application. Some common columns that are often 
                    included are:</li>
                    <ul>
                        <li><strong>id (primary key)</strong></li>
                        <li><strong>first_name</strong></li>
                        <li><strong>last_name</strong></li>
                        <li><strong>email</strong></li>
                        <li><strong>password (encrypted)</strong></li>
                        <li><strong>phone</strong></li>
                        <li><strong>address</strong></li>
                        <li><strong>city</strong></li>
                        <li><strong>state</strong></li>
                        <li><strong>zip_code</strong></li>
                        <li><strong>country</strong></li>
                        <li><strong>created_at</strong></li>
                        <li><strong>updated_at</strong></li>
                    </ul>
                    <li><strong>Orders table: </strong>An orders table typically contains the following columns:</li>
                    <ul>
                        <li><strong>order_id:</strong> a unique identifier for the order</li>
                        <li><strong>user_id:</strong> a reference to the user who placed the order</li>
                        <li><strong>order_date:</strong> the date and time when the order was placed</li>
                        <li><strong>order_status:</strong> the current status of the order (e.g. pending, fulfilled, cancelled)</li>
                        <li><strong>total_price:</strong> the total price of the order</li>
                        <li><strong>shipping_address:</strong> the shipping address associated with the order</li>
                        <li><strong>billing_address:</strong> the billing address associated with the order (if different from the shipping address)</li>
                        <li><strong>payment_method:</strong> the payment method used for the order (e.g. credit card, PayPal)</li>
                    </ul>
                    <li><strong>Items table: </strong> Additional columns may be added depending on the 
                    specific needs of the application. For example, if the application has a category or tags system, 
                    the items table may include a category_id or tags column to help with filtering 
                    and search. In a typical e-commerce application, an items table 
                    might include the following columns:</li>
                    <ul>
                        <li><strong>id:</strong> a unique identifier for each item</li>
                        <li><strong>name:</strong> the name of the item</li>
                        <li><strong>description:</strong> a description of the item</li>
                        <li><strong>price:</strong> the price of the item</li>
                        <li><strong>quantity:</strong> the number of the item in stock</li>
                        <li><strong>image_url:</strong> a URL for an image of the item</li>
                        <li><strong>created_at:</strong> the timestamp for when the item was added to the database</li>
                        <li><strong>updated_at:</strong> the timestamp for when the item was last updated in the database</li>
                    </ul>
                    <li><strong>orders_items table: </strong>An orders_items table is typically used as a 
                    many-to-many relationship between the orders and items tables.
                    These columns allow the orders_items table to represent the items included in each 
                    order, along with the quantity and price of each item.
                    It generally includes the following columns:</li>
                    <ul>
                        <li><strong>order_id:</strong> A foreign key that references the id column of the orders table.</li>
                        <li><strong>item_id:</strong> A foreign key that references the id column of the items table.</li>
                        <li><strong>quantity:</strong> The number of items of this type in the order.</li>
                        <li><strong>price:</strong> The price of the item at the time of purchase, which may be different from the current price.</li>
                        <li><strong>created_at:</strong> The date and time the item was added to the order.</li>
                        <li><strong>updated_at:</strong> The date and time the item was last updated.</li>
                    </ul>
                </div>
                <hr/>
                <li><strong>Database Permissions</strong></li>
                <ul>
                    <li>The postgres user (or any initial user) has the ability to create new databases, tables, 
                    users, etc. In PostgreSQL, the term for a user with these types of permissions is <strong>superuser</strong>. 
                    A superuser bypasses all permission checks that other users face before being allowed to perform 
                    an action. It's dangerous to let a user have access to everything, that's why we restrict their permission.</li>
                </ul>
                <p class="center"><strong>More about permissions:</strong></p>
                <button id="showCode53" onclick="showCode('displayCode53', 'showCode53')">Display</button>
                <div id="displayCode53">
                    <button onclick="closeCode('displayCode53', 'showCode53')">Close</button>
                    <li><strong>View list</strong></li>
                    <ul>
                        <li><strong>pg_catalog.pg_roles:</strong> A listing of all users in the database and a description
                        of what special permissions these users have.</li>
                        <li><strong>information_schema.table_privileges:</strong> Description of the permissions a user 
                        (grantee) has on a table. This table can be used to answer questions about who can SELECT, INSERT,
                        UPDATE, etc. values on a table.</li>
                    </ul>
                    <li><strong>Mimic Role: </strong>As a superuser, you can use <strong>SET ROLE</strong> to mimic the permissions of other users. 
                    For example, if a superuser runs <i>SET ROLE < test role ></i> and then attempts to perform an action 
                    that role couldn’t, they’d receive an error message indicating that they don’t have permission.
                    This behavior is identical to connecting to the database with that role from the start. 
                    As superuser, you can run <i>SET ROLE < superuser role ></i> to regain all superuser privileges.</li>
                    <pre>
                        <code>
                    //Check the name of the current user
                    SELECT current_user;

                    //information_schema.table_privileges
                    SELECT grantor, grantee, table_schema, table_name, privilege_type
                    FROM information_schema.table_privileges 
                    WHERE grantee = 'userB';
                        </code>
                    </pre>
                    <li><strong>CREATE ROLE: </strong>As a superuser, one of the permissions you have is the ability to create new roles. In PostgreSQL, 
                    roles can either be login roles or group roles. <strong>Login roles</strong> are used for most routine database 
                    activity. <strong>Group roles</strong> typically do not have the ability to login themselves, but can hold other 
                    roles as “members” and allow access to certain shared permissions.
                    List of permissions available for CREATE ROLE <a href="https://www.postgresql.org/docs/10/sql-createrole.html" target="_blank">here</a>.</li>
                    <pre>
                        <code>          
                //Create new role
                CREATE ROLE < name > WITH < list of permissions >;

                //Alter role
                ALTER ROLE miriam WITH CREATEDB
                        </code>
                    </pre>
                    <li><strong>Table level security: </strong><strong>GRANT</strong> and <strong>REVOKE</strong> are statements used to modify 
                    permissions at the schema and table level.
                    Every table or schema in a PostgreSQL database has an owner that can set the permissions on their 
                    tables. As a superuser or table or schema owner, you may use GRAND and REVOKE to achieve that.
                    To use a schema, a role must have a permission 
                    called <strong>USAGE</strong> - without USAGE a role cannot access tables within that schema. Other schema level 
                    permissions include <strong>CREATE</strong> and <strong>DROP</strong>, which allow the grantee the 
                    ability to create or remove tables in that schema respectively. 
                    To interact with a table, a role must have USAGE on the table’s schema. 
                    Additionally, a table owner must also grant <strong>SELECT</strong>, <strong>UPDATE</strong>, 
                    <strong>DELETE</strong>, <strong>INSERT</strong> etc. on a specific table 
                    to define how that role can interact with the table.
                    Let's examine what this looks like in practice. As the owner of the schema finance, perhaps you'd 
                    like to grant the ability to SELECT and UPDATE a table named finance.revenue to a user named analyst.
                    You could accomplish this with the following:</li>
                    <ul>
                        <li>First by <strong>granting USAGE</strong> on the schema. In this example, analyst is also granted the ability 
                        to CREATE new tables in the schema. <i>GRANT USAGE, CREATE ON SCHEMA finance TO analyst;</i></li>
                        <li>Then by <strong>granting</strong> the table <strong>specific permissions</strong>. 
                        <i>GRANT SELECT, UPDATE ON finance.revenue TO analyst;</i></li>
                        <li>Any GRANT statement can be reversed using quite similar syntax. First replacing GRANT with 
                        <strong>REVOKE</strong> and TO to FROM. For example, to revoke the ability to UPDATE given above, the owner of 
                        the table could use the following statement:
                        <i>REVOKE UPDATE ON finance.revenue FROM analyst;</i></li>
                        <li><strong>Default Permission: </strong>With it a superuser can set permissions to be updated 
                        automatically when new objects are created in a schema
                        (Default permissions can be used to set permissions at the database level as well).
                        The following statement would allow analyst to SELECT on all newly-created 
                        tables in finance immediately after another user has created them:</li>
                        <pre>
                            <code>
                        ALTER DEFAULT PRIVILEGES IN SCHEMA finance
                        GRANT SELECT ON TABLES TO analyst;
                            </code>
                        </pre>
                        <li><strong>Group Role: </strong>Alice, bob, and charlie can each be login roles, and they can 
                        also all be members of a group role called employees.
                        This is a useful feature for maintaining databases with many users, but only a few “types” of users.
                        One member can belong to more than one group role.
                        For security reasons, PostgreSQL disallows the inheritance of certain powerful permissions such
                        as LOGIN, SUPERUSER, CREATEDB, and CREATEROLE. There are several ways to create a new group role:</li>
                        <pre>
                            <code>
        // CREATE ROLE and the WITH ROLE 
            this automatically adds the listed names to the role
        CREATE ROLE marketing WITH NOLOGIN ROLE alice, bob;

        //CREATE ROLE and a GRANT statement
            grants all the permissions of the newly created 
            role to the listed names.
        CREATE ROLE finance WITH NOLOGIN;
        GRANT finance TO charlie;

        //You can also add users to group(s) 
            on creation by specifying 
        IN ROLE along with the CREATE ROLE statement
        CREATE ROLE fran WITH LOGIN IN ROLE employees, managers; 
                            </code>
                        </pre>
                        <li><strong>Column level security: </strong>PostgreSQL offers the ability to write GRANT statements that specify specific <strong>columns</strong> for a set 
                        of permissions to apply to. Consider the following example:</li>
                        <pre>
                            <code>
        GRANT SELECT (project_code, project_name, project_status) 
        ON projects to employees;

        //To display grant by column
        SELECT *
        FROM information_schema.column_privileges 
        WHERE grantee = 'manager';
                            </code>
                        </pre>
                        <li><strong>Row-level security (RLS): </strong>PostgreSQL feature  
                        that allows developers to define permissions on individual rows. To access (or modify) information from a 
                        table with RLS, a row-specific condition must be met. Information about RLS 
                        <a href="https://www.postgresql.org/docs/10/sql-createpolicy.html" target="_blank">here</a>.</li>
                        <pre>
                            <code>
                            //First, we create a policy using a CREATE POLICY statement.
                            CREATE POLICY emp_rls_policy ON accounts FOR SELECT 
                            TO sales USING (salesperson=current_user);

                            //Next, we need to enable RLS on the table the policy refers to.
                            ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;
                            </code>
                        </pre>
                    </ul>
                </div>
                <hr/>
                <li><strong>ACID </strong>(Atomic, Consistent, Isolated, and Durable): These properties help ensure that all the data in a 
                transaction is complete, accurate, and has integrity. These properties also assist in recovering databases in case of a system 
                failure and allows for concurrent use of a database.
                Any single unit of work done to the database is defined as a <strong>transaction</strong> - these transactions can often be 
                made up of multiple different steps, and most of the time represent changes made to the database.</li>
                <ul>
                    <li><strong>ATOM: </strong>“all changes to data are performed as if they are a single operation. That is, all the changes are performed, or none 
                    of them are.” This means that we treat each transaction as a single operation. If a single task in the transaction fails, 
                    then the entire transaction will fail. For example, let’s look at the following transaction</li>
                    <li><strong>Consistent: </strong>“Data is in a consistent state when a transaction starts and when it ends.”
                    Therefore, the transaction follows the rules from the database. E.g:
                    Inside of a banking application, whenever money is transferred from one account to another, we need to make sure that the no money was lost or 
                    added to the transaction. To do this, we would add the funds from both accounts together and store that value, transfer the money, 
                    then add the account values and check the initial value to make sure both are equal. </li>
                    <li><strong>Isolated: </strong>When working with multiple transactions that could occur at once, it is important to ensure that when one transaction 
                    is reading or writing from a location in to a database, no other transaction is reading or writing from that same location. This process is 
                    called isolation and is defined by IBM as “The intermediate state of a transaction is invisible to other transactions. As a result, 
                    transaction that run concurrently appear to be serialized.”
                    For example, if we had one transaction changing a row in a table, and another transaction trying to read data from that same table, 
                    these two transaction would not be able to operate at the same time. Instead, these transaction would execute one at a time.
                    This does not mean that we cannot perform multiple transactions at once. We can still have multiple transactions happen, it’s just 
                    that no two transactions can read or write from the same location at the same time. Otherwise, we could encounter issues where a 
                    transaction could use old data or a transaction could overwrite new data with old data.</li>
                    <li><strong>Durable: </strong>“after a transaction successfully completes, changes to data persist and are not undone, even in the 
                    event of a system failure.” These failures include instances of service outages and crashes. Durability can be achieved through a 
                    number of methods including change logs that are referenced whenever the database is restarted for whatever reason.</li>
                </ul>
                <hr/>
                <li><strong>SQL Injections </strong>
                Is a common vulnerability affecting applications that use SQL as their database language. A hacker can use 
                their knowledge of the SQL language to cleverly construct text inputs that modify the backend SQL query to their liking. 
                They can force the application to output private data or respond in ways that provide intel. <i>Union-Based Injections</i>,
                <i>Error-Based Injections</i>, <i>Boolean-Based Injections</i>, <i>Time-Based Injections</i>, <i>Out-of-Band SQL Injections</i></li>
                <ul>
                    <li><strong>SQL Injection Prevention: </strong>
                    There are two main methods for preventing injection attacks: <strong>sanitization</strong> and
                    <strong>prepared statements</strong>.</li>
                    <ul>
                        <li>Sanitization is the process of removing dangerous characters from user input. When it comes to SQL injections, 
                        we would want to escape dangerous characters such as: <i>' ; \--</i>
                        These sorts of characters can allow attackers to extend queries to output more data from a database.
                        While this does provide a layer of protection, this method isn’t perfect. If a user finds a way to bypass your 
                        sanitization process, they can easily inject data into your system.
                        Additionally, depending on your query, removing certain characters may have no effect! Therefore, this shouldn’t 
                        be your only defense mechanism.</li>
                        <li>Prepared Statements
                        Writing prepared statements in backend code is a common, reliable, and secure solution against SQL injections. 
                        Prepared statements are nearly foolproof.
                        How does it work? We provide the database the query we want to execute in advance. First, the database processes our 
                        query. Then we pass in the parameters/user input. Any input, regardless of whether the content has SQL syntax, is then 
                        treated only as a parameter and will not be treated as SQL code.
                        In addition to providing added security, prepared statements also make queries far more efficient.
                        Here is an example of what a prepared statement looks like in PHP web application backend code:</li>
                        <pre>
                            <code>
                        $username= $_GET['user'];
                        $stmt = $conn->prepare("SELECT * FROM Users WHERE name = '?'");
                        $stmt->bind_param("s", $username);
                        $stmt->execute();
                            </code>
                        </pre>
                    </ul>
                </ul>
                <hr/>
                <li><strong>Indexes:</strong> An index is an organization of the data in a table to help with performance when searching 
                and filtering records.
                It's a data structure that helps to speed up database queries by allowing the database to
                quickly locate the rows.
                A table can have zero, one, or many indexes.
                Indexing allows you to organize your database structure in such a way that it makes finding specific records much faster.
                In small databases this is negligible, but as the datasets get larger this becomes more significant.
                Indexes speed up searching and filtering, however, they slow down insert, update, and delete statements.
                One thing to consider using or not is whether searching will occur often enough to make the advantages worth the time and effort.</li>
                <p class="center"><strong>More about Indexes:</strong></p>
                <button id="showCode54" onclick="showCode('displayCode54', 'showCode54')">Display</button>
                <div id="displayCode54">
                    <button onclick="closeCode('displayCode54', 'showCode54')">Close</button>
                    <li><strong>Seek VS Scan: </strong>
                    Different names are used in differente databases. SQL Server uses Seek and Scan, PostgreSQL uses Scan, 
                    Index Scan and Bitmap Heap Scan. There are two major ways that a database searches for rows in a table/view when you 
                    run any query. This isn’t limited to SELECT statements — this applies to every type of query that needs to find specific 
                    rows. For example, in a database of orders, an UPDATE query for orders over $10k would need to search for those records.</li>
                    <ul>
                        <li><strong>Scan:</strong> Searches through every record in a database table/view to find the records being asked for.</li>
                        <li><strong>Seek:</strong> Uses an index to find the specific records being asked for by jumping to their location and either grabbing the 
                        data or, if it is a reference, using it to get the information.</li>
                        <li>The DB server decides if it should use a seek or scan. This means that even if you write your query to take advantage
                        of a good index, the server might ignore this and run the query using a scan. But why would it do this? If you are 
                        examining over 50% - 70% of the records in the table then seeking no longer offers any advantage. If you are regularly 
                        skipping the benefits of your indexes, they might need to be reexamined to see if the costs outweigh the benefits.</li>
                    </ul>
                    <li>To see existing indexes:</li>
                    <pre>
                        <code>
                    SELECT *
                    FROM pg_Indexes
                    WHERE tablename = 'products';
                        </code>
                    </pre>
                    <li><strong>Binary Tree (B-Tree): </strong> By default, index divides the possible matching records in half, then half, 
                    then half, and so on until the specific match you 
                    are searching for is found. This is known as a Binary Tree, or B-Tree.
                    Let’s consider an example to expand on this concept. Say you had a sales department where you ranked your clients from 
                    number 1 to 100 in order of loyalty. If you wanted to search the database for your most loyal client, who would have a 
                    loyalty score of 100, you would have to search every record (the highest loyalty score could be anywhere in the data set).
                    If you created an index on loyality_score, you could now use the B-Tree structure to speed up that search. The search would 
                    divide all results in half, so in this case, the first check would be if the record you are searching for is greater than or 
                    less than 50.</li>
                    <li><strong>EXPLAIN ANALYZE: </strong>To get insight into how PostgreSQL breaks down your statements into runnable parts, we can investigate the query plan 
                    by adding EXPLAIN ANALYZE before your query. Rather than returning the results of the query, it will return information 
                    about the query. More info <a href="https://www.postgresql.org/docs/current/sql-explain.html" target="_blank">here</a></li>
                    <ul>
                        <li><strong>Seq Scan</strong> this means that the system is scanning every record to find the specific records 
                        you are looking for. 
                        <strong>Index</strong> means the server is taking advantage of an index to improve the speed of your search.</li>
                        <li><strong>Planning time</strong> is the amount of time the server spends deciding the best way to solve your query, 
                        should it use an index, or do a full scan of the table(s) for instance. The <strong>execution time</strong> is the amount of time the 
                        actual query takes to run after the server has decided on a plan of attack. You need to take both of these into 
                        consideration, and when examining your own indexes these are critical to understanding how effective your indexes are.</li>
                        <li>We can use the code below and compare two different queries, to analyze if is faster using an index or 
                        doing a full scan of the table(s).</li>
                    </ul>
                    <pre>
                        <code>
                EXPLAIN ANALYZE SELECT *
                FROM customers;
                        </code>
                    </pre>
                    <li><strong>CREATE INDEX:</strong> 
                    When an index is created on a column, the database creates a separate data structure that 
                    contains the values from that column along with pointers to the actual rows in the table that containthose values.
                    In the code below, the "customers_user_name_idx" index will contain the values from the "user_name" column of the "customers" 
                    table and pointers to the rows in the table that contain those values. This will allow the database to quickly find all 
                    rows in the "customers" table that match a specific user name, which can be especially helpful if there are a large number 
                    of rows in the table.
                    To summarize, this code is creating an index on the "user_name" column of the "customers" table to speed up queries that 
                    involve searching for rows based on the values in that column:</li>
                    <pre>
                        <code>
                //user_name = column
                CREATE INDEX customers_user_name_idx ON customers (user_name);


                CREATE INDEX < index_name > ON < table_name > (< column_name >);
                        </code>
                    </pre>
                    <li>Much like constraints, you can <strong>combine multiple columns</strong> together as a single index. 
                    When using multicolumn indexes, the search structure will be based on the values found in all of the columns.
                    For example, an index on First and Last Name might be a good idea if it is common to search by both together in 
                    your situation. Consider a table where the last names 'Smith' and 'Johnson' appear many times. Having another filter 
                    for the first name can help you find someone named 'Sarah Smith' much faster.
                    The index is built in the specific order listed at creation, so (last_name, first_name) is different from 
                    (first_name, last_name). Keep this in mind when you are building your indexes as the order will impact the efficiency 
                    of your searches. You can create a multicolumn index as well (also known as Composite or Compound).</li>
                    <pre>
                        <code>
                //multicolumn index (Composite or Compound)
                CREATE INDEX customers_last_name_first_name_idx ON customers (last_name, first_name);
                        </code>
                    </pre>
                    <li><strong>DROP </strong>index: <i>DROP INDEX IF EXISTS customers_city_idx;</i></li>
                    <li><strong>Cons of using Index: </strong>
                    <ul>
                        <li>When new data is added, the index will be reshaped to fit that new data into 
                        its organization. This means that when you write a single statement to modify the records, the server will have to modify 
                        every index that would be impacted by this change. If you are adding a large amount of data to an existing table, it may 
                        be better to drop the index, add the data, and then recreate the index rather than having to update the index on each 
                        insertion. Keep in mind that these drawbacks are for each index you have on your table. If you have multiple indexes
                        on a single table and you insert a record, you will need to update each index associated with the table. This can make 
                        indexes very costly. If you are doing a large amount of inserts/updates it might be worth considering removing indexes 
                        before doing the changes then putting the indexes back in once you are done.
                        Updates and deletes have similar drawbacks. When deleting a record that is associated with an index, it might be faster 
                        to find the record — by leveraging the index’s ability to search. However, once the record is found, removing or editing 
                        it will result in the same issue as inserting a new record. The index itself will need to be redone. Note that if you’re 
                        updating a non-indexed column, that update will be unaffected by the index. So if you are updating a non-indexed column 
                        while filtering by one with an index, an update statement can actually be faster with an index.</li>
                        <li>Another place where an index falls short of perfection is that indexes take up space. The index data structures 
                        can sometimes take up as much space as the table itself.
                        Given the speed advantages indexes can provide when used properly, you should not ignore them, but keep in mind this balance.
                        If you wanted to examine the size of a table products you would run:
                        <i>SELECT pg_size_pretty (pg_total_relation_size('products'));</i></li>
                        <li><strong>When to use index?:</strong>
                        In the real world, this often becomes a grey area and one that you might have to go back to after trying for a while.
                        You will want to look at what a table is used for and by who. As a very rough rule of thumb, think carefully about any
                        index on a table that gets regular Insert/Update/Delete. In contrast, a table that is fairly stable but is searched 
                        regularly might be a good candidate for an index.
                        There are some other conditions that can impact your search times you should be aware of when using an index.
                        The higher the percentage of a table you are returning the less useful an index becomes. If we’re only searching 
                        for 1 record in 1,000,000, an index could be incredibly useful. However, if we are searching for 900,000 out of that 
                        same 1,000,000 the advantages of an index become useless. At higher percentages, the query planner might completely 
                        ignore your index and do a full table scan, making your index only a burden on the system.
                        Along this same line, if you are combining filtering conditions be aware of what you will be searching on. AND 
                        statements are normally fine and the query planner will try to use an indexed field before non-indexed fields to 
                        cut down on the total number of records needed to be searched. OR on the other hand, can be very dangerous; even 
                        if you have a single non-indexed condition, if it’s in an OR, the system will still have to check every record in 
                        your table, making your index useless.</li>
                    </ul>
                    <hr/>
                    <li><strong>Partial Index: </strong>
                    A partial index allows for indexing on a subset of a table, allowing searches to be conducted on just this group of 
                    records in the table. 
                    Unlike a regular index that indexes all rows in a table, a partial index only indexes the rows that satisfy a specified
                    condition. This can be useful in situations where only a subset of rows in a table are frequently queried, or where the 
                    indexed columns have a high degree of selectivity (i.e., only a small number of distinct values).
                    If you would be searching an index of ~258 Thousand instead of 70+ Million,
                    this can be powerful toolset when working with massive databases.
                    It can be used conditioning calculations as well, speeding up even more.</li>
                    <pre>
                        <code>
                CREATE INDEX users_user_name_internal_idx ON users (user_name)
                WHERE email_address LIKE '%@wellsfargo.com';
                        </code>
                    </pre>
                    <ul>
                        <li><strong>ORDER BY: </strong>
                        If you are commonly ordering your data in a specific way on an indexed column, you can add ORDER BY to the 
                        index itself and PostgreSQL will store the data in your desired order. By doing this, the results that are returned 
                        to you will already be sorted. You won’t need a second step of sorting them, saving time on your query.
                        This could improve the speed.</li>
                        <pre>
                            <code>
                CREATE INDEX logins_date_time_idx ON logins (date_time DESC, user_name);
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Primary Keys and Indexes: </strong>PostgreSQL automatically creates a unique index on any primary key you 
                    have in your tables. It will also do this for 
                    any column you define as having a unique constraint. A unique index, primary key, and unique constraint all reject any 
                    attempt to have two records in a table that would have the same value (multicolumns versions of these would reject any 
                    record where all the columns are equal).
                    The primary key index standard is to end in _pkey instead of _idx to identify it as a specific type of index. It is also 
                    the way the system names it when created automatically.</li>
                    <li>All indexes are either a <strong>clustered index</strong> or a <strong>non-clustered index</strong>. 
                    For now, let’s focus on the clustered index. A clustered index is often tied to the table’s primary key.</li>
                    <ul>
                        <li><strong>Cluster</strong> refers to a group of tables that are physically stored together on disk based on 
                        their relationships with each other.
                        In a clustered database, related data is stored together on disk, which can improve query performance by reducing 
                        the need for disk seeks and improving data locality. For example, a database might cluster a "customer" table with 
                        an "orders" table based on their relationship, so that the orders for each customer are stored together on disk.</li>
                        <li><strong>Non-Clustered</strong>You can create many indexes on a table, but only one can be a clustered index, so 
                        what about the rest? They are known as non-clustered indexes. Non-clustered indexes have records of the columns they 
                        are indexing and a pointer back to the actual data in the table. If you are searching for just the records in the 
                        non-clustered index, the system will simply seek for your query results and return them. When you search on a 
                        non-clustered index for more information than is in the indexed columns, there are two searches. The first to 
                        find the record in the index and another to find the record the pointer identifies. There are some things you 
                        can do, such as creating a multicolumn index, that in some cases can help cut down or eliminate the need for the 
                        look back to the main table in memory.
                        Previously we compared how a clustered index functions as a dictionary. You can think of all other indexes 
                        (non-clustered) more akin to an index in a book. The keywords you are looking for are organized (by type, 
                        alphabetically, by the number of appearances, etc) and can be found quickly. However, the index doesn’t contain
                        information beyond that. Instead, it contains a pointer (page number, paragraph number, etc) to where the rest of 
                        the data can be found. This is the same way non-clustered indexes in databases work. You have a key that is sorted 
                        and a pointer to where to find the rest of the data if needed.</li>
                        <li><strong>Index-Only Scans: </strong>
                        The lookup that a non-clustered index does back to the table after finding records has a cost.
                        If you include the information that is regularly looked for, even if it isn’t used in the filtering, 
                        as part of the index, a secondary search can be avoided.</li>
                        <li><strong>Combining Indexes: </strong>
                        Previously we went over multicolumn indexes as a way PostrgeSQL can speed searches on multicolumn filtering, 
                        but if you don’t have an appropriate single index for a query, the server can combine indexes together to speed 
                        the filter. Like anything automatically handled by a system, there are some things to keep in mind when using 
                        this convenience.</li>
                        <ul>
                            <li>A single multicolumn index is faster (if ordered well) than combining indexes.</li>
                            <li>A multicolumn index is less efficient than a single index in cases where a single index is needed.</li>
                            <li>You could create all of them, then the server will try to use the best one in each case, but if they 
                            are all not used relatively often/equally then this is a misuse of indexes.</li>
                        </ul>
                        <li>Take for example, searching for first_name and last_name in the customers table.</li>
                        <ul>
                            <li>If searches are most often for only one of the columns, that should be your index.</li>
                            <li>If searches are most often last_name and first_name then you should have a multicolumn index.</li>
                            <li>If the searches are frequent and evenly spread among; first_name alone, last_name alone, and the 
                            combination of the two, that is a situation where you would want to have all three indexes.</li>
                        </ul>
                    </ul>
                    <pre>
                        <code>      
                //To cluster your database table using an existing index
                CLUSTER products USING products_product_name_idx;

                //If you have already established what 
                    index should be clustered (recluster)
                CLUSTER products;


                //if you want to cluster every table in 
                    your database that has an identified index

                CLUSTER;
                        </code>
                    </pre>
                    <li><strong>Indexes Based On Expressions: </strong>
                    An index is not limited to just a column reference, it can use the result of a function or scalar expression computed 
                    from one or more columns.
                    For example, if you want to ensure the company_name in a manufactures table is unique, you can add the UNIQUE option 
                    to make a unique index constraint on the results on your index. Any duplicate will then be rejected. Using UNIQUE here 
                    tells the system that your index also needs to be a constraint and only allow one record in the system that matches the 
                    criteria for your index. In other words, by creating an index with UNIQUE the system will automatically create the 
                    constraint to match the logic in the index at the same time. Just like the creation of a constraint, if you try to 
                    create an index in this way where the data already in the table does not pass, the system will reject your creation and 
                    notify you of the issue.
                    Let’s look at our UNIQUE example a bit more. In PostgreSQL, 'ExampleCompany' is NOT the same thing as 'examplecompany' 
                    even though we would probably want to reject this as a duplicate. You can add a function on your index to convert all 
                    your company_name data to lower case by using LOWER. This ensures that 'ExampleCompany' would be considered the same as 
                    'examplecompany'. This combination of the UNIQUE constraint and the use of the function LOWER would look like the code below.
                    These special indexes compound the pros and cons of indexes. Because the results of the expression are stored in the 
                    index, it saves the search function from having to perform it on every row on future searches. However, every change 
                    in the table data that impacts the index means it has to do the expression again, making Inserts and Updates more 
                    expensive on these indexes than a basic index. Be especially thoughtful about when to use indexes that use functions 
                    or expressions.</li>
                    <pre>
                        <code>
                    CREATE UNIQUE INDEX unique_manufacture_company_name_idx 
                    ON manufacture(LOWER(company_name));
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>CREATE TEMP TABLE: </strong>If you are searching the same set of records from a table/view more than once in 
                    a block of code, put the filtered rows into an object such as a temp table, table variable, or view depending on the 
                    situation. This will eliminate the need to have to search the table/view for the same set of records more than once.</li>
                </div>
                <hr/>
                <li><strong>Postgree database management: </strong>
                The space PostgreSQL uses on disk can grow in several ways. Some ways are easier to predict, for example, the 
                addition of new tables or the addition of more data to a table. However, there are some properties of the PostgreSQL 
                data storage system that cause disk usage to increase in non-intuitive ways.</li>
                <p class="center"><strong>More about database management:</strong></p>
                <button id="showCode55" onclick="showCode('displayCode55', 'showCode55')">Display</button>
                <div id="displayCode55">
                    <button onclick="closeCode('displayCode55', 'showCode55')">Close</button>
                    <li><strong>Understanding Object Size:</strong> In order to manage database disk utilization, you should first be able to measure 
                    disk utilization. As a database user, you can use the following functions to check the size of a relation in a database.</li>
                    <ul>
                        <li><strong>pg_total_relation_size</strong> will return the size of the table and all its indexes in bytes. These values are often in the 
                        millions or billions and thus hard to read. Because indexes are relations in their own right, you can also call 
                        pg_total_relation_size on a single index to get the size of the index.</li>
                        <li><strong>pg_table_size</strong> and <strong>pg_indexes_size</strong> return the size of the table’s data and table’s 
                        indexes in bytes. The sum of these two functions is equal to pg_total_relation_size</li>
                        <li><strong>pg_size_pretty</strong> can be used with the functions above to format a number in bytes as KB, MB, or GB.</li>
                    </ul>
                    <pre>
                        <code>
                    SELECT 
                    pg_size_pretty(pg_table_size('time_series')) as tbl_size, 
                    pg_size_pretty(pg_indexes_size('time_series')) as idx_size,
                    pg_size_pretty(pg_total_relation_size('time_series')) as total_size;
                        </code>
                    </pre>
                    <li><strong>Dead tuples:</strong> Each row in a PostgreSQL table is stored in a file on the disk of the host machine. When an UPDATE or DELETE is called, 
                    PostgreSQL doesn’t physically delete the content from the disk. Instead, the database engine marks those rows so that they 
                    aren’t returned in user queries. These rows are called <strong>dead tuples</strong>, and although they aren’t referenced in the current 
                    version of databases’ tables, they still occupy space on disk and can affect performance.
                    Unlike updates, deletes don’t add space to a table - however, a DELETE statement will create dead tuples and leave the 
                    size of the table unchanged (when it should change to less).</li>
                    <li><strong>VACUUM: </strong>There are also statements you can use that allow you to actively manage disk usage. 
                    In PostgreSQL there is an operation 
                    called VACUUM that can be used to manage storage space. Running VACUUM <i>< table name >;</i> will vacuum a specific table,
                    while a VACUUM statement without a table name will run on the entire database. 
                    VACUUM simply marks dead tuples and allows that space to be re-used by future updates.</li>
                    <ul>
                        <li><strong>Autovacuum: </strong>To ensure that vacuuming isn’t left completely to the database users, PostgreSQL has a feature called autovacuum
                        enabled on most databases by default. When using autovacuum, PostgreSQL periodically checks for tables that have had a 
                        large number of inserted, updated or deleted tuples that could be vacuumed to improve performance. When autovacuum is 
                        enabled and finds such a table, a <i>VACUUM ANALYZE</i> command is run - this statement is a combination of two separate 
                        operations.</li>
                        <li>You can <strong>monitor</strong> a lot of information, such as last vacuum, autovacuum, dead tuplets, just
                        by querying the table <i>pg_stat_all_tables</i> for vacuum and analyze statistics.</li>
                        <pre>
                            <code>
                SELECT relname, 
                    last_vacuum,
                    last_autovacuum, 
                    last_analyze
                FROM pg_stat_all_tables 
                WHERE relname = 'books';
                            </code>
                        </pre>
                        <li><strong>VACUUM FULL: </strong>Rewrites all the data from a table into a “new” location on disk and only copies the required data 
                        (excluding dead tuples). This allows PostgreSQL to fully clear the space the table occupied. One of the significant 
                        drawbacks from VACUUM FULL is that it’s a slow operation that blocks other operations on the table while it’s working. 
                        If you’ve got a large table, this could mean a VACUUM FULL operation might block other user’s or application’s queries. 
                        In a local setting, this may seem trivial, but for production databases, preventing reads and writes on a table for even 
                        a few seconds can have lasting effects. VACUUM FULL is quite a heavy operation that should be used sparingly. 
                        The best strategy when designing a database maintenance plan is to make sure that VACUUM runs frequently and 
                        autovacuum is enabled.</li>
                        <pre>
                            <code>
                    //This will minimize subsequent
                        effects of dead tuples
                    VACUUM mock.time_series;

                    VACUUM ANALYZE < table_name >;

                    VACUUM FULL < table_name >;
                            </code>
                        </pre>
                        <li><strong>TRUNCATE: </strong>Occasionally, you may need to remove all the rows, but retain the structure of a table.
                        TRUNCATE quickly removes all rows from a table. It has the same effect as an unqualified delete, but since 
                        PostgreSQL doesn’t scan through the table first, TRUNCATE runs much faster on large tables. Finally, TRUNCATE 
                        simultaneously reclaims disk space immediately, rather than requiring a subsequent VACUUM or VACCUM FULL operation.
                        <i>TRUNCATE < table_name ></i></li>
                    </ul>
                    <li>More Info:</li>
                    <ul>
                        <li><strong>Performance cheatsheet </strong><a href="https://severalnines.com/blog/performance-cheat-sheet-postgresql/" target="_blank">here</a>.</li>
                        <li><strong>Advanced Postgree performance </strong><a href="https://thoughtbot.com/blog/advanced-postgres-performance-tips" target="_blank">here</a>.</li>
                        <li><strong>Performance Tuning PostgreSQL </strong><a href="https://www.revsys.com/writings/postgresql-performance.html" target="_blank">here</a>.</li>
                    </ul>
                </div>
                <hr/>
                <h3>Integrating PostgreSQL to Node</h3>
                <li><strong>Node-Postgres</strong></li>
                <ul>
                    <li><strong>Node-Postgres </strong>documentation <a href="https://node-postgres.com/" target="_blank">here</a>.</li>
                    <li><strong>Project structure </strong>with node-postgres <a href="https://node-postgres.com/guides/project-structure" target="_blank">here</a>.</li>
                </ul>
                <li><strong>Articles</strong></li>
                <ul>
                    <li><strong>CRUD REST API</strong> with Node.js, Express, and PostgreSQL <a href="https://blog.logrocket.com/crud-rest-api-node-js-express-postgresql/#what-express" target="_blank">here</a>.</li>
                    <li><strong>Why not use OMR?</strong><a href="https://blog.logrocket.com/node-js-orms-why-shouldnt-use/" target="_blank"> here</a>.</li>
                    <li>The minimal <strong>Node.js with Babel Setup</strong><a href="https://www.robinwieruch.de/minimal-node-js-babel-setup/" target="_blank"> here</a>.</li>
                    <li><strong>Setup Express.js in Node.js</strong><a href="https://www.robinwieruch.de/node-js-express-tutorial/" target="_blank"> here</a>.</li>
                    <li>Create a <strong>REST API with Express.js in Node.js</strong><a href="https://www.robinwieruch.de/node-express-server-rest-api/" target="_blank"> here</a>.</li>
                    <li><strong>Setup PostgreSQL with Sequelize(ORM) in Express</strong><a href="https://www.robinwieruch.de/postgres-express-setup-tutorial/" target="_blank"> here</a>.</li>
                    <li>Creating a <strong>REST API</strong> with <strong>Express.js and PostgreSQL</strong><a href="https://www.robinwieruch.de/postgresql-express-node-rest-api/" target="_blank"> here</a>.</li>
                    <li><strong>Postgres Performance Heroku</strong><a href="https://devcenter.heroku.com/categories/postgres-performance" target="_blank"> here</a>.</li>
                </ul>
                <li><strong>Samples</strong></li>
                <ul>
                    <li><strong>Sample Databases 1</strong><a href="https://wiki.postgresql.org/wiki/Sample_Databases" target="_blank"> here</a>.</li>
                    <li><strong>PostgresDB Samples 2</strong><a href="https://github.com/morenoh149/postgresDBSamples" target="_blank"> here</a>.</li>
                    <li><strong>PostgreSQL Samples 3</strong> <a href="https://www.postgresqltutorial.com/postgresql-getting-started/postgresql-sample-database/" target="_blank"> here</a>.</li>
                </ul>
                <li><strong>Supabase </strong><a href="https://supabase.com/" target="_blank">here</a>.</li>
                <li><strong>Tools: </strong>Working directly with databases from your application isn’t always easy. Differences in the way data structures are 
                represented often leads to challenges. The difficulty in expressing subtleties about relationships between different 
                entities can also cause issues. To address this, many different tools have been created to help act as an interface 
                between the core application and the data layer.
                We’ll look at some of the differences that arise between three common approaches:</li>
                <ul>
                    <li><strong>Raw SQL</strong></li> 
                    <li><strong>Query builders</strong></li>
                    <li><strong>ORMs (object-relational mappers)</strong></li>
                </ul>
                <p class="center"><strong>Types of tools:</strong></p>
                <button id="showCode56" onclick="showCode('displayCode56', 'showCode56')">Display</button>
                <div id="displayCode56">
                    <button onclick="closeCode('displayCode56', 'showCode56')">Close</button>
                    <li><strong>Raw SQL: </strong>
                    Some applications interface directly with the database by writing and executing queries using the native language 
                    supported by the database engine. Often, a database driver is all that is needed to connect, authenticate, and 
                    communicate with the database instance.
                    Developers can send queries written in the database’s native language through the connection. In return, the database 
                    will provide the query results, also in one of its native formats. For many relational database, the querying language 
                    of choice is SQL.
                    <ul>
                        <li><u>Benefits: </u>Developers write and manage the database queries and handle the results explicitly.
                        While this can be a lot of additional work, it means that there are few surprises in terms of what the database is storing,
                        how it is representing your data, and how it will supply that data when it is retrieved later. The lack of abstraction 
                        means that there are fewer “moving parts” that can lead to uncertainty.</li>
                        <li><u>Drawbacks: </u>
                        When interacting with a database from an application using plain SQL, you must understand the underlying data structure 
                        in order to compose valid queries. You are completely responsible for translating between the data types and structures 
                        that your application employs and the constructions available within the database system.
                        Another thing to keep in mind when working with raw SQL is that it is entirely up to you to manage the safety of your 
                        input. This is especially true if you are storing data provided by external users, where specially crafted input could 
                        induce your database to exposing information you hadn’t intended to allow (SQL injection).
                        Working with native querying languages almost always means composing queries with regular strings. This can be a painful 
                        process in cases where you must escape input and concatenate strings together to create a valid query. Your database 
                        operations can become wrapped up in many layers of string manipulation that has a high potential to accidentally mangle data.</li>
                    </ul>
                    <li><strong>Query builders: </strong>
                    Offers a thin layer of abstraction that specifically targets some of the major 
                    pain points of working directly with database-native languages. SQL query builders almost function as a templating system 
                    for querying, allowing developers to walk the line between working directly with the database and adding additional layers 
                    of abstraction. They do this by formalizing querying patterns and providing methods or functions that add input sanitation and 
                    automatically escape items for easier integration into applications.
                    <ul>
                        <li><u>Benefits:</u> Because query builders use the same constructions (methods or functions) as the rest of your application, 
                        developers often find them easier to manage long term than raw database queries written as strings. It is simple to tell 
                        the difference between operators and data and it is easy to decompose queries into logical chunks that handle specific 
                        parts of a query.
                        Makes it easier for those familiar with the database to understand what an operation will do. This isn’t always the case 
                        when using greater 
                        levels of abstraction.
                        SQL query builders often support multiple data backends, abstracting some of the subtle differences in various 
                        relational databases, for instance. This allows you to use the same tools for projects that use different databases.</li>
                        <li><u>Drawbacks: </u>SQL query builders suffer from a few of the same disadvantages as native querying languages.
                        Query builders still require you to understand and account for the database’s structures 
                        and capabilities, this means that you must have a fairly good 
                        grasp of SQL in addition to the specific syntax and capabilities of the query builder itself.
                        Additionally, SQL query builders still require you to define how the data you retrieve relates to your application data. 
                        There is no automatic synchronization between your in-memory objects and those in the database.</li>
                    </ul>
                    <li><strong>ORMs (object-relational mappers): </strong>ORMs generally
                    aim for a more complete abstraction with the hope of integrating with the application data more fluidly.
                    Object-relational mappers, or ORMs, are pieces of software dedicated to translating between the data representations in 
                    relational databases and the representation in memory used with object-oriented programming (OOP). The ORM provides an 
                    object-oriented interface to data within the database, attempting to use familiar programming concepts and reduce the 
                    amount of boilerplate code necessary in order to speed up development.
                    Object-oriented programming tends to produce a lot of structures with significant state and relationships that must be 
                    accounted for. Some other programming paradigms are more explicit about where state is stored and how it is managed. 
                    For instance, purely functional languages don’t allow mutable state, so state is often an input for functions or objects 
                    that output a new state. This clean separation of data from actions, as well as the explicitness of state life cycles can 
                    help simplify the interaction with the database.
                    Different ORMs employ different strategies to map between application and database structures. The two major categories are the 
                    active record pattern and the data mapper pattern.
                    <u>Drawbacks: </u>Many of these 
                    advantages act as a double-edged sword. They can prevent you from understanding your databases and can make it challenging 
                    to debug, change paradigms, or increase performance.
                    Perhaps the most well-known problem of working with ORMs is <strong>object-relational impedance mismatch</strong>, a term used to describe 
                    the difficulty of translating between object-oriented programming and the relational paradigm used by relational databases.
                    The incompatibilities between the data models used by these two categories of technology means that additional, imperfect 
                    abstraction is necessary with every increase in complexity. Object-relational impedance mismatch has been called the Vietnam
                    of computer science.
                    <ul>               
                        <li><strong>Active record</strong> pattern attempts to encapsulate the database’s data within the structure of objects within your code. 
                        Objects contain methods to save, update, or delete from the database and changes to your objects are meant to be easily 
                        reflected in the database. In general, an active record object in your application represents a record within a database.
                        Active record implementations allow you to manage your database by creating and connecting classes and instances within 
                        your code. Since these generally map class instances directly to database records, it is easy to conceptualize what is in 
                        your database if you understand what objects are used in your code.
                        Unfortunately, this can also come with some major downsides. Applications tend to be very tightly coupled with the 
                        database, which can cause problems when trying to migrate to a new database or even when testing your code. Your code 
                        tends to rely on the database to fill in gaps that were offloaded from your objects. The “magic” translation between these 
                        two domains can also lead to performance problems as the system tries to seamlessly map complex objects to the underlying 
                        data structure.</li>
                        <li><strong>Data mapper</strong> pattern is the other common ORM pattern. Like the active record pattern, the data mapper 
                        attempts to act as an independent layer between your code and your database that mediates between the two. 
                        However, instead of trying to seamlessly integrate objects and database records, it focuses on trying to decouple and 
                        translate between them while letting each exist independently. This can help separate your business logic from 
                        database-related details that deal with mappings, representation, serialization, etc.
                        So rather than letting the ORM system figure out how to map between the objects and the database tables, the developer 
                        is responsible for explicitly mapping between the two. This can help avoid tight coupling and behind-the-scenes 
                        operations at the expense of significantly more work in figuring out appropriate mappings.</li>
                    </ul>
                </div>
                <hr/>
                <h3>Postgres Security</h3>
                <li>Set up <strong>host-based authentication</strong> to define who is allowed to connect to the server.</li>
                <li>Implemented a <strong>role management system</strong> that operates on the Principle of Least Privilege.</li>
                <li>Enforced <strong>secure authentication</strong> and <strong>dissuaded automated attacks.</strong></li>
                <hr/>
                <h3>Authentication and authorization in POSTGRES</h3>
                <li><strong>Host-based authentication</strong> is a type of authentication mechanism that verifies the 
                identity of a user based on the host or computer they are using to access a system. In this 
                type of authentication, the identity of the user is authenticated based on the identity of 
                the computer or host from which the user is trying to access the system. More
                in <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-data-security/modules/wdcp-22-authentication-authorization-postgres/cheatsheet" target="_blank">here</a></li>
                <ul>
                    <li><strong><i>pg_hba.conf</i></strong> file (created within the project) allows you to specify 
                    rules for how Postgres should handle 
                    different connections. Rules can apply narrowly or broadly, depending on how precise 
                    the parameters are. In the pg_hba.conf file, all the entries follow the same basic format, 
                    with blank lines or lines beginning with a # symbol being ignored. The basic format of 
                    entries is:</li>
                    <pre>
                        <code>
                connection_type  db  user  address  auth_method  [auth_options]
                        </code>
                    </pre>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode68" onclick="showCode('displayCode68', 'showCode68')">Display</button>
                <div id="displayCode68">
                    <button onclick="closeCode('displayCode68', 'showCode68')">Close</button>
                    <li>Let’s <strong>build an entry</strong>. The entry we’ll be building will allow SSL connections 
                    to a database called db_example for members of the g_example group on the same network 
                    as the server and use sha-256 password authentication.</li>
                    <ul>
                        <li><strong>connection_type</strong> will be <strong>hostssl</strong>, which matches external connections that use SSL. host is like hostssl, but matches connections that don’t use SSL as well.
                        db will be db_example. The keyword all can be used to match all databases.</li>
                        <li><strong>user</strong> will be <strong>+g_example</strong>. The + matches users who are members of this group, rather 
                        than the group itself. If we were creating a rule for a specific user, we would omit 
                        the +. The keyword all can be used to match all users.</li>
                        <li><strong>address</strong> will be <strong>samenet</strong>, a shorthand for connections on the same subnet as the 
                        server. Specific IP addresses can be put here as well. The keyword all can be used 
                        to match any address.</li>
                        <li><strong>auth_method</strong> will be <strong>scram-sha-256</strong>. There are other options, including reject, 
                        which unconditionally rejects connections matching the rule.</li>
                        <li>We’ll leave auth-options blank.</li>
                    </ul>
                    <li>All together, it looks like:</li>
                    <pre>
                        <code>
            hostssl  db_example  +g_example  samenet  scram-sha-256
                        </code>
                    </pre>
                    <li>The owner, who has the username u_owner, wants to be able to access all the 
                    databases from their home computer. Implement a rule to allow connections from their 
                    IP address: 104.20.25.250 using sha-256 password authentication. Since this connection 
                    goes over the public internet, the connection needs to use SSL.</li>
                    <pre>
                        <code>
            hostssl  all  u_owner  104.20.25.250  scram-sha-256
                        </code>
                    </pre>
                    <li>Let’s implement a <strong>default-deny</strong> rule at the very bottom of pg_hba.conf, to ensure 
                    that all external connections we don’t specifically allow are blocked. This rule should 
                    match all types of external connections, for all databases, users, and addresses, and 
                    reject them.</li>
                    <pre>
                        <code>
            host  all  all  all  reject
                        </code>
                    </pre>
                </div>
            <li><strong>User and Role Management:</strong>
            To solve this, you decide to create a system that uses three types of roles: permissions, 
            groups, and users.
            Permissions will determine privileges based on tasks, such as reading and writing to a given 
            table. Groups will be collections of permissions, and represent a group of users.
            Users represent specific people or applications, and join groups based on what their job is.
            We’ll be using two main commands today: CREATE ROLE and GRANT. <strong>A video implementation</strong>
            <a href="https://www.youtube.com/watch?v=aniANzg0BSk" target="_blank">here</a>.</li>
            <ul>
                <li><strong>CREATE ROLE</strong> follows the format
                below. It has a variety of optional parameters such as SUPERUSER/NOSUPERUSER, but Postgres provides 
                sensible default values for these parameters, so we won’t need to specify them here. 
                (You should always do extra research when creating your own application.) 
                <strong><i>CREATE ROLE role_name;</i></strong></li>
                <li><strong>GRANT</strong> follows two formats. <strong><i>PERMISSION ON table TO role;</i></strong>
                is used for granting permissions; if we wanted to allow the p_example role to select on the example table, we would 
                use GRANT SELECT ON example TO p_example;.
                <strong><i>GRANT role TO other_role;</i></strong> is used to assign one role to another role; if we wanted to 
                give g_example all the permissions of p_example, we 
                would use GRANT p_example TO g_example;.</li>
            </ul>
            <hr/>
            <h3>Server Configuration</h3>
            <li>A configuration file called <strong><i>postgresql.conf</i></strong> (created within the project) it's needed in order to make some final tweaks to improve the overall security of the 
            Postgres server. Some of the changes will enforce secure authentication, while others will make it more difficult for an 
            attacker to target the server using automated tools. We’ll be changing three parameters in this exercise:</li>
            <ul>
                <li>The <strong>listen_addresses</strong> parameter controls what IP addresses are allowed to connect to the server. 
                An IP address that isn’t 
                allowed to connect won’t even be able to try to authenticate. Setting this to '*' allows connections from any address to 
                try and authenticate, but this is generally a bad idea!</li>
                <li>The <strong>port parameter</strong> is the port the Postgres server listens on. Port numbers 49152—65535 aren’t reserved by any 
                software, so a port in this range usually doesn’t conflict with any other software.</li>
                <li>The <strong>ssl parameter</strong> determines whether or not the server will support SSL connections. In a real environment,
                the server also needs to be provided with the appropriate certificate and key.</li>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>NoSQL</h2>
            <ul>
                <li><strong>NoSQL: </strong>
                NoSQL keeps all the information in one place, in the form of key-values or documents.</li>
                <ul>
                    <li>Benefits:<strong>Scalability:</strong> NoSQL was designed with
                    scalability as a priority. NoSQL can be an excellent choice for massive datasets that need to be 
                    distributed across multiple servers and locations.
                    <strong>Flexibility:</strong> Unlike a relational database, NoSQL databases don’t require a schema. This means that 
                    NoSQL can handle unstructured or semi-structured data in different formats
                    <strong>Developer Experience:</strong> NoSQL requires less organization and thus lets developers focus more on using
                    the data than on figuring out how to store it.</li>
                    <li><strong></strong>Drawbacks:</strong>
                    <strong>Data Integrity:</strong> Relational databases are typically ACID compliant, ensuring high data integrity. 
                    NoSQL databases follow BASE principles (basic availability, soft state, and eventual consistency)
                    and can often sacrifice integrity for increased data distribution and availability. However, some 
                    NoSQL databases do offer ACID compliance.
                    <strong>Language Standardization:</strong> While some NoSQL databases do use the Structured Query Language (SQL), 
                    typically, each database uses its unique language to set up, manage, and query data.</li>
                </ul>
                <li><strong>Types of NoSQL</strong> Databases:</li>
                <ul>
                    <li><strong>key-value database</strong> consists of individual records organized via key-value pairs. In this model, 
                    keys and values can be any type of data, ranging from numbers to complex objects. However, keys 
                    must be unique. This means this type of database is best when data is attributed to a unique key, 
                    like an ID number. Ideally, the data is also simple, and we are looking to prioritize fast queries 
                    over fancy features. Amazon <a href="https://aws.amazon.com/pt/dynamodb/" target="_blank">DynamoDB</a> 
                    and <a href="https://redis.com/" target="_blank">Redis</a> are popular options for developers 
                    looking to work with key-value databases.</li>
                    <li><strong>document-based</strong> (also called document-oriented) database consists of data stored in hierarchical 
                    structures. Some supported document formats include JSON, BSON, XML, and YAML. The document-based 
                    model is considered an extension of the key-value database and provides querying capabilities not 
                    solely based on unique keys. Documents are considered very flexible and can evolve to fit an 
                    application’s needs. They can even model relationships!
                    <a href="https://www.mongodb.com/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral" target="_blank">MongoDB</a> is a popular option for developers looking to work with a document database.</li>
                    <li><strong>graph database</strong> stores data using a graph structure. In a graph structure, data is stored in 
                    individual nodes (also called vertices) and establishes relationships via edges (also called 
                    links or lines). The advantage of the relationships built using a graph database as opposed to 
                    a relational database is that they are much simpler to set up, manage, and query. For example, 
                    let’s say we wanted to build a recommendation engine for our e-commerce store. We could establish
                    relationships between similar items our customers searched for to create recommendations.
                    <a href="https://neo4j.com/" target="_blank">Neo4j</a> is a popular option for developers looking to work with a graph database.</li>
                    <li><strong>column-oriented</strong> NoSQL database stores data similar to a relational database. However, 
                    instead of storing data as rows, it is stored as columns. Column-oriented databases aim to 
                    provide faster read speeds by being able to quickly aggregate data for a specific column. 
                    Amazon’s <a href="https://aws.amazon.com/redshift/" target="_blank">Redshift</a> is a popular 
                    option for developers looking to work with a column-oriented database.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode48" onclick="showCode('displayCode48', 'showCode48')">Display</button>
                <div id="displayCode48">
                    <button onclick="closeCode('displayCode48', 'showCode48')">Close</button>
                    <ul>
                    </ul>
                </div>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>WebSecurity</h2>
            <ul>
                <li><strong>OWASP (Open Web Application Security Project)</strong> is a respected authority 
                in the field of web security.
                OWASP Top Ten threats can be used as a guide for a webapp security - see it
                <a href="https://owasp.org/www-project-top-ten" target="_blank">here.</a></li>
                <li><strong>Security Principles: </strong>A good rule of thumb for web security, and cybersecurity in general, is something called the
                CIA triad (no, not the US federal agency). CIA stands for Confidentiality, Integrity, and 
                Availability.</li>
                <ul>
                    <li>Confidentiality refers to protecting private information from eyes that shouldn’t have 
                    access to it. It’s the need to enforce access - who can see this, and who shouldn’t? Examples 
                    of enforcing confidentiality include implementing robust user authentication and encryption of 
                    important user data.</li>
                    <li>Integrity refers to data integrity here. We need security controls that protect data from 
                    being changed or deleted, and that the damage can be reversed if done accidentally. Some 
                    techniques related to integrity are database security, keeping backups and using cryptography 
                    to check for changes.</li>
                    <li>Availability refers to data being consistently, reliably available to those authorized. For 
                    example, social media websites ensure that even with high traffic or when a server is 
                    compromised, information gets to a user’s screen. This is accomplished through constant 
                    maintenance of hardware and software, monitoring servers and networks, and having a plan for 
                    any disasters.</li>
                </ul>
            </ul>
            <hr/>
            <h3>Data Security</h3>
            <ul>
                <li></strong>Transport Layer Security(TLS): </strong>
                is a protocol for establishing secure connections between computers. TLS’s largest 
                claim to fame is that it powers HTTPS, the protocol that lets us browse the web securely.
                As suggested by its name, TLS provides security for data that is sent through transport 
                layer protocols. It does this by creating a secure connection (often conceptualized as 
                a tunnel) through which data can be transmitted to its destination. You can think of 
                TLS as a wrapper for transport layer protocols. TLS makes use of other algorithms and 
                protocols to handle things like encryption and key exchange. However, TLS is not itself 
                an encryption algorithm.
                TLS uses public-key certificates in order to make sure that servers (and sometimes 
                clients) are who they say they are. These certificates are created using the ability 
                of asymmetric cryptography to digitally sign data, verifying its authenticity and 
                provenance.</li>
                <ul>
                    <li><strong>Secure Sockets Layer (SSL)</strong> is the predecessor of TLS. Like TLS, it is a protocol 
                    meant to establish secure communications between computers. The primary difference 
                    between SSL and TLS is that SSL has a history of serious security vulnerabilities, 
                    with the final version being deprecated in 2015.
                    Both SSL and TLS use the same kind of certificate, and TLS was originally created 
                    to replace SSL. Because SSL was around first, it’s still common to refer to 
                    ‘SSL/TLS certificates’ as just ‘SSL certificates’. For the most part, whenever 
                    you hear someone talk about SSL, you can probably assume they’re actually talking 
                    about TLS.</li>
                </ul>
                <li><strong>Role-Based Access Control (RBAC) </strong>is a way of managing permissions using roles.
                As the name suggests, roles are a core part of Role-Based Access Control. A role serves 
                as an layer between permissions and users; rather than permissions being granted 
                directly to users, permissions are granted to roles, and then users are assigned roles 
                as appropriate.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode67" onclick="showCode('displayCode67', 'showCode67')">Display</button>
            <div id="displayCode67">
                <button onclick="closeCode('displayCode67', 'showCode67')">Close</button>
                <ul>
                    <li>employee</li>
                    <ul>
                        <li>Time-Tracking Software (Personal Access)</li>
                        <li>Payroll Software (Personal Access)</li>
                    </ul>
                    <li>mechanic</li>
                    <ul>
                        <li>Work Orders (View/Edit)</li>
                    </ul>
                    <li>cashier</li>
                    <ul>
                        <li>Point Of Sale Terminal Access</li>
                        <li>Inventory Database (Read)</li>
                        <li>Work Orders (Read)</li>
                    </ul>
                    <li>inventory_manager</li>
                    <ul>
                        <li>Inventory Database (Read/Write)</li>
                        <li>Supply Orders (View/Create)</li>
                    </ul>
                    <li>hr</li>
                        <li>Time-Tracking Software (Administrative)</li>
                    <li>payroll</li>
                    <ul>
                        <li>Payroll Software (Administrative)</li>
                    </ul>
                    <li>billing</li>
                    <ul>
                        <li>Invoice Software (Create/Pay)</li>
                        <li>Supply Orders (View)</li>
                    </ul>
                    <li>it</li>
                    <ul>
                        <li>Administrative Computer Access</li>
                    </ul>
                </ul>
            </div>
            <hr/>
            <h3>Common Attacks on Web Applications</h3>
            <ul>
                <li><strong>Cross-Site Scripting (XSS)</strong> is a common web application vulnerability 
                that occurs when a web application renders unsanitized input to the front end of an application. 
                An attacker takes advantage of this vulnerability by injecting malicious code, generally in the form of 
                JavaScript, through the browser.
                XSS is preventable with <strong>input sanitization</strong> and <strong>application-level firewalls</strong>.
                Prevention Cheatsheet 
                <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html" target="_blank">here</a>.
                <ul>
                    <strong>Sanitization</strong> is the process of removing/replacing problematic characters with safe 
                    versions. Depending on the backend language, there may or may not be built-in functions to aid in this 
                    process. However, if these functions do not exist, we can generally succeed 
                    in preventing XSS attacks by removing characters such as <, >, ", =, and potentially dangerous keywords.
                    Rather than remove characters, we can also replace them with HTML-encoded versions of the characters. 
                    This allows us to retain the characters, but remove their capacity to affect the page’s HTML.
                    For example, the < character would be converted to the “<” string. The browser will render this string 
                    as the “<” character, but it will not interpret it as actual HTML, preventing the attack.
                    It is important to note, however, that depending on how the data is used, this type of escaping may 
                    not be enough. It’s important to consider all potential avenues for an attack.
                    There are also JavaScript packages like sanitize-html that help sanitizer user inputs. Here are some
                    types of XSS attacks:</li>
                    <ul>
                        <li><strong>Stored XSS (server and/or database)</strong> <a href="https://owasp.org/www-community/attacks/xss/#stored-xss-attacks" target="_blank">here</a>.</li>
                        <li><strong>Reflected XSS (server and/or database)</strong> <a href="https://owasp.org/www-community/attacks/xss/#reflected-xss-attacks" target="_blank">here</a>.</li>
                        <li><strong>DOM-based Atacks (client side)</strong> <a href="https://owasp.org/www-community/attacks/DOM_Based_XSS" target="_blank">here</a>.</li>
                    </ul>
                    <li>Video protecting against <strong>XSS attacks</strong> <a href="https://www.youtube.com/watch?v=JHOmNd2218g" target="_blank">here</a>.</li>
                    <li>Video Acme Bank pproctecting against <strong>Various attacks</strong> 
                    <a href="https://www.youtube.com/watch?v=d0pWvLyngHM" target="_blank">here</a>.</li>
                    <li><strong>Securing Cookies and Headers: </strong></li>
                    <ul>
                        <li><strong>Cookies</strong> can be used to steal user’s data. An express server that uses 
                        express-session to store cookies has the properties httpOnly and secure to configure 
                        how to store and send cookies. Setting <strong>httpOnly</strong> and <strong>secure</strong>
                        to true helps mitigate the risk of client-side script accessing the protected cookie.
                        In order to set up a cookie in an Express server, you can use the library 
                        express-session to set up a session and configure the application with specific 
                        properties pertaining to cookies:</li>
                        <pre>
                            <code>
                            app.use(
                            session({
                                secret: "my-secret",
                                resave: true,
                                saveUninitialized: true,
                                cookie: {
                                httpOnly: true,
                                secure: true
                                },
                            })
                            );
                            </code>
                        </pre>
                        <li><strong>Setting Security Headers: </strong>
                        Moreover, we can include the helmet package to edit HTTP headers. Helmet.js is a 
                        collection of 15 Node modules that interface with Express. Each module provides 
                        configuration options for securing different HTTP headers. One of them being the 
                        contentSecurityPolicy which is an added layer of security that helps to detect and 
                        mitigate certain types of attacks. Fortunately, by just including this package in 
                        your express app, 11 of these modules (including the content security policy module) 
                        will be configured automatically. You can require helmet 
                        using: <i><strong>const helmet = require('helmet');</strong></i>
                        You can use helmet by adding the following line 
                        of code:</li>
                        <pre>
                            <code>
                            app.use(helmet());
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Data Validation and Sanitization: </strong>
                    In the <strong>Reflected</strong> and <strong>Stored XSS Attacks</strong>, an attacker can inject malicious 
                    code into the server and/or database using a form.
                    When we validate data we ensure that the user is not submitting information that doesn’t 
                    fit a certain format. Moreover, we can use sanitization in order to reformat data so no 
                    malicious code is sent.
                    In other words, <strong>validation</strong> checks if the input meets a set of criteria (such as a string 
                    contains no standalone single quotation marks), whereas <strong>sanitization</strong> modifies the input 
                    to ensure that it is valid (such as removing single quotes).
                    There are many packages that help validate user data, and one common package is 
                    express-validator - recomended for express applications.
                    <strong>Documentation</strong> <a href="https://express-validator.github.io/docs/validation-chain-api/" target="_blank">here</a>.
                    List of express-validor's method <strong>validations</strong> 
                    <a href="https://github.com/validatorjs/validator.js" target="_blank">here</a>.</li>
                    <p class="center"><strong>Example:</strong></p>
                    <button id="showCode69" onclick="showCode('displayCode69', 'showCode69')">Display</button>
                    <div id="displayCode69">
                        <button onclick="closeCode('displayCode69', 'showCode69')">Close</button>
                        <li>With <strong>express-validator</strong>, we can verify if a string matches a certain format by importing 
                        certain functions such as check:
                        <i>const { check } = require("express-validator");</i>
                        Once the function is imported, it can be used as a middleware within our endpoints, 
                        to validate any input that’s submitted within objects attached to req (such as data 
                        sent in a form through req.body):</li>
                        <ul>
                            <pre>
                                <code>
                        app.post("/login", [
                            check('email').isEmail(),
                        ], (req, res) => {});
                                </code>
                            </pre>
                            <li>In the example above, the email field is sent through a login form and retrieved from 
                            req.body. Notice how we’re using an array since we can pass in multiple check‘s for input 
                            data.
                            If the input data is valid, then the rest of the request will be executed and we know 
                            that the data passed in is safe and properly formatted.</li>
                        </ul>
                    </div>
                    <li><strong>DOM-Based Precautions: </strong>
                    Ideally, one could take a step further and <strong>avoid rendering user input</strong>, 
                    especially if it affects DOM elements such as the document.url, document.location, or document.referrer.
                    Lastly, one should <strong>validate and sanitize</strong> all user input in order to prevent any data manipulation.
                    </li>
                </ul>
                <li><strong>Cross-Site Request Forgery (CSRF) Attacks</strong></li>
                <ul>
                    <li>Cross-Site Request Forgery (CSRF) is a common class of vulnerability that tricks a user into submitting a web request on behalf of an attacker.
                    <strong>More info</strong> <a href="https://owasp.org/www-community/attacks/csrf" target="_blank">here</a>.</li>
                    <li><strong>Preventing: </strong>
                    One of the simplest ways to prevent these attacks is to add a <strong>CSRF token</strong>. This token is 
                    a unique value that is added to each request. This value is dynamically generated by the 
                    server and used to verify all requests. This token is kept strictly with the form the 
                    user is currently on if they were making the legitimate request, so the attacker does 
                    not have access to it, and cannot get the user to complete the same request without the 
                    token. Since this value is unique for every request and constantly changing, it is nearly 
                    impossible for an attacker to pre-create the URLs/requests for an attack AND bypass 
                    the token check.
                    While a CSRF token can prevent many malicious requests, it can still fail. If an application is vulnerable to Cross-Site Scripting (XSS) attack, a hacker could use their XSS attack to extract this token!
                    As an extra layer of security, we can ask users to re-authenticate by manually enter 
                    additional information prior to a critical request. For example, prior to changing a 
                    username, email, or password, we may want the user to enter their current password. 
                    By ensuring the request has the correct password, we can ensure that an attacker isn’t 
                    able to easily compromise a user, even with XSS.
                    </li>
                </ul>
                <li><strong>SQL Injection</strong></li>
                <ul>
                    <li>When you log in to Codecademy, you provide a username and password which are used 
                    to authenticate you. When you provide these 
                    credentials, the Codecademy server will take your input and compare it against user 
                    data inside a database.
                    That step of checking the input against the database can be abused by attackers. 
                    Through a cleverly and carefully crafted input an attacker can inject code directly 
                    into the database query, getting precious data.
                    A hacker can use their knowledge of the SQL language to cleverly construct text 
                    inputs that modify the backend SQL query to their liking. They can force the 
                    application to output private data or respond in ways that provide intel.
                    Here are some types:</li>
                    <ul>
                        <li><strong>Union-Based Injections</strong></li>
                        <li><strong>Error-Based Injections</strong></li>
                        <li><strong>Boolean-Based Injections</strong></li>
                        <li><strong>Time-Based Injections</strong></li>
                        <li><strong>Out-of-Band SQL Injections</strong></li>
                    </ul>
                    <li><strong>Prevention: </strong>
                    There are two main methods for preventing injection attacks: sanitization and prepared statements.
                    <strong>Video Implementation</strong>
                    <a href="https://www.youtube.com/watch?v=SwBz06hM_XY&embeds_euri=https%3A%2F%2Fwww.codecademy.com%2F&embeds_origin=https%3A%2F%2Fwww.codecademy.com&source_ve_path=MjM4NTE&feature=emb_title" target="_blank">here</a>.</li>
                    <ul>
                        <li><strong>Sanitization: </strong>When it comes to SQL injections, we would want to escape 
                        dangerous characters such as: <i>' ; \--</i>
                        While this does provide a layer of protection, this method isn’t perfect. If 
                        a user finds a way to bypass your sanitization process, they can easily inject 
                        data into your system. 
                        Additionally, depending on your query, removing certain characters may have no 
                        effect! Therefore, this shouldn’t be your only defense mechanism.
                        <strong>validator.js</strong> is a library of string validators and sanitizers 
                        that can be used server-side with Node.js. validator.js can be used to validate 
                        forms and sanitize inputs before using a form value in the application code
                        (that's different from express-validator, which is sanitization for express
                        framework). <strong>A list of all validators methods</strong> <a href="https://www.npmjs.com/package/validator" target="_blank">here</a>.</li>
                        <pre>
                            <code>
                const validator = require('validator');

                app.post('/submit', 
                (req, res) => {
                    console.log( validator.isEmail(req.body.email)); 
                })
                            </code>
                        </pre>
                        <li><strong>Prepared Statements:</strong>
                        Arguably, the best technique to protect against SQL injections
                        Writing prepared statements (also known as parameterized queries) in backend code 
                        is a common, reliable, and secure solution against SQL injections. 
                        Prepared statements are nearly foolproof.
                        Prepared statements are predefined SQL queries that take user
                        input and place them into placeholders using array syntax.</li>
                    </ul>   
                    <p class="center"><strong>Example:</strong></p>
                    <button id="showCode70" onclick="showCode('displayCode70', 'showCode70')">Display</button>
                    <div id="displayCode70">
                        <button onclick="closeCode('displayCode70', 'showCode70')">Close</button>
                        <li><strong>How does it work? </strong>We provide the database the query we want 
                        to execute in advance.
                        First, a SQL query template is sent to the database. Certain values, called 
                        parameters, are left unspecified. For example, user input.
                        The database processes the query and performs optimizations.
                        Values are bound to the parameters and the SQL query is executed.
                        Then we pass in the parameters/user input. Any input, regardless of whether the 
                        content has SQL syntax, is then treated only as a parameter and will not be treated
                        as SQL code. In addition to providing added security, prepared 
                        statements also make queries far more efficient.</li>
                        <li>Consider this insecure SQLite database query that directly constructs the query 
                        string from user input:</li>
                        <pre>
                            <code>
            db.get(`SELECT * FROM Employee  WHERE FirstName = ${req.body.firstName} 
                AND LastName =  ${req.body.lastName}`, (error, results) => {
                    ...
            });
                            </code>
                        </pre>
                        <li>The query can be reconstructed to use the following <strong>array syntax</strong>, where the 
                        first element replaces the first question mark, and the second element replaces 
                        the second question mark.
                        This minimal change ensures that the input strings are properly escaped and 
                        special characters are removed, preventing SQL injection attacks.</li>
                        <pre>
                            <code>
            db.all("SELECT * FROM Employee  WHERE FirstName = ? AND LastName = ? ", 
                [req.body.lastName, req.body.firstName], 
                (error, results) => {
                ...
            });
                            </code>
                        </pre>
                        <li>Another way to implement prepared statements is to use <strong>named placeholders</strong>. 
                        Instead of using an array, we use an <strong>object to map</strong> the parameters to the query 
                        variables. Consider the following prepared statement using placeholders:</li>
                        <pre>
                            <code>
            db.all("SELECT * FROM Employee  WHERE FirstName = ? AND LastName = ? ", 
                [req.body.lastName, req.body.firstName], 
                (error, results) => {
                ...
            });
                            </code>
                        </pre>
                        <li>The query can be reconstructed to use named placeholders by replacing the <i>?</i> with 
                        a variable beginning with the <i>$</i> character, and passing an object that maps to the
                        named placeholder value. This minimal change makes the code more readable for complicated queries.</li>
                        <pre>
                            <code>
            db.all("SELECT * FROM Employee  WHERE FirstName = $firstName 
            AND LastName = $lastName ", 
                {
                    $firstName: req.body.firstName,
                    $lastName: req.body.lastName
                },
                (error, results) => {
                ...
            });
                            </code>
                        </pre>
                    </div>
                </ul>
            </ul>
            <hr/>
            <h3>Defensive Coding In Javascript</h3>
            <ul>
                <li><strong>Dangerous Code</strong></li>   
                <ul> 
                    <li><strong>The eval Function </strong>
                    in JavaScript takes a string as an argument and executes it as Javascript source code. 
                    The functions, <i>setInterval()</i>, <i>setTimeout()</i>, and new <i>Function()</i> use <i>eval()</i> 
                    in their implementations, and should be used with the same caution.
                    We might be able to mitigate this risk with npm packages like 
                    <a href="https://github.com/hacksparrow/safe-eval" target="_blank">safe-eval</a> and 
                    <a href="https://www.npmjs.com/package/expression-eval" target="_blank">expression-eval</a>. 
                    Both allow us to limit which methods and properties are available to eval(). 
                    Best practices with eval are: Avoid using it altogether!
                    If you must use it, use a safer version, and only allow trusted, non-user input.</li>
                    <li><strong>The exec method </strong> takes a string as an argument 
                    and runs it as a shell command, enabling shell syntax within JavaScript. The danger is 
                    that unrestricted commands can access, modify, and delete files.
                    The <strong><i>execFile()</i></strong> method is an alternative that works similarly 
                    to <strong><i>exec()</i></strong> but requires 
                    separation of the commands and its arguments. This prevents piped commands and path 
                    variable access. This separation ensures that an attacker cannot inject their malicious 
                    commands. Whereas exec will allow for additional unintended commands in the input,
                    execFile will detect an error.</li>
                    <li><strong>fs Module</strong>
                    The file system, or fs, module in Node.js enables file system operations. 
                    It gives us access to methods like: <i>chmod()</i> to change file permissions,
                    <i>mkdir()</i> to create directories, <i>rmdir()</i> to delete directories and many more.
                    The fs module coupled with improperly sanitized user input gives attackers access to our 
                    entire file system and exposes it to path traversal and file inclusion vulnerabilities.
                    To mitigate the risk, we can tweak our code to restrict traversal scope to a directory 
                    of our choice. We use the <i>join()</i> method of the path method to combine our desired directory with 
                    the user-provided file name. Hiding the directory the server is operating on makes 
                    it tougher to reach valuable information.</li>
                    <pre>
                        <code>
                const user_input = "example.txt"
                const root_directory = process.cwd();    // Hard-code path to restrict scope
                const filePath = path.join(root_directory , fileName);
                fs.unlinkSync(filePath);
                        </code>
                    </pre>
                    <li><strong>Regular Expressions</strong>
                    are used in almost every single programming language to validate whether user input 
                    adheres to an expected condition. Attackers can make use of insecure regex expressions 
                    to trigger a <a href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS" target="_blank">Regular expression Denial of Service (ReDoS)</a>.
                    The <strong>RegEx</strong> engine can take a large amount of time on poorly defined Regex expressions. 
                    To prevent this danger, we can use the <strong>validator</strong> npm package. It provides a library of 
                    string validators and sanitizers for things like IP addresses, emails, and phone numbers. 
                    For Regex expression we must write ourselves, we can use tools like the safe-regex npm 
                    package to detect dangerous regular expressions.
                    We encourage you to take a look at some examples in the 
                    <a href="https://www.npmjs.com/package/safe-regex" target="_blank">safe-regex</a> documentation.</li>
                </ul>
                <li><strong>Secure Your Code</strong></li>
                <li><strong>Video Implementation: </strong>
                <a href="https://www.youtube.com/watch?v=MJ-ZzgqCblI" target="_blank">here</a>.</li>
                <ul>
                    <li><strong>Strict Mode: </strong>
                    Let’s learn about some defensive tools. One of them is JavaScript’s strict mode. 
                    Using strict mode throws errors that would otherwise be silent, which can help reveal 
                    vulnerabilities. To invoke strict mode, simply put "use strict"; in single or double
                    quotes on top of your JavaScript file.</li>
                    <li><strong>Static Code Analysis: </strong>
                    Static Code Analysis evaluates a code without executing it. A lint, or linter, is a 
                    static code analysis tool used to improve source code by finding and flagging 
                    programming errors, bugs, and patterns that may compromise security. Some of the
                    most popular JavaScript linters are: ESLint, JSLint, JSHint.
                    </li>
                </ul>
            </ul>
            <hr/>
            <h3>Managing Environment Variables, API keys, AND files in NODE.JS</h3>
            <ul>
                <li>Exposing sensitive developer-only data like credentials and keys remains a common mistake.
                This vulnerability counts as <strong>Sensitive Data Exposure</strong>, one of OWASP’s top ten web application security risks.
                We will introduce how to store sensitive application data securely into environment variables. 
                We will also learn how .gitignore helps you control which files, folders, and secrets we want to 
                display in public code repositories.</li>
                <li><strong>Environment Variables:</strong>
                An environment variable is no different than other variables we use while programming. It is used to store 
                information we want to reference in a program. The only difference is that it’s a key-value pair whose value 
                is set and stored outside a program, usually by the operating system or the production environment. 
                Environment variables can prevent the secret development keys and passwords from getting out. 
                They also reward us with more efficient coding in the long run. 
                Environment variables are not recommended for every situation because they are global variables.
                On a large-scale application, global variables can be hard to keep track of.
                Whether the database is hosted online or locally, it is generally a good idea to keep database credentials 
                in the .env file rather than hard-coding it. This ensures our database is not exposed on accidental pushes 
                to a git repository and allows for quick configuration when distributing or deploying our project on a 
                different environment. While the credentials may differ depending on the database, the following are 
                typically present in each database: <strong>Host IP address, Port, Username, Password</strong>.
                <strong>API keys</strong> also must be kept in .env, since it can be used by others, and the API price
                would go high above. </li>
                <pre>
                    <code>
                    DB_HOST=123.45.678.90
                    DB_USER=root
                    DB_PASS=123456
                    API_KEY=V3rYPubl1cK3y
                    </code>
                </pre>
                <ul>
                    <li>We must initialize them in a file called .env (note the dot in the beginning). We can create 
                    this file by running the command <strong><i>touch .env</i></strong>.
                    Node.js stores all the environment variables into a <strong>global variable</strong> called <strong>process.env</strong>. 
                    We can use a npm package called <strong>dotenv</strong> 
                    (documentation <a href="https://github.com/motdotla/dotenv#readme" target="_blank">here</a>) 
                    to load all our environment variables 
                    from .env to process.env, allowing us to access them in our program - you’d normally have to use 
                    the command npm install dotenv to install the dotenv package. We need to set <strong>.gitignore</strong>
                    so the .env file doesn't upload to a repository.</li>
                </ul>
                <li><strong>Environment Variables vs Config Variables </strong>
                share some similarities; choosing one comes down to the developer’s preference and environment. 
                While a <strong>config.json</strong> file allows us to have a greater variety of data types and complex data structures,
                the data in a <strong>.env</strong> file is generally more intelligible. Moreover, some online hosting platforms 
                natively support environment variables. At the end of the day, they both accomplish the same purpose: keeping your 
                information secure.</li>
                <li><strong>Environment Variables and Project Collaboration: </strong>             
                The best practice when it comes to working as part of a team or shared project is to include 
                a sample .env file in the public repository as a template 
                for the next person. This would usually be named <strong>sample.env</strong> or <strong>example.env</strong>. This file contains 
                the names of all the environment variables we need to run a project but their values are empty.
                Writing <strong>comments</strong> to explain each variable is recommended and it helps to group related variables. 
                Other developers can simply add their credentials and rename this file to .env. Take a look at 
                the example.env file in the workspace.
                It’s also best practice to provide instructions for obtaining someone’s own credentials or API keys 
                in the project <strong>README.md</strong> file. Take a look at the README.md in the workspace for an example.
                Just be careful to NOT add the sample.env file or the README.md to .gitignore.</li>
            </ul>
            <hr/>
            <ul>
                <h3>Remediation and Incident Response</h3>
                <li>In Cybersecurity, the term <strong>incident</strong> is when something bad happens, like a breach or 
                policy violation, that harms or potentially harms the security of a system. While a big 
                part of security is preventing incidents from happening in the first place, the reality 
                is that sooner or later, there’s going to be an incident.
                <strong>NIST (the United States National Institute of Standards and Technology)</strong> 
                runs the Computer Security Research Center (CSRC), whose recommendations and guides are 
                highly respected within the industry. NIST Guide
                <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-61r2.pdf" target="_blank">here</a></li>
                <ul>
                    <li><strong>Remediation: </strong>NIST defines remediation as “The act of mitigating a vulnerability or 
                    a threat”. In simple terms, remediation is simply “the process of fixing a security issue”. 
                    It could be patching a vulnerability in a piece of software, removing malware from 
                    an infected computer, or kicking a malicious attacker out of a network. Not all 
                    remediation comes as the result of an incident; arguably the best remediation happens 
                    before the security issue can evolve into an incident.</li>
                    <li><strong>Incident response: </strong>NIST defines incident response as “The mitigation of violations of security 
                    policies and recommended practices.”, but a simpler definition might be “everything 
                    that needs to happen to investigate and recover from an incident”.
                    Incident response begins before an incident even occurs, with preparations to ensure 
                    that an organization is able to respond quickly when an incident does occur. These 
                    preparations can include training, ensuring access to tools, and creating incident 
                    response plans that contain details about what to do when an incident happens.
                    <strong>Incident Response Playbook</strong> contains procedures outlining what needs 
                    to happen to respond to an incident. These playbooks contain information on what 
                    constitutes an incident, what procedures should be enacted and by who, who needs to 
                    be contacted, etc...</li>
                </ul>
            </ul>
        </div>
    </body>
</html>
