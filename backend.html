<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="./component/button.js" defer></script>
        <title>Backend</title>
        <nav>
            <ul class="mainNav">
                <li><a href="#">Menu</a></li>
                <li><a href="./AI.html">AI</a></li>
                <li><a href="./git.html">Git</a></li>
            </ul>
        </nav>
        <h1>Backend</h1>
    </header>
    <body>
        <div class="styleGuide">
            <ul>
                <li><a href="pages/express.html" target="_blank">Express.js</a></li>
                <li><a href="pages/postman.html" target="_blank">Postman</a></li>
                <li><a href="pages/userAuthSession.html" target="_blank">User Authentication / Authorization & Web Sessions</a></li>
                <li><a href="pages/testDriven.html" target="_blank">Test Driven (TDD)</a></li>
                <li><a href="pages/database.html" target="_blank">Database</a></li>
                <li><a href="pages/testDriven.html" target="_blank">WebSecurity</a></li>
                <li><a href="pages/nodeSqlite.html" target="_blank">Node SQLite</a></li>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Node.js</h2>
            <ul>
                <li><strong>Node</strong> provides the ability to run JavaScript programs on our own computers instead of just in the browser's 
                    console or embedded in HTML.</li>
                <ul>
                    <li>To <strong>run a program</strong> with node <i>$ node myProgram.js</i></li>
                </ul>
                <li><strong>Codecademy Material</strong> <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-introduction-to-back-end/modules/wdcp-22-back-end-javascript-with-node-js/cheatsheet" target="_blank">here</a></li>
                <li><strong>Node.js Documentation</strong> <a href="https://nodejs.org/en/docs/" target="_blank">here</a>.</li>
                <li><strong>nodemon</strong> is a tool that helps develop Node.js based applications by automatically 
                restarting the node application when file changes in the directory are detected. Documentation
                <a href="https://www.npmjs.com/package/nodemon" target="_blank">here</a></li>
            </ul>
            <hr/>
            <h3>REPL</h3>
            <ul>
               <li><strong>REPL</strong> is an abbreviation for <u>read-eval-print loop</u>. It's a program that loops, or 
                repeatedly cycles, through three different states: a read state where the program reads
                input from a user, the eval state where the program evaluates the user's input, and the
                print state where the program prints out its evaluation to a console.</li>
                <li>A REPL can be extremely useful for performing calculations, learning a language, and developing
                code. It’s a place where you can explore language features and try things out while receiving 
                immediate feedback.</li>
                <li>To access REPL, type <i>node</i> in the terminal.</li>
            </ul>
            <hr/>
            <h3>Modules</h3>
            <ul>
                <li><strong>Modules</strong> are reusable pieces of code in a file that can be exported and then
                imported for use in another file. A modular program is one whose components can be separated, 
                used individually, and recombined to create a complex system.
                <strong>Module</strong> tends to refer to larger bundles, whilst <strong>Components</strong>
                on the other hand tend to be smaller bundles of code, often smaller than a full class - 
                they tend to be a component of something larger.</li>
                <li>There are two runtime environments and each has a preferred module implementation:</li>
                <ul>
                    <li>The <strong>Node</strong> runtime environment: <i>module.exports</i> and <i>require()</i> syntax.</li>
                    <li>The <strong>browser’s</strong> runtime environment and the ES6 <i>import/export</i> syntax.</li>
                </ul>
                <li>Within Node.js applications, developers have access to a number of <strong>core modules</strong> that come 
                preshipped when you install Node.js onto your machine.</li>
                <li>There are also modules created by other developers - these third-party modules often solve common
                problems and simplify the development process. When we use these modules in our code, they are 
                referred to as <strong>dependencies</strong>.</li>
                <ul>
                    <li>Most of the time, these dependencies are installed in packages handled by a <strong>package manager</strong>.
                    A package is a third-party module wrapped up with the list of that module's own dependencies.
                    The most popular package manager is <strong>Node Package Manager(npm)</strong> which is the 
                    default package manager for Node.js. You can install it using:</li> 
                    <ul>
                        <li><i>npm i < package name ></i> or <i>npm install < package name ></i></li>
                        <li><i>npm i</i></li>
                        <li><i>npm i --production</i> If you wish to leave out development dependencies.</li>
                    </ul>
                    <li>Open source developers and developers at companies use the <strong>npm registry</strong> 
                    to contribute packages to the entire community or members of their organizations, and download
                    packages to use in their own projects.</li>
                </ul>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode33" onclick="showCode('displayCode33', 'showCode33')">Display</button>
            <div id="displayCode33">
                <button onclick="closeCode('displayCode33', 'showCode33')">Close</button>
                <ul>
                    <li><strong>module.exports</strong>:</li>
                    <pre>
                        <code>
                function celsiusToFahrenheit(celsius) {
                    return celsius * (9/5) + 32;
                }
                    
                module.exports.celsiusToFahrenheit = celsiusToFahrenheit;
                module.exports.fahrenheitToCelsius = function(fahrenheit) {
                    return (fahrenheit - 32) * (5/9);
                };
                        </code>
                    </pre>
                    <li><strong>require()</strong>:</li>
                    <pre>
                        <code>
            const converters = require('./converters.js');
 
            const freezingPointC = 0;
            const boilingPointC = 100;
            
            const freezingPointF = converters.celsiusToFahrenheit(freezingPointC);
            const boilingPointF = converters.celsiusToFahrenheit(boilingPointC);
            
            console.log(`The freezing point of water in Fahrenheit is ${freezingPointF}`);
            console.log(`The boiling point of water in Fahrenheit is ${boilingPointF}`);
                        </code>
                    </pre>
                    <li><strong>require()</strong> with <strong>destructuring</strong>:</li>
                    <pre>
                        <code>
            /* celsius-to-fahrenheit.js */
            const { celsiusToFahrenheit } = require('./converters.js');
            
            const celsiusInput = process.argv[2]; 
            const fahrenheitValue = celsiusToFahrenheit(celsiusInput);
            
            console.log(`${celsiusInput} degrees Celsius = ${fahrenheitValue} degrees Fahrenheit`);
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>Node Modules</h3>
            <ul>
                <li><strong>Core Modules: </strong>are built into the Node.js environment to efficiently 
                perform common tasks. To access core modules, inside REPL type: <i>require('module').builtinModules</i></li>
                <li><strong>Process Module: </strong>Node has a global process object with useful methods and 
                information about the <strong>current process.</strong>Type in the code:</li>
                <ul>
                    <li>The <strong>process.env</strong> property is an object which stores and controls information 
                    about the environment in which the process is currently running.</li>
                    <li>The <strong>process.memoryUsage()</strong> returns information on the CPU
                    demands of the current process.</li>
                    <li>The <strong>process.argv</strong> property holds an array of command line values provided 
                    when the current process was initiated.</li>
                </ul>
                <li><strong>OS Module: </strong>When developing or debugging an app, it can be helpful to have information about the 
                computer, operating system, and network on which the program is running.
                the os module is not global and needs to be included into the file in order to gain access to it’s methods. 
                You can include the os module into your file by typing: <i>const os = require('os');</i></li>
                <ul>
                    <li><strong>os.type()</strong> — to return the computer’s operating system.</li>
                    <li><strong>os.arch()</strong> — to return the operating system CPU architecture.</li>
                    <li><strong>os.networkInterfaces()</strong> — to return information about the network interfaces of the 
                    computer, such as IP and MAC address.</li>
                    <li><strong>os.homedir()</strong> — to return the current user’s home directory.</li>
                    <li><strong>os.hostname()</strong> — to return the hostname of the operating system.</li>
                    <li><strong>os.uptime()</strong> — to return the system uptime, in seconds.</li>
                </ul>
                <li><strong>Util Module:</strong> Utility functions don’t necessarily create new functionality 
                in a program, but you can think of them as internal tools used to maintain and debug your code.
                The Node.js util core module contains methods specifically designed for these purposes. 
                The util module can be required into the file using:<i> const util = require('util');</i></li>
                <ul>
                    <li><strong>types: </strong>which provides methods for runtime type checking in Node.</li>
                    <li><strong>promisify: </strong>turns callback functions into promises.</li>
                </ul>
                <li><strong>Event Module: </strong>
                Node.js has an EventEmitter class which can be accessed by importing the events core 
                module by using the <i>require()</i> statement. Each event emitter instance has an <i>.on()</i> method
                which assigns a listener callback function to a named event. EventEmitter also has an <i>.emit()</i> 
                method which announces a named event that has occurred.</li>
                <li><strong>Error Module: </strong>Within our own code, we can generate errors and throw them, and, with synchronous
                code in Node, we can use error handling techniques such as <i>try...catch</i> statements.
                However we cannot use try...catch when the error is thrown asynchronously. Many asynchronous Node APIs use
                error-first callback functions—callback functions which have an error as the first expected argument and the data as
                the second argument. If the asynchronous task results in an error, it will be passed in as the first argument to the
                callback function. If no error was thrown, the first argument will be undefined.</li>
                <li><strong>Input/Output: </strong>Input is data that is given to the computer, while output is 
                any data or feedback that a computer provides. In Node, we can get input from a user using the 
                <i>stdin.on()</i> method on the process object. We are able to use this because <i>.on()</i> is an instance 
                of EventEmitter. To give an output, we can use the <i>.stdout.write()</i> method on the process object
                as well. This is because <i>console.log()</i> is a thin wrapper on .stdout.write().</li>
                <li><strong>Buffer Module: </strong>Is used to handle binary data. 
                It provides a variety of methods to handle the binary data such as .alloc(), .toString(), .from(), and .concat()</li>
                <ul>
                    <li>The <strong>.alloc()</strong> Method: Allows a new Buffer object to be created with the 
                    size specified as the first argument. Optionally, a second argument can be provided to specify 
                    the fill and a third argument to specify the encoding.</li>
                    <li>The <strong>.toString()</strong> Method: A Buffer object can be translated into a human-readable 
                    string by chaining the .toString() method to a Buffer object. Optionally, encoding can be specified
                    as the first argument, byte offset to begin translating can be provided as the second argument, and
                    the byte offset to end translating as the third argument.</li>
                    <li>The <strong>.from()</strong> Method: A new Buffer object can be created from a specified string, 
                    array, or another Buffer object using the .from() method. Encoding can be specified optionally as the
                    second argument.</li>
                    <li>The <strong>.concat()</strong> Method: Joins all Buffer objects in the specified array into
                    one Buffer object. The length of the concatenated Buffer can be optionally provided as the second
                    argument. This method is useful because a Buffer object can't be resized.</li>
                </ul>
                <li><strong>FS Module (file system): </strong>All of the data on a computer is organized and accessed
                through a filesystem. When running JavaScript code on a browser, it’s important for a script to have
                only limited access to a user’s filesystem. This technique of isolating some applications from others
                is known as sandboxing. In the back-end, however, less restricted interaction with the filesystem is essential.
                The Node <strong>fs core module</strong> is an API for interacting with the file system.
                Import module via <i>require('fs');</i>
                The <strong>.readFile()</strong> Method: Reads data from a provided file.</li>
                <li><strong>Readable/Writable Streams: </strong>In most cases, data isn’t processed all at once but
                rather piece by piece. This is what we call streams. Streaming data is preferred as it doesn’t require
                tons of RAM and doesn’t need to have all the data on hand to begin processing it. To read files
                line-by-line, we can use the <i>.createInterface()</i> Method from the readline core module. We can write to
                streams by using the <i>.createWriteStream()</i> Method.</li>
                <li><strong>Timers Module:</strong> There are times when we want some of our code to be executed at a
                specified point in time. This is what the timers module is used for.
                Timer functions in Node.js behave similarly to how they work in front-end JavaScript programs,
                but the difference is that they are added to the Node.js event loop. This means that the timer
                functions are scheduled and put into a queue. This queue is processed at every iteration of the
                event loop. If a timer function is executed outside of a module, the behavior will be random (non-deterministic).</li>
                The <strong>setImmediate()</strong> function is often compared with the setTimeout() function.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode31" onclick="showCode('displayCode31', 'showCode31')">Display</button>
            <div id="displayCode31">
                <button onclick="closeCode('displayCode31', 'showCode31')">Close</button>
                <ul>
                    <li><strong>Event Module</strong></li>
                    <pre>
                        <code>
                let newUserListener = (data) => {
                    console.log(`We have a new user: ${data}.`);
                };
                    
                // Assign the newUserListener function as the listener callback for 'new user' events
                myEmitter.on('new user', newUserListener)
                
                // Emit a 'new user' event
                myEmitter.emit('new user', 'Lily Pad') //newUserListener will be invoked with 'Lily Pad'
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Error Module</strong></li>
                    <pre>
                        <code>
                const errorFirstCallback = (err, data)  => {
                    if (err) {
                    console.log(`There WAS an error: ${err}`);
                    } else {
                    // err was falsy
                    console.log(`There was NO error. Event data: ${data}`);
                    }
                }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Input/Output</strong></li>
                    <ul>
                        <li>In the Node environment, the console is the terminal, and the console.log() 
                        method is a “thin wrapper” on the .stdout.write() method of the process object. 
                        stdout stands for standard output.</li>
                    </ul>
                    <pre>
                        <code>
                process.stdout.write(
                "I'm thinking of a number from 1 through 10. What do you think it is?
                \n(Write \"quit\" to give up.)\n\nIs the number ... ");

                process.stdin.on('data', (userInput) => {
                    let input = userInput.toString()
                    console.log(input)
                });
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>FS Module</strong></li>
                    <ul>
                        <li>readFile()</li>
                        <pre>
                            <code>
                const fs = require('fs');

                let readDataCallback = (err, data) => {
                    if (err) {
                        console.log(`Something went wrong: ${err}`);
                    } else {
                        console.log(`Provided file contained: ${data}`);
                    }
                };
                
                fs.readFile('./file.txt', 'utf-8', readDataCallback);
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Read/Write Streams</strong></li>
                    <ul>
                        <li><strong>createInterface() </strong>& <strong>createReadStream()</strong></li>
                        <pre>
                            <code>
                const readline = require('readline');
                const fs = require('fs');
                
                const myInterface = readline.createInterface({
                    input: fs.createReadStream('text.txt')
                });
                
                myInterface.on('line', (fileLine) => {
                    console.log(`The line read: ${fileLine}`);
                });
                            </code>
                        </pre>
                        <li><strong>.createWriteStream()</strong></li>
                        <pre>
                            <code>
                const fs = require('fs')
                const fileStream = fs.createWriteStream('output.txt');
                
                fileStream.write('This is the first line!'); 
                fileStream.write('This is the second line!');
                fileStream.end();
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Timers Module</strong></li>
                    <ul>
                        <li><strong>setImmediate()</strong></li>
                        <pre>
                            <code>
                    setImmediate(() => {
                        console.log('Hello! My name is Codey.')
                    });
                            </code>
                        </pre>
                    </ul>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>CORS</h2>
            <ul>
                <li><strong>Cross-origin resource sharing (CORS)</strong> is a standard mechanism that allows JavaScript XMLHttpRequest 
                (XHR) calls executed in a web page to interact with resources from non-origin domains (different domains that are outside
                current). The CORS standard is needed because it allows servers to specify not only who can access the 
                assets, but also how they can be accessed.</li>
                <li>Servers will allow GET requests, meaning they will allow resources from external origins (say, a web page) 
                to read their assets. HTTP requests methods like PATCH, PUT, or DELETE, however, may be denied to prevent
                malicious behavior. For many servers, this is intentional. For example, it is likely that server A does not
                want servers B, C, or D to edit or delete its assets.
                <u>With CORS, a server can specify who can access its assets and which HTTP request methods are allowed 
                from external resources - like building with a security entrance. For example, if you need to borrow a 
                ladder, you could ask a neighbor in the building who has one. The building’s security would likely not 
                have a problem with this request (i.e., same-origin). If you needed a particular tool, however, and 
                you ordered it from an outside source like an online marketplace (i.e., cross-origin), the security 
                at the entrance may request that the delivery person provide identification when your tool arrives.</u></li>
                <li>An <strong>HTTP header</strong> is a piece of information associated with a request or a response.
                Headers are passed back and forth between your web browser (also referred to as a client) and a server when
                the web page you are on wants to use resources hosted on a different server. Headers are used to describe requests
                and responses. The CORS standard manages cross-origin requests by adding new HTTP headers to the standard list of headers. </li>
                <ul>
                    <li><strong>Access-Control-Allow-Origin:</strong> This header allows servers to specify how their resources are shared with external domains. 
                    When a GET request is made to access a resource on Server A, Server A will respond with a value for the Access-Control-Allow-Origin
                    header. Many times, this value will be *, meaning that Server A will share the requested resources with any domain on the 
                    Internet. Other times, the value of this header may be set to a particular domain (or list of domains), meaning that 
                    Server A will share its resources with that specific domain (or list of domains). The Access-Control-Allow-Origin 
                    header is critical to resource security.</li>
                    <li>List of <strong>Headers</strong><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#cors" target="_blank">here</a>.</li>
                </ul>
                <li><strong>Pre-flight request: </strong>
                Most servers will allow GET requests but may block requests to modify resources on the server. 
                Servers don’t just blindly block such requests; they have a process in place that first checks and then communicates 
                to the client (your web browser) which requests are allowed. When a request is made using any of the following HTTP request 
                methods, a standard preflight request will be made before the original request PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.    
                Preflight requests use the OPTIONS header. The preflight request is sent before the original request, 
                hence the term “preflight.” The purpose of the preflight request is to determine whether or not the original request is safe (for example, a 
                DELETE request). The server will respond to the preflight request and indicate whether or not the original request is safe. If the server specifies 
                that the original request is safe, it will allow the original request. Otherwise, it will block the original request.</li>
                <hr/>
                <h3>How to implement CORS?</h3>
                <li><strong>Cross-origin request</strong>s are made using the <strong>standard HTTP request</strong> methods. Most servers will allow 
                GET requests, meaning they will allow resources from external origins (say, a web page) to read their 
                assets. HTTP requests methods like PATCH, PUT, or DELETE, however, may be denied to prevent malicious 
                behavior. For many servers, this is intentional. For example, it is likely that server A does not want 
                servers B, C, or D to edit or delete its assets.
                <strong>Headers</strong> are passed back and forth between your web browser (also referred to as a client) and a server 
                when the web page you are on wants to use resources hosted on a different server. Headers are used to 
                describe requests and responses. The CORS standard manages cross-origin requests by adding new HTTP 
                headers to the standard list of headers. A descriptive list of all HTTP headers added by 
                the CORS standard. 
                <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#CORS" target="_blank">here</a>.</li>
                <li>Implementing the request headers to set up CORS correctly depends on the language and framework of 
                the backend.</li>
                <ul>
                    <li>If you are using Node, you can use setHeader(), <i>response.setHeader('Content-Type', 'text/html');</i>.</li>
                    <li>If you are using Express, you can use CORS middleware: <i>$ npm install cors</i></li>
                </ul>
                <pre>
                    <code>                   
                    var express = require('express');
                    var cors = require('cors');
                    var app = express();
                     
                    app.use(cors());
                     
                    app.get('/hello/:id', function (req, res, next) {
                      res.json({msg: 'Hello world, we are CORS-enabled!'});
                    });
                     
                    app.listen(80, function () {
                      console.log('CORS-enabled web server is listening on port 80');
                    });
                    </code>
                </pre>
            </ul>
        </div>
    </body>
</html>
