<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="./component/button.js" defer></script>
        <title>Backend</title>
    </header>
    <body>
        <nav>
            <ul class="mainNav">
                <li><a href="./index.html">Cheat Sheet</a></li>
                <li><a href="./displayProperties.html">Display Properties</a></li>
                <li><a href="./objects.html">Objects</a></li>
                <li><a href="./developmentCycle.html">Development Cycle</a></li>
                <li><a href="./debug.html">Debug</a></li>
                <li><a href="./git.html">Git</a></li>
                <li><a href="./form.html">Form</a></li>
                <li><a href="./api.html">API</a></li>
                <li><a href="./react.html">REACT</a></li>
                <li><a href="./helpfulContent.html">Helpful Content</a></li>
                <li><a href="#">Backend</a></li>
            </ul>
        </nav>
        <header>
            <h1>Backend</h1>
        </header>
        <div class="styleGuide">
            <h2>Node.js</h2>
            <ul>
                <li><strong>Node</strong> provides the ability to run JavaScript programs on our own computers instead of just in the browser's 
                    console or embedded in HTML.</li>
                    <ul>
                        <li>To <strong>run a program</strong> with node <i>$ node myProgram.js</i></li>
                    </ul>
                <li><strong>Codecademy Material</strong> <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-introduction-to-back-end/modules/wdcp-22-back-end-javascript-with-node-js/cheatsheet" target="_blank">here</a></li>
                <li><strong>Node.js Documentation</strong> <a href="https://nodejs.org/en/docs/" target="_blank">here</a>.</li>
                <li><strong>nodemon</strong> is a tool that helps develop Node.js based applications by automatically 
                restarting the node application when file changes in the directory are detected. Documentation
                <a href="https://www.npmjs.com/package/nodemon" target="_blank">here</a></li>
            </ul>
            <hr/>
            <h3>REPL</h3>
            <ul>
               <li><strong>REPL</strong> is an abbreviation for <u>read-eval-print loop</u>. It's a program that loops, or 
                repeatedly cycles, through three different states: a read state where the program reads
                input from a user, the eval state where the program evaluates the user's input, and the
                print state where the program prints out its evaluation to a console.</li>
                <li>A REPL can be extremely useful for performing calculations, learning a language, and developing
                code. It’s a place where you can explore language features and try things out while receiving 
                immediate feedback.</li>
                <li>To access REPL, type <i>node</i> in the terminal.</li>
            </ul>
            <hr/>
            <h3>Modules</h3>
            <ul>
                <li><strong>Modules</strong> are reusable pieces of code in a file that can be exported and then
                imported for use in another file. A modular program is one whose components can be separated, 
                used individually, and recombined to create a complex system.
                <strong>Module</strong> tends to refer to larger bundles, whilst <strong>Components</strong>
                on the other hand tend to be smaller bundles of code, often smaller than a full class - 
                they tend to be a component of something larger.</li>
                <li>There are two runtime environments and each has a preferred module implementation:</li>
                <ul>
                    <li>The <strong>Node</strong> runtime environment: <i>module.exports</i> and <i>require()</i> syntax.</li>
                    <li>The <strong>browser’s</strong> runtime environment and the ES6 <i>import/export</i> syntax.</li>
                </ul>
                <li>Within Node.js applications, developers have access to a number of <strong>core modules</strong> that come 
                preshipped when you install Node.js onto your machine.</li>
                <li>There are also modules created by other developers - these third-party modules often solve common
                problems and simplify the development process. When we use these modules in our code, they are 
                referred to as <strong>dependencies</strong>.</li>
                <ul>
                    <li>Most of the time, these dependencies are installed in packages handled by a <strong>package manager</strong>.
                    A package is a third-party module wrapped up with the list of that module's own dependencies.
                    The most popular package manager is <strong>Node Package Manager(npm)</strong> which is the 
                    default package manager for Node.js. You can install it using:</li> 
                    <ul>
                        <li><i>npm i < package name ></i> or <i>npm install < package name ></i></li>
                        <li><i>npm i</i></li>
                        <li><i>npm i --production</i> If you wish to leave out development dependencies.</li>
                    </ul>
                    <li>Open source developers and developers at companies use the <strong>npm registry</strong> 
                    to contribute packages to the entire community or members of their organizations, and download
                    packages to use in their own projects.</li>
                </ul>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode33" onclick="showCode('displayCode33', 'showCode33')">Display</button>
            <div id="displayCode33">
                <button onclick="closeCode('displayCode33', 'showCode33')">Close</button>
                <ul>
                    <li><strong>module.exports</strong>:</li>
                    <pre>
                        <code>
                function celsiusToFahrenheit(celsius) {
                    return celsius * (9/5) + 32;
                }
                    
                module.exports.celsiusToFahrenheit = celsiusToFahrenheit;
                module.exports.fahrenheitToCelsius = function(fahrenheit) {
                    return (fahrenheit - 32) * (5/9);
                };
                        </code>
                    </pre>
                    <li><strong>require()</strong>:</li>
                    <pre>
                        <code>
            const converters = require('./converters.js');
 
            const freezingPointC = 0;
            const boilingPointC = 100;
            
            const freezingPointF = converters.celsiusToFahrenheit(freezingPointC);
            const boilingPointF = converters.celsiusToFahrenheit(boilingPointC);
            
            console.log(`The freezing point of water in Fahrenheit is ${freezingPointF}`);
            console.log(`The boiling point of water in Fahrenheit is ${boilingPointF}`);
                        </code>
                    </pre>
                    <li><strong>require()</strong> with <strong>destructuring</strong>:</li>
                    <pre>
                        <code>
            /* celsius-to-fahrenheit.js */
            const { celsiusToFahrenheit } = require('./converters.js');
            
            const celsiusInput = process.argv[2]; 
            const fahrenheitValue = celsiusToFahrenheit(celsiusInput);
            
            console.log(`${celsiusInput} degrees Celsius = ${fahrenheitValue} degrees Fahrenheit`);
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>Node Modules</h3>
            <ul>
                <li><strong>Core Modules: </strong>are built into the Node.js environment to efficiently 
                perform common tasks. To access core modules, inside REPL type: <i>require('module').builtinModules</i></li>
                <li><strong>Process Module: </strong>Node has a global process object with useful methods and 
                information about the <strong>current process.</strong>Type in the code:</li>
                <ul>
                    <li>The <strong>process.env</strong> property is an object which stores and controls information 
                    about the environment in which the process is currently running.</li>
                    <li>The <strong>process.memoryUsage()</strong> returns information on the CPU
                    demands of the current process.</li>
                    <li>The <strong>process.argv</strong> property holds an array of command line values provided 
                    when the current process was initiated.</li>
                </ul>
                <li><strong>OS Module: </strong>When developing or debugging an app, it can be helpful to have information about the 
                computer, operating system, and network on which the program is running.
                the os module is not global and needs to be included into the file in order to gain access to it’s methods. 
                You can include the os module into your file by typing: <i>const os = require('os');</i></li>
                <ul>
                    <li><strong>os.type()</strong> — to return the computer’s operating system.</li>
                    <li><strong>os.arch()</strong> — to return the operating system CPU architecture.</li>
                    <li><strong>os.networkInterfaces()</strong> — to return information about the network interfaces of the 
                    computer, such as IP and MAC address.</li>
                    <li><strong>os.homedir()</strong> — to return the current user’s home directory.</li>
                    <li><strong>os.hostname()</strong> — to return the hostname of the operating system.</li>
                    <li><strong>os.uptime()</strong> — to return the system uptime, in seconds.</li>
                </ul>
                <li><strong>Util Module:</strong> Utility functions don’t necessarily create new functionality 
                in a program, but you can think of them as internal tools used to maintain and debug your code.
                The Node.js util core module contains methods specifically designed for these purposes. 
                The util module can be required into the file using:<i> const util = require('util');</i></li>
                <ul>
                    <li><strong>types: </strong>which provides methods for runtime type checking in Node.</li>
                    <li><strong>promisify: </strong>turns callback functions into promises.</li>
                </ul>
                <li><strong>Event Module: </strong>
                Node.js has an EventEmitter class which can be accessed by importing the events core 
                module by using the <i>require()</i> statement. Each event emitter instance has an <i>.on()</i> method
                which assigns a listener callback function to a named event. EventEmitter also has an <i>.emit()</i> 
                method which announces a named event that has occurred.</li>
                <li><strong>Error Module: </strong>Within our own code, we can generate errors and throw them, and, with synchronous
                code in Node, we can use error handling techniques such as <i>try...catch</i> statements.
                However we cannot use try...catch when the error is thrown asynchronously. Many asynchronous Node APIs use
                error-first callback functions—callback functions which have an error as the first expected argument and the data as
                the second argument. If the asynchronous task results in an error, it will be passed in as the first argument to the
                callback function. If no error was thrown, the first argument will be undefined.</li>
                <li><strong>Input/Output: </strong>Input is data that is given to the computer, while output is 
                any data or feedback that a computer provides. In Node, we can get input from a user using the 
                <i>stdin.on()</i> method on the process object. We are able to use this because <i>.on()</i> is an instance 
                of EventEmitter. To give an output, we can use the <i>.stdout.write()</i> method on the process object
                as well. This is because <i>console.log()</i> is a thin wrapper on .stdout.write().</li>
                <li><strong>Buffer Module: </strong>Is used to handle binary data. 
                It provides a variety of methods to handle the binary data such as .alloc(), .toString(), .from(), and .concat()</li>
                <ul>
                    <li>The <strong>.alloc()</strong> Method: Allows a new Buffer object to be created with the 
                    size specified as the first argument. Optionally, a second argument can be provided to specify 
                    the fill and a third argument to specify the encoding.</li>
                    <li>The <strong>.toString()</strong> Method: A Buffer object can be translated into a human-readable 
                    string by chaining the .toString() method to a Buffer object. Optionally, encoding can be specified
                    as the first argument, byte offset to begin translating can be provided as the second argument, and
                    the byte offset to end translating as the third argument.</li>
                    <li>The <strong>.from()</strong> Method: A new Buffer object can be created from a specified string, 
                    array, or another Buffer object using the .from() method. Encoding can be specified optionally as the
                    second argument.</li>
                    <li>The <strong>.concat()</strong> Method: Joins all Buffer objects in the specified array into
                    one Buffer object. The length of the concatenated Buffer can be optionally provided as the second
                    argument. This method is useful because a Buffer object can't be resized.</li>
                </ul>
                <li><strong>FS Module (file system): </strong>All of the data on a computer is organized and accessed
                through a filesystem. When running JavaScript code on a browser, it’s important for a script to have
                only limited access to a user’s filesystem. This technique of isolating some applications from others
                is known as sandboxing. In the back-end, however, less restricted interaction with the filesystem is essential.
                The Node <strong>fs core module</strong> is an API for interacting with the file system.
                Import module via <i>require('fs');</i>
                The <strong>.readFile()</strong> Method: Reads data from a provided file.</li>
                <li><strong>Readable/Writable Streams: </strong>In most cases, data isn’t processed all at once but
                rather piece by piece. This is what we call streams. Streaming data is preferred as it doesn’t require
                tons of RAM and doesn’t need to have all the data on hand to begin processing it. To read files
                line-by-line, we can use the <i>.createInterface()</i> Method from the readline core module. We can write to
                streams by using the <i>.createWriteStream()</i> Method.</li>
                <li><strong>Timers Module:</strong> There are times when we want some of our code to be executed at a
                specified point in time. This is what the timers module is used for.
                Timer functions in Node.js behave similarly to how they work in front-end JavaScript programs,
                but the difference is that they are added to the Node.js event loop. This means that the timer
                functions are scheduled and put into a queue. This queue is processed at every iteration of the
                event loop. If a timer function is executed outside of a module, the behavior will be random (non-deterministic).</li>
                The <strong>setImmediate()</strong> function is often compared with the setTimeout() function.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode31" onclick="showCode('displayCode31', 'showCode31')">Display</button>
            <div id="displayCode31">
                <button onclick="closeCode('displayCode31', 'showCode31')">Close</button>
                <ul>
                    <li><strong>Event Module</strong></li>
                    <pre>
                        <code>
                let newUserListener = (data) => {
                    console.log(`We have a new user: ${data}.`);
                };
                    
                // Assign the newUserListener function as the listener callback for 'new user' events
                myEmitter.on('new user', newUserListener)
                
                // Emit a 'new user' event
                myEmitter.emit('new user', 'Lily Pad') //newUserListener will be invoked with 'Lily Pad'
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Error Module</strong></li>
                    <pre>
                        <code>
                const errorFirstCallback = (err, data)  => {
                    if (err) {
                    console.log(`There WAS an error: ${err}`);
                    } else {
                    // err was falsy
                    console.log(`There was NO error. Event data: ${data}`);
                    }
                }
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Input/Output</strong></li>
                    <ul>
                        <li>In the Node environment, the console is the terminal, and the console.log() 
                        method is a “thin wrapper” on the .stdout.write() method of the process object. 
                        stdout stands for standard output.</li>
                    </ul>
                    <pre>
                        <code>
                process.stdout.write(
                "I'm thinking of a number from 1 through 10. What do you think it is?
                \n(Write \"quit\" to give up.)\n\nIs the number ... ");

                process.stdin.on('data', (userInput) => {
                    let input = userInput.toString()
                    console.log(input)
                });
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>FS Module</strong></li>
                    <ul>
                        <li>readFile()</li>
                        <pre>
                            <code>
                const fs = require('fs');

                let readDataCallback = (err, data) => {
                    if (err) {
                        console.log(`Something went wrong: ${err}`);
                    } else {
                        console.log(`Provided file contained: ${data}`);
                    }
                };
                
                fs.readFile('./file.txt', 'utf-8', readDataCallback);
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Read/Write Streams</strong></li>
                    <ul>
                        <li><strong>createInterface() </strong>& <strong>createReadStream()</strong></li>
                        <pre>
                            <code>
                const readline = require('readline');
                const fs = require('fs');
                
                const myInterface = readline.createInterface({
                    input: fs.createReadStream('text.txt')
                });
                
                myInterface.on('line', (fileLine) => {
                    console.log(`The line read: ${fileLine}`);
                });
                            </code>
                        </pre>
                        <li><strong>.createWriteStream()</strong></li>
                        <pre>
                            <code>
                const fs = require('fs')
                const fileStream = fs.createWriteStream('output.txt');
                
                fileStream.write('This is the first line!'); 
                fileStream.write('This is the second line!');
                fileStream.end();
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Timers Module</strong></li>
                    <ul>
                        <li><strong>setImmediate()</strong></li>
                        <pre>
                            <code>
                    setImmediate(() => {
                        console.log('Hello! My name is Codey.')
                    });
                            </code>
                        </pre>
                    </ul>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>Express.js</h2>
            <ul>
                <li><strong>Express.js: </strong>Is a server-side framework built upon Node.js. A server-side framework can handle 
                a lot of the back-end responsibilities without needing to come up with a custom solution, which
                saves a lot of time. This workflow might include things like accessing databases, generating HTML,
                handling URL routing, access to libraries built to work with the framework, existing resources and
                documentation for solving common problems, improved security.</li>
                <li>Express Documentation <a href="https://expressjs.com/en/4x/api.html" target="_blank">here</a>.</li>
                <li>Express simple explanation <a href="https://www.freecodecamp.org/news/going-out-to-eat-and-understanding-the-basics-of-express-js-f034a029fb66/" target="_blank">here</a>.</li>
                <li>Express API Project <a href="https://codecademy-content.s3.amazonaws.com/PRO/independent-practice-projects/quote-api/quote-api-solution.zip" target="_blank">here</a>.</li>
                <li>Boss machine full project<a href="https://content.codecademy.com/PRO/skill-paths/backend-javascript/projects/boss-machine/project-4-boss-machine-solution.zip" target="_blank">here</a></li>
                <hr/>
                <h3>Initiating</h3>
                <li>Express is a Node module, so in order to use it, we will need to import it into our program file
                with <i>require('express')</i>.</li>
                <li><strong>app.listen():</strong> The purpose of a server is to listen for requests, perform whatever action is required to satisfy 
                the request, and then return a response. In order for our server to start responding, as first argument
                we have to tell the server where to listen for new requests by providing a port number argument to a method called 
                <i>app.listen()</i>. The server will then listen on the specified port and respond to any requests that come 
                into it. The second argument is a callback function that will be called once the server is running and ready to receive responses.</li>
            </ul>
            <hr/>
            <h3>Routes</h3>
            <ul>
                <li><strong>Routes: </strong>registering a series of routes we tell our server how to deal with any given request. 
                It defines the control flow for requests based on the request's path and HTTP verb.
                For example, if your server receives a GET request at <i>/monsters</i>, we will use a route to
                define the appropriate functionality for that HTTP verb (GET) and path (/monsters).</li>
                <ul>
                    <li><i>localhost:4001/monsters</i>, the path is <i>/monsters</i>, hostname is <i>localhost</i>, the port
                    number is <i>4001</i>).</li>
                    <li>Express tries to match requests by route, meaning that if we send a request to 
                    < server address >:< port number ><i>/api-endpoint</i>, the Express server will search through any
                    registered routes in order that they are registered in your code and try to match <i>/api-endpoint</i>.
                    The first one that is matched will be used, and its callback will be called.</li>
                </ul>
                <li><strong>Route Parameters: </strong>Makes Routes dynamic. Parameters are route path segments 
                    that begin with <i>:</i> in their Express route definitions. They act as wildcards, matching any
                    text at that path segment. For example <i>/monsters/:id</i> will match <i>both/monsters/1</i>
                    and <i>/monsters/45</i>.</li>
                <ul>
                    <li>Express parses any parameters, extracts their actual values, and attaches them as an object
                    to the request object: <strong>req.params</strong>. This object’s keys are any parameter names
                    in the route, and each key’s value is the actual value of that field per request.</li>
                    <li>Not all APIs implement route parameters but when they do, it most commonly does not access
                    sensitive data, unless it also requires to have an API key to access the response from such route.</li>
                    <li><strong>router.param()</strong>: When working with routes that require parameters, we might find
                    ourselves in a position where multiple different routes require the same parameter and use it to 
                    identify the same piece of data.router.param.</li>
                </ul>
                <li><strong>Merge Parameters: </strong>When we’re building web endpoints, we might want to access 
                some property of a complex object. In order to do this in Express, we can design a nested router. 
                This would be a router that is invoked within another router. In order to pass parameters the parent 
                router has access to, we pass a special configuration object when defining the router.</li>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode38" onclick="showCode('displayCode38', 'showCode38')">Display</button>
                <div id="displayCode38">
                    <button onclick="closeCode('displayCode38', 'showCode38')">Close</button>
                    <ul>
                        <li><strong>router.param()</strong></li>
                        <pre>
                            <code>
                    app.param('spellId', (req, res, next, id) => {
                        let spellId = Number(id);
                        try {
                        const found = SpellBook.find((spell) => {
                            return spellId === spell.id;
                        })
                        if (found) {
                            req.spell = found;
                            next();
                        } else {
                            next(new Error('Your magic spell was not found in any of our tomes'));
                        };
                        } catch (err) {
                            next(err)
                        }
                    });
                            </code>
                        </pre>
                        <li><strong>Full example:</strong></li>
                        <pre>
                            <code>
                const express = require('express');
                const app = express();
                const bodyParser = require('body-parser');

                app.use(express.static('public'));

                const PORT = process.env.PORT || 4001;

                const spiceRack = [
                {
                    id: 1,
                    name: 'cardamom',
                    grams: 45,
                },
                {
                    id: 2,
                    name: 'pimento',
                    grams: 20,
                },
                {
                    id: 3,
                    name: 'cumin',
                    grams: 450,
                },
                {
                    id: 4,
                    name: 'sichuan peppercorns',
                    grams: 107,
                }
                ];

                let nextSpiceId = 5;

                app.use(bodyParser.json());

                // Add your code here:
                app.param('spiceId', (req, res, next, id) => {
                const spiceId = Number(id);
                const spiceIndex = spiceRack.findIndex(spice => spice.id === spiceId);
                
                if (spiceIndex !== -1){
                    req.spiceIndex = spiceIndex;
                    next();
                } else {
                    res.sendStatus(404);
                }
                })


                app.get('/spices/', (req, res, next) => {
                res.send(spiceRack);
                });

                app.post('/spices/', (req, res, next) => {
                const newSpice = req.body.spice;
                if (newSpice.name  && newSpice.grams) {
                    newSpice.id = nextSpiceId++;
                    spiceRack.push(newSpice);
                    res.send(newSpice);
                } else {
                    res.status(400).send();
                }
                });

                app.get('/spices/:spiceId', (req, res, next) => {
                res.send(spiceRack[req.spiceIndex]);
                });

                app.put('/spices/:spiceId', (req, res, next) => {
                spiceRack[req.spiceIndex] = req.body.spice;
                res.send(spiceRack[req.spiceIndex]);
                });

                app.delete('/spices/:spiceId', (req, res, next) => {
                spiceRack.splice(req.spiceIndex, 1);
                res.status(204).send();
                });

                app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
                });
                            </code>
                        </pre>
                        <hr/>
                        <li><strong>Merge Parameters:</strong></li>
                        <pre>
                            <code>
            const sorcererRouter = express.Router();
            const familiarRouter = express.Router({mergeParams: true});
                
            sorcererRouter.use('/:sorcererId/familiars', familiarRouter);
                
            sorcererRouter.get('/', (req, res, next) => {
                res.status(200).send(Sorcerers);
                next();
            });
                
            sorcererRouter.param('sorcererId', (req, res, next, id) => {
                const sorcerer = getSorcererById(id);   
                req.sorcerer = sorcerer;
                next();
            });
                
            familiarRouter.get('/', (req, res, next) => {
                res.status(200).send(`Sorcerer ${req.sorcerer} has familiars ${getFamiliars(sorcerer)}`);
            });
                
            app.use('/sorcerer', sorcererRouter);
                            </code>
                        </pre>
                    </ul>
                </div>
                <hr/>
            </ul>
            <h3>CRUD</h3>
            <ul>
                <li>app.get, app.put, app.post, app.delete are used to connect with api requests.
                This is the cleanest order to use:</li>
                    <ul>
                        <li>GET <i>/expressions/</i></li>
                        <li>GET <i>/expressions/:id</i></li>
                        <li>PUT <i>/expressions/:id</i></li>
                        <li>DELETE <i>/expressions/:id</i></li>
                    </ul>
                <li><strong>app.get():</strong> Registers routes to match GET requests. Express routes (including
                app.get()) usually take two arguments, a path (usually a string), and a callback function to handle
                the request and send a response.</li>
                <ul>
                    <li><strong>res: </strong>Facilitates how we can submit responses by providing a response 
                    object, commonly seen as: res, and it represents the HTTP response that we will emit when 
                    we receive an HTTP request to any of our endpoints. Inside of it, we just need to pass
                    the data of the response using:</li>
                    <ul>
                        <li><strong>.send()</strong>: Express servers send responses using the <i>.send()</i> method on the
                        response object. <i>.send()</i> will take any input and include it in the response body.</li>
                        <li><strong>.json()</strong>: can also be used to explicitly send JSON-formatted responses. 
                        <i>.json()</i> sends any JavaScript object passed into it.</li>
                    </ul>
                </ul>
                <li><strong>app.post(): </strong>POST request are use to create a new resource.
                The client does not know the id of the monster until it is created and sent back by the server, therefore
                POST /monsters/:id doesn’t make sense because a client couldn’t know the unique id of a monster before it
                exists.</li>
                <li><strong>app.put(): </strong>PUT requests are used for updating existing resources. 
                For this reason, it's needed to include a unique identifier 
                as a route parameter to determine which specific resource to update.</li> 
                <li><strong> app.delete(): </strong>Deletes currently existing data. Their paths should usually 
                end with a route parameter to indicate which resource to delete.</li>
                <li><strong>Query string: </strong>Is a part of a uniform resource locator (URL) that assigns values
                to specified parameters. Query strings appear at the end of the path in URLs, and they are indicated 
                with a <i>?</i> character. For instance, in <i>/monsters/1?name=chimera&age=1</i>, the query string is 
                <i>name=chimera&age=1</i> and the path is <i>/monsters/1/</i> Query strings do not count as part of the route path. I</li>    
                <ul>
                    <li><strong>req.query: </strong>This property is an object containing a property for each query string parameter 
                    in the route. When query parser is set to disabled, it is an empty object {}, otherwise it is the result of the 
                    configured query parser.</li>
                    <li><strong>req.param</strong> vs <strong>req.query</strong>: Both are closely related but they are not the same at all, params are parameters set for the route, query are 
                    values resembling variable assignment that provide extra information on what is being required for the route and
                    it will always start with a ? on the URL, inherently they are both string values that express extrapolates into
                    objects and key/value pairs from the req object.</li>
                    <ul>
                        <li><strong>req.param:</strong> <i>/lor/creatures/:name</i> if we were to make a request <i>/lor/creatures/gollum</i> gollum is the 
                        name parameter and so we could find it in the object as: req.params.name which equals to gollum.</li>
                        <li><strong>req.query:</strong> <i>/lor/creatures/hobbit?familyname=Baggins&home=Shire</i> we get two query parameters, familyname 
                        and home, this way we can get each as <i>req.query.familyname</i> which is Baggins and <i>req.query.home</i> which is Shire.</li>
                    </ul>
                </ul>
                <li><strong>app.use(express.static('public')):</strong> This is used to make sure that once the 
                server is started, you can reload the browser and render on it.
                The static method of express allows us to serve all the static files of our application, that is to say,
                all HTML, CSS, and JS files that will comprise the front end visuals on the browser. In our case:
                express.static('public');
                Public is the name of the directory where we find those files, for example, in our execise 37:</li>
                <li><strong>Status Codes: </strong> Response codes provide information to clients about how their 
                requests were handled. Any res.send() has by default sent a 200 OK status code.
                The res object has a <i>.status()</i> method to allow us to set the status code,
                and other methods like .send() can be chained from it.</li>
                <li><strong>Glossary of status code </strong><a href="https://www.webfx.com/web-development/glossary/http-status-codes/" target="_blank">here</a>.</li>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode34" onclick="showCode('displayCode34', 'showCode34')">Display</button>
                <div id="displayCode34">
                    <button onclick="closeCode('displayCode34', 'showCode34')">Close</button>
                    <li>In a real setting API server, <u>the data doesn't exist in arrays and objects within the file</u> as 
                    the examples underneath.
                    The reason is that it will not be <strong>persisting data</strong>, since if we keep it as an object, or an array of values 
                    or even an array of objects in the file, every time we were to stop the server, all changes will disappear since 
                    the file will only have whatever we wrote in it but not any further changes introduced.
                    That is why in real APIs we also implement storage technologies like <strong>SQL</strong> or <strong>NoSQL</strong> databases, 
                    <strong>yaml files</strong>, and <strong>cloud storage</strong> 
                    services for which we need to learn and implement other libraries or their documentation on how we communicate with them 
                    within our express server.</li>
                    <hr/>
                    <li><strong>Importing</strong> Express.js, <strong>app.listen()</strong>,
                    <strong>app.get()</strong>, <strong>send()</strong>,
                    <strong>app.put()</strong>, <strong>app.post()</strong>, <strong>app.delete()</strong> 
                    & <strong>app.use()</strong>.</li>
                    <pre>
                        <code>
            //Importing express.js
            const express = require('express');
            const app = express();

            // Use static server to serve the Express Yourself Website
                so to reload and render on the browser
            app.use(express.static('public'));

            const { getElementById, getIndexById, updateElement,
            seedElements, createElement } = require('./utils');

            const PORT = process.env.PORT || 4001;

            // Variables that stores data, that'll be 
                requested, created, updated and deleted
            const expressions = [];
            seedElements(expressions, 'expressions');
            const animals = [];
            seedElements(animals, 'animals');

            // Get all expressions
            app.get('/expressions', (req, res, next) => {
                res.send(expressions);
            });

            // Get a single expression (based on ID)
            app.get('/expressions/:id', (req, res, next) => {
                const foundExpression = getElementById(req.params.id, expressions);
                if (foundExpression) {
                    res.send(foundExpression);
                } else {
                    res.status(404).send();
                }
            });

            // Update an expression (based on ID)
            app.put('/expressions/:id', (req, res, next) => {
                const expressionIndex = getIndexById(req.params.id, expressions);
                //getIndexById will return -1 if the expressions array 
                    doesn’t contain an element with that id.
                //updateElement will throw an error if you pass in
                    an id that doesn’t exist in the array
                if (expressionIndex !== -1) {
                    updateElement(req.params.id, req.query, expressions);
                    res.send(expressions[expressionIndex]);
                } else {
                    res.status(404).send();
                }
            });

            // Create an expression
            app.post('/expressions', (req, res, next) => {
                const receivedExpression = createElement('expressions', req.query);
                if (receivedExpression) {
                    expressions.push(receivedExpression);
                    res.status(201).send(receivedExpression);
                } else {
                    res.status(400).send();
                }
            });

            // Delete an expression (based on ID)
            app.delete('/expressions/:id', (req, res, next) => {
                const expressionIndex = getIndexById(req.params.id, expressions);
                //getIndexById will return -1 for a non-existent ID,
                and the proper index if it exists. 
                Then you can use the splice method to remove the element.
                if (expressionIndex !== -1) {
                    expressions.splice(expressionIndex, 1);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            });

            // Get all animals
            app.get('/animals', (req, res, next) => {
                res.send(animals);
            });

            // Get a single animal
            app.get('/animals/:id', (req, res, next) => {
                const animal = getElementById(req.params.id, animals);
                if (animal) {
                    res.send(animal);
                } else {
                    res.status(404).send();
                }
            });

            // Create an animal
            app.post('/animals', (req, res, next) => {
                const receivedAnimal = createElement('animals', req.query);
                if (receivedAnimal) {
                    animals.push(receivedAnimal);
                    res.status(201).send(receivedAnimal);
                } else {
                    res.status(400).send();
                }
            });

            // Update an animal
            app.put('/animals/:id', (req, res, next) => {
                const animalIndex = getIndexById(req.params.id, animals);
                if (animalIndex !== -1) {
                    updateElement(req.params.id, req.query, animals);
                    res.send(animals[animalIndex]);
                } else {
                    res.status(404).send();
                }
            });

            // Delete a single animal
            app.delete('/animals/:id', (req, res, next) => {
                const animalIndex = getIndexById(req.params.id, animals);
                if (animalIndex !== -1) {
                    animals.splice(animalIndex, 1);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on ${PORT}`);
            });
                        </code>
                    </pre>
                    <hr/>
                    <li><strong>app.put</strong> & <strong>req.params</strong>, <strong>req.query</strong>.</li>
                    <pre>
                        <code>
            const express = require('express');
            const app = express();

            const PORT = process.env.PORT || 4001;

            const currencies = {
                diram: {
                    countries: ['UAE', 'Morocco'],
                },
                real: {
                    countries: ['Brazil'],
                },
                dinar: {
                    countries: ['Algeria', 'Bahrain', 'Jordan', 'Kuwait'],
                },
                vatu: {
                    countries: ['Vanuatu'],
                },
                shilling: {
                    countries: ['Tanzania', 'Uganda', 'Somalia', 'Kenya'],
                },
            };

            app.put('/currencies/:name/countries', (req, res, next) => {
                const currencyName = req.params.name; //param ":name" from PUT request
                const countries = req.query; //value property from the key: value
                currencies[currencyName] = countries;  //query: value assign to parameter

                if(currencies[currencyName]){
                    res.send(currencies[currencyName]);
                } else {
                res.status(404).send();
                }
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });

                        </code>
                    </pre>
                    <li><strong>app.post</strong> & <strong>req.query</strong>.</li>
                    <pre>
                        <code>
            const express = require('express');
            const app = express();

            const PORT = process.env.PORT || 4001;

            const soups = ['gazpacho', 'borscht', 'primordial', 'avgolemono', 'laksa'];

            app.post('/soups', (req, res, next) => {
                const soup = req.query.name;
                soups.push(soup);
                res.status(201).send(soup);
            })

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });

                        </code>
                    </pre>
                    <li><strong>app.delete</strong> & <strong>req.params</strong></li>
                    <hr/>
            const express = require('express');
            const app = express();

            const PORT = process.env.PORT || 4001;

            const puddingFlavors = ['chocolate', 'banana', 'butterscotch', 'pistachio'];

            const findPuddingIndex = (name) => {
                return puddingFlavors.indexOf(name);
            }

            const deletePuddingAtIndex = (index) => {
                puddingFlavors.splice(index, 1);
            }

            app.delete('/puddings/:flavor', (req, res, next) => {
                const index = findPuddingIndex(req.params.flavor);
                if(index !== -1){
                    deletePuddingAtIndex(index);
                    res.status(204).send();
                } else {
                    res.status(404).send();
                }
            })

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });
                    <hr/>
                    <li><strong>Route Parameters</strong>:</li>
                    <ul>
                        <pre>
                            <code>
                const monsters = { 
                    hydra: { height: 3, age: 4 }, 
                    dragon: { height: 200, age: 350 } 
                };

                // GET /monsters/hydra
                app.get('/monsters/:name', (req, res, next) => {
                    console.log(req.params); // { name: 'hydra' }
                    res.send(monsters[req.params.name]);
                });
                            </code>
                        </pre>
                        <li>Another example:</li>
                        <pre>
                            <code>
            const express = require('express');
            const app = express();

            app.use(express.static('public'));

            const { getElementById, seedElements } = require('./utils');

            const expressions = [];
            seedElements(expressions, 'expressions');

            const PORT = process.env.PORT || 4001;

            app.get('/expressions', (req, res, next) => {
                res.send(expressions);
            });

            app.get('/expressions/:id', (req, res, next) => {
                const foundExpression = getElementById(req.params.id, expressions);
                res.send(foundExpression);
            });

            app.listen(PORT, () => {
                console.log(`Listening on port ${PORT}`);
            });
                            </code>
                        </pre>
                    </ul>    
                    <hr/>
                    <li><strong>Status Code:</strong></li>
                    <pre>
                        <code>
            const monsterStoreInventory = { fenrirs: 4, 
                                            banshees: 1, 
                                            jerseyDevils: 4, 
                                            krakens: 3 };
            
            app.get('/monsters-inventory/:name', (req, res, next) => {
                const monsterInventory = monsterStoreInventory[req.params.name];
                if (monsterInventory) {
                    res.send(monsterInventory);
                } else {
                    res.status(404).send('Monster not found');
                }
            });
                        </code>
                    </pre>
                </div>
            </ul>
                <hr/>
            <h3>Express.Router</h3>
                <ul>
                    <li>Routers are mini versions of Express applications — they provide functionality for handling 
                    route matching, requests, and sending responses.
                    Generally, we will keep each router in its own file, and require them in the main application. 
                    (because of reusability, scalability and cleaness). 
                    For example, having a router file that specifies all routes and depending on the main route, 
                    it will use the respective file that handles the request to that route.
                    We can use it with <strong>express.Router()</strong>.</li>
                    <li>Is very common having a <i>router.js</i> file that handles all the route connections.</li>
                    <li>Routers nested within nested routers <a href='https://discuss.codecademy.com/t/why-would-we-nest-routers-in-nested-routers/394943' target="_blank">here</a>.</li>
                    <li>To use a router, we mount it at a certain path using <strong>app.use()</strong> and pass in the router as the
                    second argument. This router will now be used for all paths that begin with that path segment.</li>
                    <li><strong>Documentation</strong> on Routing <a href="https://expressjs.com/en/guide/routing.html" target="_blank">here</a>.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode35" onclick="showCode('displayCode35', 'showCode35')">Display</button>
                <div id="displayCode35">
                    <button onclick="closeCode('displayCode35', 'showCode35')">Close</button>
                    <ul>
                        <li><strong>Express.Router</strong></li>
                        <ul>
                            <li>The code below contains all the monsters specific code. In a more full-fledged API, this file
                            would contain multiple routes. To use this router in another file, we use <strong>module.exports</strong>
                            so that other files can access monstersRouter. The only other new line of code required is
                            that Express must be required in each file, since we’ll need to create a router with 
                            <i>express.Router()</i>.</li>
                        </ul>
                        <pre>
                            <code>
                // monsters.js
                const express = require('express');
                const monstersRouter = express.Router();
                    
                const monsters = {
                    '1': {
                        name: 'godzilla',
                        age: 250000000
                    },
                    '2': {
                        Name: 'manticore',
                        age: 21
                    }
                }
                    
                monstersRouter.get('/:id', (req, res, next) => {
                    const monster = monsters[req.params.id];
                    if (monster) {
                        res.send(monster);
                    } else {
                        res.status(404).send();
                    }
                });
                    
                module.exports = monstersRouter;
                            </code>
                        </pre>
                        <li>Our <i>main.js</i> file could then be refactored to import the monstersRouter:</li>
                        <pre>
                            <code>
                            // main.js
                            const express = require('express');
                            const app = express();
                            const monstersRouter = require('./monsters.js');
                             
                            app.use('/monsters', monstersRouter);
                            </code>
                        </pre>
                    </ul>
                </div>
                <hr/>
                <h3>Middleware</h3>
                <ul>
                    <li><strong>DRY</strong>ing Routes With app.use().
                    A path can be written as optional, to write middleware that will run for every request at a specific 
                    path. It can also be even an array of routes to reference more than one path.</li>
                    <li><strong>Middleware</strong> is code that executes between a server receiving a request and
                    sending a response. It operates on the boundary, so to speak, between those two HTTP actions.
                    Middleware is a function that can perform logic on the request and response objects, such
                    as: inspecting a request, performing some logic based on the request, attaching information to the 
                    response, attaching a status to the response, sending the response back to the user, or simply passing
                    the request and response to another middleware. Middleware can do any combination of those things or
                    anything else a Javascript function can do.</li>
                    <li><strong>Middleware stack: </strong> Is a chain of middleware. Most of Express's functionality is 
                    chaining middleware. <u>Express routes are middleware</u>. Every route created in Express is also a 
                    middleware function handling the request and response objects at that part of the stack.</li>
                    <ul>
                        <li>The routes are called in the order that they appear in the file, provided the previous route
                        called <strong>next()</strong> and thus passed control to the next middleware.</li>
                        <li>An Express middleware is a function with three parameters: <i>(req, res, next)</i>.
                        The third argument to a middleware function, <i>next</i>, should get explicitly called as the last 
                        part of the middleware’s body. This will hand off the processing of the request and the construction
                        of the response to the next middleware in the stack.</li>
                        <li><u>We don’t always want to pass control to the <i>next</i> middleware in the stack.</u>
                        For example, when designing a system with confidential information, we want to be able to selectively 
                        show that information to authorized users. In order to do that, we would create middleware that tests 
                        a user’s permissions. If the user has the permission necessary, we would continue through the middleware 
                        stack by calling <i>next()</i>. If it fails, we would want to let the user know that they’re not allowed to see 
                        the information they’re trying to access.</li>
                    </ul>
                    <li>Since middleware is just a function with a specific signature, namely <i>(req, res, next)</i>, 
                    we can define functions and using them as middleware.
                    We can remove the <i>app.use()</i> line and replace it with a specific route method, or sprinkle it throughout
                    the application without it being universal.
                    With modular pieces like this, it is useful to know that methods such as <i>app.use()</i>, <i>app.get()</i>, 
                    <i>app.post()</i>, and so on all can take multiple callbacks as additional parameters.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode36" onclick="showCode('displayCode36', 'showCode36')">Display</button>
                <div id="displayCode36">
                    <button onclick="closeCode('displayCode36', 'showCode36')">Close</button>
                    <ul>
                        <li><strong>app.use()</strong> & <strong>next()</strong></li>
                        <pre>
                            <code>
            //A path can be written as optional 
                so to write middleware that will run
                for every request at a specific path.
                It can be even an array of routes
                to reference more than one path.
            app.use([path, anotherPath](req, res, next) => {
                console.log("A sorcerer approaches!");
                next();
            });
                
            app.get('/magic/:spellname', (req, res, next) => {
                console.log("The sorcerer is casting a spell!");
                next();
            });
                
            app.get('/magic/:spellname', (req, res, next) => {
                console.log(`The sorcerer has cast ${req.params.spellname}`);
                res.status(200).send();
            });
                
            app.get('/magic/:spellname', (req, res, next) => {
                console.log("The sorcerer is leaving!");
            });
                
            // Accessing http://localhost:4001/magic/fireball 
            // Console Output:
            // "A sorcerer approaches!"
            // "The sorcerer is casting a spell!"
            // "The sorcerer has cast fireball"
                                </code>
                            </pre>
                            <hr/>
                            <li>Other example:</li>
                            <pre>
                                <code>
            const express = require('express');
            const app = express();

            app.use(express.static('public'));

            const PORT = process.env.PORT || 4001;

            const jellybeanBag = {
                mystery: {
                    number: 4
                },
                lemon: {
                    number: 5
                },
                rootBeer: {
                    number: 25
                },
                cherry: {
                    number: 3
                },
                licorice: {
                    number: 1
                }
            };

            // Logging Middleware 
                (this below could be changed for Morgan)
            app.use((req, res, next) => {
                console.log(`${req.method} Request Received`);
                next('Bag with that name does not exist');
            });

            app.use('/beans/:beanName', (req, res, next) => {
                const beanName = req.params.beanName;
                if (!jellybeanBag[beanName]) {
                    res.status(404).send('Bag with that name does not exist');
                    return console.log('Response Sent');
                }
                req.bean = jellybeanBag[beanName];
                req.beanName = beanName;
                next();
            });

            app.get('/beans/', (req, res, next) => {
                res.send(jellybeanBag);
                console.log('Response Sent');
            });

            app.post('/beans/', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
            });

            // This below could be changed for bodyParser.
            req.on('end', () => {
                const body = JSON.parse(bodyData);
                const beanName = body.name;
                if (jellybeanBag[beanName] || jellybeanBag[beanName] === 0) {
                    return res.status(404).send('Bag with that name already exists!');
                }
                const numberOfBeans = Number(body.number) || 0;
                jellybeanBag[beanName] = {
                    number: numberOfBeans
                };
                res.send(jellybeanBag[beanName]);
                console.log('Response Sent');
                });
            });

            app.get('/beans/:beanName', (req, res, next) => {
                res.send(req.bean);
                console.log('Response Sent');
            });

            app.post('/beans/:beanName/add', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
            });

            req.on('end', () => {
                const numberOfBeans = Number(JSON.parse(bodyData).number) || 0;
                req.bean.number += numberOfBeans;
                res.send(req.bean);
                console.log('Response Sent');
                });
            });

            app.post('/beans/:beanName/remove', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
            });

            req.on('end', () => {
                const numberOfBeans = Number(JSON.parse(bodyData).number) || 0;
                if (req.bean.number < numberOfBeans) {
                    return res.status(400).send('Not enough beans in the jar to remove!');
                }
                req.bean.number -= numberOfBeans;
                res.send(req.bean);
                console.log('Response Sent');
                });
            });

            app.delete('/beans/:beanName', (req, res, next) => {
                jellybeanBag[req.beanName] = null;
                res.status(204).send();
                console.log('Response Sent');
            });

            app.put('/beans/:beanName/name', (req, res, next) => {
                let bodyData = '';
                req.on('data', (data) => {
                    bodyData += data;
                });

                req.on('end', () => {
                    const newName = JSON.parse(bodyData).name;
                    jellybeanBag[newName] = req.bean;
                    jellybeanBag[req.beanName] = null;
                    res.send(jellybeanBag[newName]);
                    console.log('Response Sent');
                });
            });

            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });
                                </code>
                            </pre>
                            <li>In the below code sample, we created reusable middleware for authentication and data validation. 
                            We use the authenticate() middleware to verify a user is logged in before proceeding with the request
                            and we use the validateData() middleware before performing the appropriate create or update function.
                            Additional middleware can be placed at any point in this chain.</li>
                            <pre>
                                <code>
            const authenticate = (req, res, next) => {
            ...
            };
            
            const validateData = (req, res, next) => {
            ...
            };
            
            const getSpell = (req, res, next) => {
                res.status(200).send(getSpellById(req.params.id));
            };
            
            const createSpell = (req, res, next) => {
                createSpellFromRequest(req);
                res.status(201).send();
            };
            
            const updateSpell = (req, res, next) => {
                updateSpellFromRequest(req);
                res.status(204).send();
            }
            
            app.get('/spells/:id', authenticate, getSpell);
            
            app.post('/spells', authenticate, validateData, createSpell);
            
            app.put('/spells/:id', authenticate, validateData, updateSpell);
                                </code>
                            </pre>
                        </ul>
                    </div>
                <h3>Open-Source Middleware</h3>
                <ul>
                    <li>If we needed to write a web server from scratch every time we wanted to build a web application, 
                    we’d waste a lot of time solving problems that have been solved countless times before and ignoring
                    perfectly good pre-existing solutions. Luckily for us web developers, Express already exists as an
                    <strong>open-source package</strong> that we can install and use to build upon. There is a huge ecosystem of Javascript
                    packages that will solve so many of the problems that developers frequently run into.</li>
                    <li><strong>Morgan: </strong>Is an open-source library for logging (console.log) information about the HTTP request-response
                    cycle in a server application. <i>morgan()</i> is a function that will return a middleware function 
                    that will have the function signature <i>(req, res, next)</i> that can be inserted into an <i>app.use()</i>,
                    and that function will be called before all following middleware functions. Morgan takes an argument 
                    to describe the formatting of the logging output. For example, <i>morgan('tiny')</i> will return a middleware 
                    function that does a “tiny” amount of logging. With morgan in place, we’ll be able to remove the existing logging code.</li>
                    <ul>
                        <li>Morgan's <strong>documentation</strong> <a href="https://github.com/expressjs/morgan" target="_blank">here</a>.</li>
                    </ul>
                    <li><strong>Body-parser: </strong>Simplifies a perform request body parsing. That substituted a lot
                    of the req.on code from the previous examples.</li>
                    <ul>
                        <li>Body-parser <strong>documentation</strong> <a href="https://github.com/expressjs/body-parser#body-parser" target="_blank">here</a>.</li>
                    </ul>
                    <li><strong>List of middlewares</strong> <a href="https://expressjs.com/en/resources/middleware.html" target="_blank">here</a>.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode37" onclick="showCode('displayCode37', 'showCode37')">Display</button>
                <div id="displayCode37">
                    <button onclick="closeCode('displayCode37', 'showCode37')">Close</button>
                    <ul>
                        <li><strong>Morgan</strong></li>
                        <pre>
                            <code>
            const express = require('express');
            const morgan = require('morgan');
            const app = express();

            //This will console.log 
                (`${req.method} Request Received`) 
                to every router.
            app.use(morgan('tiny'));

            //This will console .log 
                :method :url :status :response-time ms - :res[content-length]
                to every router.
            app.use(morgan('dev')); 
                            </code>
                        </pre>
                        <li><strong>Body-Parser</strong></li>
                        <pre>
                            <code>
            const bodyParser = require('body-parser');

            app.use(bodyParser.json());
                            </code>
                        </pre>
                        <li>Full code example: <strong>Morgan</strong> & <strong>body-parser</strong></li>
                        <pre>
                            <code>
            const express = require('express');
            const app = express();
            const morgan = require('morgan');
            const bodyParser = require('body-parser');

            app.use(express.static('public'));

            const PORT = process.env.PORT || 4001;

            const cards = [
                {
                    id: 1,
                    suit: 'Clubs',
                    rank: '2'
                },
                {
                    id: 2,
                    suit: 'Diamonds',
                    rank: 'Jack'
                },
                {
                    id: 3,
                    suit: 'Hearts',
                    rank: '10'
                }
            ];
            let nextId = 4;

            // Logging
            if (!process.env.IS_TEST_ENV) {
                app.use(morgan('short'));
            }

            // Parsing
            app.use(bodyParser.json());

            // Find card
            app.use('/cards/:cardId', (req, res, next) => {
                const cardId = Number(req.params.cardId);
                const cardIndex = cards.findIndex(card => card.id === cardId);
                if (cardIndex === -1) {
                    return res.status(404).send('Card not found');
                }
                req.cardIndex = cardIndex;
                next();
            });

            const validateCard = (req, res, next) => {
            const newCard = req.body;
            const validSuits = ['Clubs', 'Diamonds', 'Hearts', 'Spades'];
            const validRanks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King', 'Ace'];
            if (validSuits.indexOf(newCard.suit) === -1 || validRanks.indexOf(newCard.rank) === -1) {
                return res.status(400).send('Invalid card!');
            }
                next();
            };

            // Get all Cards
            app.get('/cards/', (req, res, next) => {
                res.send(cards);
            });

            // Create a new Card
            app.post('/cards/', validateCard, (req, res, next) => {
                const newCard = req.body;
                newCard.id = nextId++;
                cards.push(newCard);
                res.status(201).send(newCard);
            });

            // Get a single Card
            app.get('/cards/:cardId', (req, res, next) => {
                res.send(cards[req.cardIndex]);
            });

            // Update a Card
            app.put('/cards/:cardId', validateCard, (req, res, next) => {
                const newCard = req.body;
                const cardId = Number(req.params.cardId);
                if (!newCard.id || newCard.id !== cardId) {
                    newCard.id = cardId;
                }
                cards[req.cardIndex] = newCard;
                res.send(newCard);
            });

            // Delete a Card
            app.delete('/cards/:cardId', (req, res, next) => {
                cards.splice(req.cardIndex, 1);
                res.status(204).send();
            });

            // Start the server
            app.listen(PORT, () => {
                console.log(`Server is listening on port ${PORT}`);
            });
                            </code>
                        </pre>
                    </ul>
                </div>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Postman</h2>
            <ul>
                <li>Postman is a GUI that aids in the development of APIs by 
                making it easy to test requests and their responses in an organized way.</li>
                <li>API requests with <strong>Postman</strong>(GUI) & <strong>cURL</strong>(Command Line)
                <a href="https://www.taniarascia.com/making-api-requests-postman-curl/" target="_blank">here</a></li>
                <hr/>
                <h3>API Requests</h3>
                <li><strong>Initializing: </strong>
                Set the URL connected to the server & the HTTP method.</li>
                <li><strong>GET: </strong>
                Write proper URL to GET request.</li>
                <li><strong>POST: </strong> It is <u>non-idempotent</u>, meaning that two identical 
                POST requests will create two new resources.<br>
                Select <strong>POST</strong> method, Body => Raw (set to JSON), 
                write the Post request. As the output, an id will be created as a property
                inside "user". Example: </li>
                <pre><code>{"user": {"username": "Victor", "password": "Rego"}}</code></pre>
                <li><strong>PUT: </strong>It is <u>idempotent</u>, meaning that two identical PUT requests will modify the same
                resource.<br>
                A <strong>PUT</strong> request requires the entire body to be sent through; if any data 
                is missing, that data will be wiped (except automatic values like auto-incrementing 
                IDs and timestamps).</li>
                <li><strong>PATCH: </strong>Updates an existing resource, and does not require
                sending the entire body with the request.</li>
                <li><strong>DELETE: </strong>Removes a resource. No values to send.</li>
                <li><strong>Authentication: </strong>
                In Postman, you'll go to Headers and add Authorization as the key and Bearer < JWT_TOKEN > as
                the value to send authentication values. You can also go to Headers, click Presets, Manage
                Presets, and put your own reusable variables in for any headers or values you'll be reusing a lot.</li>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>CORS</h2>
            <ul>
                <li><strong>Cross-origin resource sharing (CORS)</strong> is a standard mechanism that allows JavaScript XMLHttpRequest 
                (XHR) calls executed in a web page to interact with resources from non-origin domains (different domains that are outside
                current). 
                The CORS standard is needed because it allows servers to specify not only who can access the assets, but also
                how they can be accessed.</li>
                <li>Servers will allow GET requests, meaning they will allow resources from external origins (say, a web page) 
                to read their assets. HTTP requests methods like PATCH, PUT, or DELETE, however, may be denied to prevent
                malicious behavior. For many servers, this is intentional. For example, it is likely that server A does not
                want servers B, C, or D to edit or delete its assets.
                <u>With CORS, a server can specify who can access its assets and which HTTP request methods are allowed from external resources.</u></li>
                <li>An <strong>HTTP header</strong> is a piece of information associated with a request or a response.
                Headers are passed back and forth between your web browser (also referred to as a client) and a server when
                the web page you are on wants to use resources hosted on a different server. Headers are used to describe requests
                and responses. The CORS standard manages cross-origin requests by adding new HTTP headers to the standard list of headers. </li>
                <ul>
                    <li><strong>Access-Control-Allow-Origin:</strong> This header allows servers to specify how their resources are shared with external domains. 
                    When a GET request is made to access a resource on Server A, Server A will respond with a value for the Access-Control-Allow-Origin
                    header. Many times, this value will be *, meaning that Server A will share the requested resources with any domain on the 
                    Internet. Other times, the value of this header may be set to a particular domain (or list of domains), meaning that 
                    Server A will share its resources with that specific domain (or list of domains). The Access-Control-Allow-Origin 
                    header is critical to resource security.</li>
                    <li>List of <strong>Headers</strong><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#cors" target="_blank">here</a>.</li>
                </ul>
                <li><strong>Pre-flight request: </strong>
                Most servers will allow GET requests but may block requests to modify resources on the server. 
                Servers don’t just blindly block such requests; they have a process in place that first checks and then communicates 
                to the client (your web browser) which requests are allowed. When a request is made using any of the following HTTP request 
                methods, a standard preflight request will be made before the original request PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH.    
                Preflight requests use the OPTIONS header. The preflight request is sent before the original request, 
                hence the term “preflight.” The purpose of the preflight request is to determine whether or not the original request is safe (for example, a 
                DELETE request). The server will respond to the preflight request and indicate whether or not the original request is safe. If the server specifies 
                that the original request is safe, it will allow the original request. Otherwise, it will block the original request.</li>
                <hr/>
                <h3>How to implement CORS?</h3>
                <li>Implementing the request headers to set up CORS correctly depends on the language and framework of the backend.
                <ul>
                    <li>If you are using Node, you can use setHeader(), <i>response.setHeader('Content-Type', 'text/html');</i>.</li>
                    <li>If you are using Express, you can use CORS middleware: <i>$ npm install cors</i></li>
                </ul>
                <pre>
                    <code>                   
                    var express = require('express');
                    var cors = require('cors');
                    var app = express();
                     
                    app.use(cors());
                     
                    app.get('/hello/:id', function (req, res, next) {
                      res.json({msg: 'Hello world, we are CORS-enabled!'});
                    });
                     
                    app.listen(80, function () {
                      console.log('CORS-enabled web server is listening on port 80');
                    });
                    </code>
                </pre>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>User Authentication and Authorization</h2>
            <ul>
                <li><strong>Authentication</strong> determines identity, <strong>authorization</strong> determines the privileges associated with an 
                identity, and <strong>encryption</strong> ensures that data can only be accessed by authorized parties.</li>
            </ul>
            <hr/>
            <h3>Authentication</h3>
            <ul>
                <li><strong>Authentication</strong> is the verification of who you are. For example, let’s say you’ve gone to a concert. At the front door, the 
                security guard asks to see your ticket and ID in order to verify that the name on your ID matches the name on your ticket. 
                Authentication relies on one or more factors to verify identity, and these factors come in three main types:</li>
                <ul>
                    <li><strong>Knowledge</strong> is something you know, like a username and password.</li> 
                    <li><strong>Possession</strong> is something you have, like a security card or mobile device.</li> 
                    <li><strong>Inherence</strong> is something you are, which generally refers to biometric data such as fingerprints.</li>
                </ul>
                <li><strong>Single-Factor Authentication: </strong>Relies on a single factor, such as a simple username/password combo,
                and is becoming increasingly insecure.</li>
                <li><strong>Multi-Factor Authentication: </strong>requires multiple factors, such as a username/password combo and a code 
                sent to a mobile device. This is distinct from Multi-Step authentication, which requires multiple types of authentication 
                within a single factor, such as a password and a PIN.</li>
            </ul>
            <hr/>
            <h3>Authorization</h3>
            <ul>
                <li><strong>Authorization</strong> is the verification of what you are allowed to do. 
                It is responsible for everything from preventing users from modifying each other’s accounts, to protecting back-end assets 
                from attackers, to granting limited access to external services.
                Good authorization will allow you to limit users and services to the privileges they require; just because a user is authorized 
                to manage one group doesn’t mean they should be able to manage all groups, for example.</li>
            </ul>
            <hr/>
            <h3>Encryption</h3>
            <strong>Encryption</strong> enforces authentication and authorization is encryption. 
            Encryption is the process of transforming data into a format that is unreadable unless you have the correct key to decrypt it.
        </div>
        <div class="styleGuide">
            <h2>Web Sessions & Security</h2>
            <h3>Sessions & Cookies & Localstorage</h3>
            <ul>
                <li><strong>Sessions & Cookies & Localstorage </strong>
                <a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-user-authentication-authorization/modules/wdcp-22-session-authentication-in-express/cheatsheet" target="_blank">here.</a></li>
                <li><strong>Web sessions: </strong>HTTP(S) protocol on its own is stateless, meaning requests and 
                responses are just relaying information back and forth with no knowledge of a specific user.
                But web developers want to create engaging, personalized experiences for users. This means there needs to 
                be a system that associates the requests with a specific user and does so in a secure.
                Without it, every time you reloaded the window you would be logged out or lose your cart!
                A <strong>web session</strong> refers to a series of user interactions over a time frame. 
                <u>Session data is stored server-side and associated with a session ID.</u>
                Think of a session as short-term memory for a web application.</li>
                <li><strong>Sessions Cookies:</strong> A cookie is a text file that stores stateful client data 
                in a key-pair format. It is stored by the web browser, aka client-side.
                Cookies store credentials for authentication, so the user doesn't need to send them every time 
                a button is clicked.</li>
                <li><strong>Sessions localStorage and sessionStorage: </strong>
                Client-side browser storage introduced with HTML5 that stores data in a key-pair format. 
                It does not interact with the server and is only changeable through JavaScript, with simple syntax.</li>
                <li>Ideally, all sessions-based web applications should enforce <strong>HTTPS</strong> for all communication. This 
                prevents common web attacks that could give the attacker access to the session.
                Security headers allow you to customize your web application’s security policy! They are an important 
                line of defense against web attacks. You should research each header, different options for each, 
                and find out how they can improve security while maintaining usability.</li>
                <ul>
                    <li>List of Security Headers
                    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers#security" target="_blank">here</a>.</li> 
                    <li>You can use <a href="https://securityheaders.com/" target="_blank">https://securityheaders.com/</a> 
                    to check which headers are active on your web address.</li>
                </ul>
                <hr/>
                <h3>Express Session</h3>
                <li>In order to implement sessions within an Express application, we can use the NPM module, express-session, 
                as a middleware. Once the session middleware is implemented, each user that navigates to our app will have a 
                unique session generated for them. This allows us to store their session data server-side under a session 
                identifier and easily retrieve it.</li>
                <li><strong>Express Configure:</strong></li>
                <ul>
                    <li><strong>secret:</strong> The secret property is a key used for signing and/or encrypting 
                    cookies in order to protect our session ID.
                    <li><strong>resave:</strong> Setting this option to true will force a session to be saved 
                    back to the session data store, even when no data was modified. Typically, this option should 
                    be false, but also depends on your session storage strategy.</li>
                    <li><strong>saveUninitialized</strong>: This property is a boolean value. If it’s set to true,
                    the server will store every new session, even if there are no changes to the session object. 
                    This might be useful if we want to keep track of recurring visits from the same browser, but 
                    overall, setting this property to false allows us to save memory space.</li>
                    <li>The resave & saveUninitialized determine how often the session object will be saved.</li>
                </ul>
                <li><strong>Storing Session Data:</strong>
                Sessions are typically stored in three different ways:</li>
                <ul>
                    <li>In <strong>memory</strong> (this is the default storage)</li>
                    <li>In a <strong>database</strong> like MongoDB or MySQL</li>
                    <li>A <strong>memory cache</strong> like Redis or Memcached.</li>
                    <li>Whenever a user makes a request from the same client with a valid session identifier, the server 
                    retrieves the valid session information. express-session provides an in-memory store called, <strong>MemoryStore()</strong>. If no other store 
                    is specified, then this is set as the default storage.</li>        
                </ul>
                <li><strong>Sessions and Authentication (Cookies):</strong>
                We should make use of client-side storage so that the user’s browser can automatically send over the 
                session identifier with each incoming HTTP request.
                We’ll tell the client browser to create a cookie that stores the session ID. We can also modify cookie attributes to add a bit of security.
                Cookies will have a few default properties set, but we can specify them using key-value pairs. </li>
                <ul>
                    <li><strong>maxAge</strong> property sets the number of milliseconds until the cookie expires.</li> 
                    <li><strong>secure attribute</strong> makes it only send to the server via HTTPS.</li> 
                    <li><strong>sameSite</strong> property setted to 
                    "none" allows a cross-site cookie through different browsers.</li>
                    <li><strong>Other cookie</strong> properties include: cookie.expires, cookie.httpOnly, cookie.sameSite</li>
                </ul>
                <li><strong>Sessions and Authentication (Logging In):</strong>
                With a session middleware configured, we can now make use of the session and combine it with an authentication process.
                <ul>
                    <li>We can do this by first looking up the user in our database and then verifying that the password is correct.</li>
                    <li>Once credentials are confirmed, we’ll add data to our session.</li>
                    <li>Once the user is logged in we’ll add a property, authenticated within our session object and assign it to 
                    true. We’ll also set user in the session data and assign it the username and password we received.</li>
                    <li>Once the user is logged in, their session is created and stored in memory. The properties authenticated and user will 
                    be accessible and changeable as session data.</li>
                </ul>
                <li><strong>Accessing Session Data: </strong>
                Data in a session is serialized as JSON when stored, so we’re able to store and access data in nested objects. Let’s say we had 
                saved the number of items in a user’s cart in the session data: <i>req.session.user.cartCount = 2;</i>
                We can then access it by referring to <i>req.session.user.cartCount</i> when we need to display the correct number of items. We can also update its value.
                One common use case of session data is to protect specific routes. In the example below, we check that the authorized 
                property exists within the session, and if it’s set to true before we move on to the next route handler.
                </li>
                <li><strong>Download project</strong> with <strong>Sessions Authentication</strong> & <strong>Sessions Access</strong> <a href="https://static-assets.codecademy.com/content/paths/web-security/sessions-in-express/sessions-auth-data.zip" target="_blank">here</a>.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode39" onclick="showCode('displayCode39', 'showCode39')">Display</button>
            <div id="displayCode39">
                <button onclick="closeCode('displayCode39', 'showCode39')">Close</button>
                <ul>
                    <li>We can <strong>install</strong> the package by running the following command:</li>        
                    <pre>
                        <code>
            npm install express-session
                        </code>
                    </pre>    
                    <li>From here, we import the session module and <strong>store it in a variable</strong>:</li>
                    <pre>
                        <code>
            const session = require("express-session")
                        </code>
                    </pre>
                    <li><strong>Configure express-session</strong> & <strong>Storing Session Data</strong></li>
                    <pre>
                        <code>
            //instantiate a new store
            const store = new session.MemoryStore();
            
            app.use(
                session({
                  secret: "f4z4gs$Gcg",
                  cookie: { maxAge: 1000 * 60 *60 * 24, secure: true, sameSite: "none" },
                  saveUninitialized: false,
                  resave: false,
                })
            );
                        </code>
                    </pre>  
                    <li><strong>Sessions Authentication</strong> & <strong>Sessions Access</strong></li>
                    <pre>
                        <code>
                //app.js

                const express = require("express");
                const app = express();
                const session = require("express-session");
                const store = new session.MemoryStore();
                const db = require("./db");
                const PORT = process.env.PORT || 4001;
                
                app.set("trust proxy", 1);
                app.use(express.json());
                app.use(express.urlencoded({ extended: false }));
                app.set("view engine", "ejs");
                app.use(express.static(__dirname + "/public"));
                
                app.use(
                    session({
                        secret: "f4z4gs$Gcg",
                        cookie: { maxAge: 300000000, secure: true, sameSite: "none" },
                        saveUninitialized: false,
                        resave: false,
                        store,
                    })
                );
                
                function ensureAuthentication(req, res, next) {
                    // Check for the authorized property within the session
                    if (req.session.authenticated) {
                        return next();
                    } else {
                        res.status(403).json({ msg: "You're not authorized to view this page" });
                    }
                }
                
                // Add your ensureAuthentication middleware below:
                app.get("/shop", ensureAuthentication, (req, res) => {
                    // Send the user object to the view page:
                    // res.render() takes in a view page as the 
                        first argument and an object whose properties 
                        define local variables for the view as the second argument.
                    res.render("shop", { user: req.session.user });
                });
                
                app.get("/login", (req, res) => {
                    res.render("login");
                });
                
                // POST request for logging in
                // Sessions and Authentication (Logging In)
                app.post("/login", (req, res) => {
                    const { username, password } = req.body;
                    db.users.findByUsername(username, (err, user) => {
                        if (!user) return res.status(403).json({ msg: "No user found!" });
                        if (user.password === password) {
                                req.session.authenticated = true;
                                req.session.user = {
                                username,
                                password,
                            };
                            res.redirect("/shop");
                        } else {
                            res.status(403).json({ msg: "Bad Credentials" });
                        }
                    });
                });
                
                app.listen(PORT, () => {
                    console.log(`Server is listening on port ${PORT}`);
                });
                            
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>JSON Web Tokens (JWTs)</h3>
            <ul>
                <li><strong>JSON Web Tokens</strong> are self-contained JSON objects that compactly and securely transmit information between 
                two parties. They are secure because they are digitally signed using a secret or a public/private key pair.</li>
                <li>JWTs are used for authorization: They’re often used for SSO.
                Information Exchange: If a server received a valid JWT, it knows the sender is who they say they are and the information hasn’t been tampered with.
                <ul>
                    <li>Why <strong>use JWTs?</strong> Parsing JSON is easier than some alternatives like XML or SAML.
                    JWTs are small, scale well, and are easier for mobile devices to process.</li>
                    <li>Why <strong>not use JWT</strong>?
                    A mix of a public and private key-pair adds security, but can also add complexity.
                    Sensitive information, like passwords or Social Security Numbers, should not be stored client-side, even if it is encoded.</li>
                </ul>
                <li>A JWT is made up of three components:</li>
                <ul>
                    <li><strong>JWT Header: </strong>A JWT header contains the type of the token we’re creating and the signing algorithm 
                    that will be used. <strong>Type:</strong> The type of this token will always be “JWT”. The Internet Assigned Numbers Authority, or IANA, coordinates internet 
                    protocol resources across the globe. The “JWT” type aligns with the media type “application/jwt“.
                    <strong>Algorithm:</strong> The signing, or hashing, algorithm used might vary. Some commonly used algorithms are HMAC-SHA256, 
                    represented by "HS256", RSA with SHA-256, represented by "RW256", and ECDSA with SHA-256, represented by "ES256".</li>
                    <li><strong>JWT Payload: </strong>A JWT payload contains claims about an entity. A claim is a statement or piece of 
                    information and the entity is often a user. There are three types of claims a JWT payload can contain:
                    <strong>Registered Claims:</strong> These are predefined claim types that anyone can use in a JWT.
                    <strong>Public Claims:</strong> These are custom claim types that are created by a developer and can be used 
                    publicly. They should be registered to avoid collisions, also known as repeated claims.
                    <strong>Private Claims:</strong> These are custom claim types that are not registered or public. They are only 
                    used between parties that have agreed to use them. List of registered claims and public claims 
                    <a href="https://www.iana.org/assignments/jwt/jwt.xhtml#claims" target="_blank">here</a>.</li>
                    <li><strong>JWTSignature: </strong>Is used to verify that the JWT wasn’t tampered with or changed. 
                    It can be created taking the encoded header, the encoded payload, a secret, and using the hashing algorithm 
                    to create a hash from those elements.</li>
                </ul>
                <li><strong>Do not store your JWT in localStorage</strong> as an attacker could use Cross-Site Scripting 
                attacks to steal local data.
                <strong>Storing your JWT in a cookie could expose your data to a Cross-Site 
                Resource Forgery attack</strong>. Additionally, if a user has disabled cookies in their browser, 
                the application is now unable to store the JWT.</li>
                <li>JWT documentation <a href="https://jwt.io/" target="_blank">here</a>.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode40" onclick="showCode('displayCode40', 'showCode40')">Display</button>
            <div id="displayCode40">
                <button onclick="closeCode('displayCode40', 'showCode40')">Close</button>
                <ul>
                    <li>JWS <strong>Header</strong> specifying the <strong>HMAC-SHA256</strong> algorithm:</li>
                    <pre>
                        <code>
                {
                    'alg': 'HS256',  
                    'typ': 'JWT'
                }
                        </code>
                    </pre>
                    <li>JWS <strong>Payload</strong> using some common registered claims:</li>
                    <pre>
                        <code>
                
            {
                'sub': '1234567890',
                'name': 'Harine Cooper',
                'admin': false,
                'iat': 1620924478,
                'exp': 1620939187
            }
                        </code>
                    </pre>
                    <li>In this example, we will use <strong>jwt.io’s JWT debugger</strong> to create our <strong>final JWT</strong>.</li>
                    <ul>
                        <li>The secret is a symmetric key known by the sender and receiver of this token. </li>
                        <li>The <strong>Base64Url encoding of our header</strong> is: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</li>
                        <li>The <strong>Base64Url encoding of our payload</strong> is:<br/>
                        <i>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkhhcmluZSBDb29wZXIiLCJhZG1pbiI6ZmFsc2UsI<br/>mlhdCI6MTYyMDkyNDQ3OCwiZXhwIjoxNjIwOTM5MTg3fQ</i></li>
                        <li>Finally, we use the HMAC-SHA256 algorithm we defined in our header to create our signature:</li>
                        <pre>
                            <code>
                        HMACSHA256(
                            base64UrlEncode(header) + "." +
                            base64UrlEncode(payload),
                            secret)
                            </code>
                        </pre>
                        <li>Which gives us: <i>3B-FLgPETrExxlDKW30AoU7KGE6xuZodw79TQR8_mwM</i></li>
                        <li>Concatenating our encoded header, our encoded payload, and our signature, and separating each with a “.”, gives us our final token:
                        <i>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ikhh<br/>cmluZSBDb29wZXIiLCJhZG1pbiI6ZmFsc2UsImlhdCI6MTYyMDkyNDQ3OCwiZXhwIjoxNjIwOTM5MTg3fQ.3B-FLgPETrExxlDKW30AoU7KGE6xuZodw79TQR8_mwM</i></li>
                    </ul>
                </ul>
            </div>
            <hr/>
            <h3>Protecting information (Encryption, Hashing, Encoding, Obfuscation)</h3>
            <ul>
                <li><strong>Encryption: </strong>
                    Encryption Cryptography is the science of hiding data and making it available again. In 
                    cryptography, hiding data is called encryption and unhiding it is called decryption. When data is
                    securely exchanged, it is first encrypted by the sender, and then decrypted by the receiver using 
                    a special key. There are two main types of encryption: symmetric and asymmetric.
                    Asymmetric encryption is the most secure way to transmit data; however, it is slower and more complex than
                    symmetric encryption. Therefore, it is primarily used to exchange smaller pieces of data.</li>
                    <ul>
                        <li><strong>Symmetric</strong> encryption uses the same key to both encrypt and decrypt data.</li>
                        <li><strong>Asymmetric</strong> encryption uses two different keys to encrypt and decrypt data.</li>
                    </ul>
                <li><strong>Hashing: </strong>
                Hashing does not encrypt data. Instead, hashing is a one-way process that takes a piece of data of any size 
                and uses a mathematical function to represent that data with a unique hash value of a fixed size. You cannot 
                compute the original data from its hash.
                Because each hash should be unique, hashing allows us to see if changes have been made to documents.
                <ul>
                    <li>Hashes are widely used in order to <strong>store passwords in online databases</strong>. If passwords are stored in plaintext 
                    and a database is breached, so are all of the passwords! However, if they are stored as hash values, even if 
                    someone hacks into a website’s database, only the password hashes are exposed.</li>
                    <li><strong>For example</strong>, let’s suppose a user’s password is: <i>CodecademyIsGr8t</i>
                    Now, if the website storing the password is using a SHA-256 hash, even if someone hacked into that website, 
                    all the hacker would see is the hash value:
                    <i>d04f855e71ad9d495d91e666175d593b669f45970f885a258f6dbbaab262ac8b</i>
                    Remember, an attacker has no way of decrypting a hash value to get the original value. Hashing is a one-way process.</li>
                </ul>
                <li><strong>Encoding: </strong>While it may sound similar to encryption, encoding is not actually used to hide 
                data. Encoding transforms data into a form that can be used by a different type of system. Some different types 
                of encoding are: <strong>ASCII, Unicode, Base64</strong>. Encoded information is easily reversed and only requires 
                knowledge of the algorithm used to decode information.</li>
                <li><strong>Obfuscation: </strong>Obfuscation is less about data security and more about securing code. Developers might 
                obfuscate their code in order to hide what their code is actually doing. Obfuscate means to hide the meaning of something 
                by making it difficult to understand.
                Developers might want to hide trade secrets or intellectual property from others who can access their code. 
                Obfuscating their code makes it difficult for others to steal code and use it for their own purposes. Obfuscation can also make 
                it harder for users to hack software or get around licensing requirements needed to use programs.
                Malicious actors might also use obfuscation to make it hard for users or antivirus software to detect a virus they are 
                planting on a system. If you don’t know what an application is for, be very careful before downloading or opening it.</li>
            </ul>
            <hr/>
            <h3>Passport.js</h3>
            <ul>
                <li>Passport.js is a flexible authentication middleware for Node.js that can be added to any Express-based 
                application. With Passport.js we can implement authentication using the concept of strategies.
                Passport strategies are separate modules created to work with different means of authentication. Passport is a very extensible 
                middleware, and it allows you to plug in over 300 different authentication providers like Facebook, Twitter, Google, and more.</li>
                <ul>
                    <li>Passport.js <strong>documentation</strong> <a href="http://www.passportjs.org/docs/" target="_blank">here</a>.</li>
                </ul>
                <li><strong>Serializing and Deserializing Users: </strong>
                If authentication succeeds, a session will be established and maintained via a cookie set in the user’s browser. 
                However, if a user logs in and refreshes the page, the user data won’t persist across HTTP requests. We can fix 
                this by <strong>serializing</strong> and <strong>deserializing</strong> users.
                Serializing a user determines which data of the user object should be stored in the session, usually the user id. 
                The <i>serializeUser()</i> function sets an id as the cookie in the user’s browser, and the <i>deserializeUser()</i> function 
                uses the id to look up the user in the database and retrieve the user object with data.</li>
                <li><strong>Logging In:</strong> In order to log in a user we need a POST request (with a logging end-point)
                that takes in user credentials & a get request, to retrieve data. Steps on how to Implement within "Example".</li>
                <li><strong>Register:</strong> In order to register a user we need a POST request (with a register end-point).
                Steps on how to Implement within "Example".</li>
                <li><strong>Logging out: </strong>Passport.js exposes a logout function within the request object: <i>req.logout</i>.
                The function can be called from any route handler in order to terminate a login session. It essentially removes 
                the <i>req.user</i> property and clears the login session (if any). 
                By terminating the session, the user will have to re-authenticate in order to create a new session.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode41" onclick="showCode('displayCode41', 'showCode41')">Display</button>
            <div id="displayCode41">
                <button onclick="closeCode('displayCode41', 'showCode41')">Close</button>
                <ul>
                    <li><strong>Configuring Passport.js: </strong>
                    One of the great things about using Passport.js is that a lot of the heavy lifting is taken care of 
                    by the module. In order to use it, we need to configure it and implement cookies and sessions for 
                    persistent logins.</li>
                    <ul>
                        <li>To start using the traditional authentication module, we <strong>install the passport</strong> and the <strong>passport-local</strong> 
                        packages via the terminal: <i>npm install passport passport-local</i>
                        <li>Once imported, <strong>we require the passport and passport-local</strong> packages in our JavaScript file as below.
                        We’re importing the passport-local package with its Strategy instance to authenticate users with 
                        a username and password.</li>
                        <pre>
                            <code>
                const passport = require("passport");
                const LocalStrategy = require("passport-local").Strategy;
                            </code>
                        </pre>    
                        <li>Now that we have the package installed, we can <strong>initialize</strong> it by calling the initialize() method:
                        <i>app.use(passport.initialize());</i>
                        passport is a middleware and must be implemented using <i>app.use()</i>. The <i>initialize()</i> method initializes 
                        the authentication module across our app.</li>
                        <li>Next, we want to <strong>allow for persistent logins</strong>, and we can do this by calling <i>session()</i> on our passport 
                        module: <i>app.use(passport.session());</i>
                        The <i>session()</i> middleware alters the request object and is able to attach a ‘user’ value that can be 
                        retrieved from the session id.</li>
                    </ul>
                    <hr/>
                    <li><strong>Passport's Local Strategy</strong></li>
                    <ul>
                        <li>With Passport configured, we can now set up the passport-local strategy for authenticating with a username and password.
                        First, we can configure the local strategy by creating a new instance of it and passing it as middleware into passport:</li>
                        <pre>
                            <code>
                    passport.use(new LocalStrategy(
                        function(username, password, done) {
                        // …
                        }
                    ));
                            </code>
                        </pre>
                        <li>The new LocalStrategy object will take in an anonymous function with the following parameters:</li>
                        <ul>
                            <li>username</li>
                            <li>password</li>
                            <li>A callback function called done.</li>
                        </ul>
                        <li>The purpose of the done callback is to supply an authenticated user to Passport if a user is authenticated. 
                        The logic within the anonymous function follows this order:</li>
                        <ol>
                            <li>Verify login details in the callback function.</li>
                            <li>If login details are valid, the done callback function is invoked and the user is authenticated.</li>
                            <li>If the user is not authenticated, pass false into the callback function.</li>
                        </ol>
                        <li>The done callback function takes in two arguments:</li>
                        <ul>
                            <li>An error or null if no error is found.</li>
                            <li>A user or false if no user is found.</li>
                        </ul>
                        <li>With those steps implemented our updated strategy should look like:</li>
                        <pre>
                            <code>
                    passport.use(new LocalStrategy(
                        function (username, password, done) {
                            // Look up user in the db
                            db.users.findByUsername(username, (err, user) => {
                            // If there's an error in db lookup, 
                            // return err callback function
                            if(err) return done(err);
                        
                            // If user not found, 
                            // return null and false in callback
                            if(!user) return done(null, false);
                        
                            // If user found, but password not valid, 
                            // return err and false in callback
                            if(user.password != password) return done(null, false);
                        
                            // If user found and password valid, 
                            // return the user object in callback
                            return done(null, user)
                            });
                        })
                    );
                            </code>
                        </pre>
                        <li>We’re looking for potential errors during the authentication process and addressing them before the next request handler is reached.</li>
                        <li>Once the local strategy is configured, the Express application will have user authentication implemented!</li>
                    </ul>
                    <hr/>
                    <li><strong>Serializing</strong> and <strong>Deserializing Users</strong></li>
                    <ul>
                        <li>When we <strong>serialize a user</strong>, Passport takes that user id and stores it internally on <i>req.session.passport </i>
                        which is Passport’s internal mechanism to keep track of things.
                        In the code example below, we pass a user object and a callback function called done after successful authentication.</li>
                        <pre>
                            <code>
                    passport.serializeUser((user, done) => {
                        done(null, user.id);
                    });
                            </code>
                        </pre>
                        <li>The first argument in the <i>done()</i> function is an error object. In this case, since there was no error we pass null 
                        as the argument. For the second argument, we pass in the value that we want to store in our Passport’s internal session, 
                        the user id. Once configured, the user id will then be stored in Passport’s internal session:
                        <i>req.session.passport.user = {id: 'xyz'}</i>
                        For any subsequent request, the user object can be retrieved from the session via the <i>deserializeUser()</i> function. 
                        We can implement the deserializeUser function as follows:</li>
                        <pre>
                            <code>
                passport.deserializeUser((id, done) => {
                // Look up user id in database. 
                db.users.findById(id, function (err, user) {
                        if (err) return done(err); 
                        done(null, user);
                    });
                });
                            </code>
                        </pre>
                        <li>For the <strong>deserializeUser function</strong>, we pass the key that was used when we initially serialized a user (id). 
                        The id is used to look up the user in storage, and the fetched object is attached to the request object as 
                        req.user across our whole application.
                        This way we’re able to access the logged-in user’s data in req.user on every subsequent request!</li>
                    </ul>
                    <hr/>
                    <li><strong>Logging In</strong></li>
                    <ul>
                        <li>In order to log in a user we first need a POST request that takes in user credentials. 
                        We can add passport middleware in order to process the authentication and, if successful, serialize the user for us:</li>
                    <pre>
                        <code>
            app.post("/login",
                passport.authenticate("insertStrategyHere", 
                { failureRedirect : "/insertPathHere"}),
                (req, res) => {
                    res.redirect("profile");
                }
            );
                        </code>
                    </pre>
                    <li>We’re passing in <i>passport.authenticate()</i> as middleware. Using this middleware allows Passport.js 
                    to take care of the authentication process behind the scenes and creates a user session for us.
                    passport.authenticate() takes in:</li>
                    <ul>
                        <li>A string specifying which strategy to employ. In this case, we should use a local strategy.</li>
                        <li>An optional object as the second argument. In this case, we should set the failureRedirect key 
                            to "/login". This will redirect the user to the /login page if the login process fails.</li>
                    </ul>
                    <li>Once implemented, we can update the "/profile" endpoint to make use of the serialized user found in the request object, req.user:</li>
                    <pre>
                        <code>
            app.get("/profile", (req, res) => {
                res.render("insertDashboardNameHere", { user: req.user });
            }); 
                        </code>
                    </pre>
                    <li>This will render our profile view page along with the user data stored in the session!</li>
                    </ul>
                    <hr/>
                    <li><strong>User Registration</strong></li>
                    <ul>
                        <li>Let’s learn how to register a user without a database. In a real production environment, you should 
                        use a database, but we’ve simplified this example to focus on the creation of new users.                    
                        Instead of a database, we’ll use an array holding data:</li>
                        <pre>
                            <code>
                    // users:
                    let records = [
                        {
                            id: 1,
                            username: "sam",
                            password: "codec@demy10",
                        },
                        {
                            id: 2,
                            username: "jill",
                            password: "p@ssword123!",
                        },
                    ];
                            </code>
                        </pre>
                        <li>Using a custom helper function we can retrieve user data upon registration 
                        and update the records array:</li>
                        <pre>
                            <code>
                    function createUser(user) {
                        return new Promise((resolve, reject) => {
                        const newUser = {
                            // getNewId creates an updated ID 
                            // for the new user
                            id: getNewId(records),
                            ...user,
                        };
                        records = [newUser, ...records];
                        resolve(newUser);
                        });
                    };
                            </code>
                        </pre>
                        <li>In the <strong>createUser()</strong> function, we’re creating a Promise in order to prevent events from becoming blocked 
                        when running the application. <i>createUser()</i> creates a new user and inserts them into our database, records. Once created, we resolve the 
                        Promise and send back the newly created user. Let’s use the <i>createUser()</i> helper function in our routes. We’ll add the logic to create users in a POST 
                        request to </i>"/register"</i>.
                        Since we’re working with promises, we can create an asynchronous route handler by using <i></i>async/await</i>:</li>
                        <pre>
                            <code>
                        app.post("/register", async (req, res) => { ... })
                            </code>
                        </pre>
                        <li>We’ll retrieve the user data from <i></i>req.body</i> and await as we call our helper function to create the new user:</li>
                        <pre>
                            <code>
                        app.post("/register", async (req, res) => {
                            const { username, password } = req.body;
                            // imported helper function: 
                            // db.users.createUser
                            const newUser = await db.users.createUser({ username, password });
                            </code>
                        </pre>

                        <li>If a newUser is successfully created, we send a status code of 201 and a json response back to the client:</li>
                        <pre>
                            <code>
                app.post("/register", async (req, res) => {
                    const { username, password } = req.body;
                    const newUser = await db.users.createUser({ username, password });
                    if (newUser) {
                        res.status(201).json({
                        msg: "Insert Success Message Here",
                        insertDataHere
                    });
                }
                            </code>
                        </pre>
                        <li>Lastly, we want to handle potential errors that might occur. In an else statement we can 
                        return a status code of 500 indicating that there was a relevant error message:</li>
                        <pre>
                            <code>
                app.post("/register", async (req, res) => {
                    const { username, password } = req.body;
                    const newUser = await db.users.createUser({ username, password });
                    if (newUser) {
                        res.status(201).json({
                        msg: "Insert Success Message Here",
                        insertDataHere
                    });
                    } else {
                        res.status(500).json({ msg: "Insert Failure Message Here" });
                }
                            </code>
                        </pre>
                        <li>NOTE: In a real development environment, passwords would be hashed whenever a new user registers.</li>
                        <li>With the route completed, users will now be able to register and log in!</li>
                    </ul>
                    <hr/>
                    <li><strong>Logging out</strong></li>
                    <ul>
                        <pre>
                            <code>
                    app.get("/logout", (req, res) => {
                        req.logout();
                        res.redirect("/");
                    });
                            </code>
                        </pre>
                    </ul>
                    <hr/>
                    <li><strong>Passport Implementation: </strong></li>
                    <pre>
                        <code>    
                const express = require("express");
                const app = express();
                const session = require("express-session");
                const store = new session.MemoryStore();
                const db = require("./db");
                const passport = require("passport");
                const LocalStrategy = require("passport-local").Strategy;
                const PORT = process.env.PORT || 4001;
                
                app.use(express.json());
                app.use(express.urlencoded({ extended: false }));
                app.set("view engine", "ejs");
                app.use(express.static(__dirname + "/public"));
                
                app.use(
                  session({
                    secret: "f4z4gs$Gcg",
                    cookie: { maxAge: 300000000, secure: false },
                    saveUninitialized: false,
                    resave: false,
                    store,
                  })
                );
                
                app.use(passport.initialize());
                app.use(passport.session());
                
                //Serialize User
                passport.serializeUser((user, done) => {
                  done(null, user.id);
                });
                
                //Deserialize User
                passport.deserializeUser((id, done) => {
                  db.users.findById(id, function (err, user) {
                    if (err) {
                      return done(err);
                    }
                    done(null, user);
                  });
                });
                
                // Passport local strategy below:
                passport.use(
                    //cb is callback
                    new LocalStrategy(function (username, password, cb) {
                        db.users.findByUsername(username, function (err, user) {
                            // There was an error in the database lookup
                            if (err) {
                                return cb(err);
                            }
                            // A user was NOT found and there was NO error
                            if (!user) {
                                return cb(null, false);
                            }
                            // A user was found, but the password was NOT valid
                            if (user.password != password) {
                                return cb(null, false);
                            }
                            // There was no error, the user and password are valid
                            return cb(null, user);
                        });
                    })
                );
                
                // Logout handler below:
                app.get("/logout", (req, res) => {
                  req.logout();
                  res.redirect("/login");
                });
                
                app.get("/login", (req, res) => {
                  res.render("login");
                });
                
                //Logging
                app.post(
                  "/login",
                  passport.authenticate("local", { failureRedirect: "/login" }),
                  (req, res) => {
                    res.redirect("profile");
                  }
                );
                
                app.get("/profile", (req, res) => {
                  res.render("profile", { user: req.user });
                });
                
                //Register
                app.post("/register", async (req, res) => {
                  const { username, password } = req.body;
                  const newUser = await db.users.createUser({ username, password });
                  if (newUser) {
                    res.status(201).json({
                      msg: "New user created!",
                      newUser,
                    });
                  } else {
                    res.status(500).json({ msg: "Unable to create user" });
                  }
                });
                
                app.listen(PORT, () => {
                  console.log(`Server is listening on port ${PORT}`);
                });


                        </code>
                    </pre> 
                    <hr/>
                    <li><strong>Helper Function: </strong>
                    Using a custom helper function, 
                    we can retrieve user data upon registration and update the records array:</li>
                    <pre>
                        <code>
                let records = [
                    {
                        id: 1,
                        username: "sam",
                        password: "codec@demy10",
                    },
                    {
                        id: 2,
                        username: "jill",
                        password: "birthday",
                    },
                ];

                const getNewId = (array) => {
                    if (array.length > 0) {
                        return array[array.length - 1].id + 1;
                    } else {
                        return 1;
                    }
                };

                exports.createUser = function (user) {
                    return new Promise((resolve, reject) => {
                        const newUser = {
                            id: getNewId(records),
                            ...user,
                        };
                        records = [newUser, ...records];
                        console.log(records);
                        resolve(newUser);
                    });
                };

                exports.findById = function (id, cb) {
                    process.nextTick(function () {
                        var idx = id - 1;
                        if (records[idx]) {
                            cb(null, records[idx]);
                        } else {
                            cb(new Error("User " + id + " does not exist"));
                        }
                    });
                };

                exports.findByUsername = function (username, cb) {
                    process.nextTick(function () {
                        for (var i = 0, len = records.length; i < len; i++) {
                            var record = records[i];
                            if (record.username === username) {
                                return cb(null, record);
                            }
                        }
                        return cb(null, null);
                    });
                };
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>BCRYPT</h3>
            <ul>
                <li>When practicing new concepts, we might store plaintext passwords in a local database, but this is 
                incredibly insecure. <u>One should never do this in a production environment</u>. 
                You should <strong>hash passwords</strong> before storing them in a database in order to protect 
                your users from being hacked. There are plenty of cryptographic hashing functions to choose from, 
                such as the SHA-3 or MD-5 algorithms, but they are quite fast (the faster the function, the faster 
                a hacker can retrieve a hashed password). 
                Using a function that is slower at hashing passwords can actually protect your users.
                We can accomplish this by using the <strong>bcrypt</strong> algorithm and library. 
                Using bcrypt, we can protect our users by <strong>hashing and salting passwords</strong>.
                Using multiple rounds of hashing ensures that an attacker must deploy massive funds and 
                hardware to be able to crack your passwords.</li>
                <li><strong>bcrypt is hashing algorithm</strong>. This means you cannot easily retrieve 
                the plaintext password without already knowing the salt, rounds, and key (password).
                A hash function only works one-way, which means that once a value is hashed it can’t be unhashed
                (this helps to avoid exposing password if a server attack happens). 
                This is different from encryption, because, if you know which algorithm was used to encrypt a value, 
                you can use that same algorithm to decrypt it.</li>
                <li>On a typical website, when a user first signs up, we retrieve their password and run it through a 
                hashing algorithm. The hashed password is then stored in the database. Whenever the same user 
                logs in, we hash the password they tried to log in with and compare it to the already stored hash 
                value. If the values match, the user is authenticated.</li>
                <li>A <strong>salt</strong> is a random value that is added to the input of a hashing function in order to make each 
                password hash unique even in the instance of two users choosing the same passwords. Salts help 
                us mitigate hash table (like Rainbow Table) attacks by forcing attackers to re-compute them using the salts for each 
                user.</li>
                <li>The <strong>process of comparing</strong> passwords should look as follows:</li>
                <ol>
                    <li><strong>Retrieve</strong> plain text password.</li>
                    <li><strong>Hash</strong> the password.</li>
                    <li><strong>Compare</strong> the hashed password with the one stored in our DB. 
                    (Since we’re using the same hash, it should return the same value if the password is correct.)</li>
                </ol>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode42" onclick="showCode('displayCode42', 'showCode42')">Display</button>
            <div id="displayCode42">
                <button onclick="closeCode('displayCode42', 'showCode42')">Close</button>
                <ul>
                    <li>Bcrypt to<strong> Hash Passwords:</strong></li>
                    <ul>
                        <li>A <strong>salt</strong> is a value that is concatenated to a password before hashing in order to make it less 
                        vulnerable to rainbow table and brute-force attacks.</li>
                        <li>A <strong>salt round</strong> can be described as the amount of time needed to calculate a single bcrypt hash. 
                        The higher the salt rounds, the more time is necessary to crack a password.</li>
                        <li>The built-in <strong><i>genSalt()</i></strong> function automatically generates a salt for us. Since we’re using an 
                        asynchronous function we can await this function call.</li>
                    </ul>
                    <pre>
                        <code>
                const bcrypt = require("bcrypt");

                const passwordHash = async (password, saltRounds) => {
                    try {
                        const salt = await bcrypt.genSalt(saltRounds);
                        return await bcrypt.hash(password, salt);
                    } catch (err) {
                        console.log(err);
                    }
                    return null;
                };
                        </code>
                    </pre>
                    <li><strong>Verifying password:</strong></li>
                    <ul>
                        <li>The built-in function <strong><i>compare()</i></strong> 
                        takes in a plaintext password, password and a hashed password, hash.
                        <i>bcrypt.compare()</i> deduces the salt from the provided hash and is able to then 
                        hash the provided password correctly for comparison.</li>
                        <pre>
                            <code>
                const bcrypt = require("bcrypt");

                const comparePasswords = async (password, hash) => {
                    try {
                        const matchFound = await bcrypt.compare(password, hash);
                        return matchFound;
                    } catch(err) {
                        console.log(err);
                    }
                    return false;
                };
                            </code>
                        </pre>
                    </ul>
                    <hr/>
                    <li><strong>Implementation bcrypt:</strong></li>
                    <pre>
                        <code>
            const express = require("express");
            const router = express.Router();
            const helper = require("../helpers/helpers");
            let users = require("../data/users.json");
            const filename = "./data/users.json";
            const bcrypt = require("bcrypt");

            /* Register a user */
            router.post("/register", async (req, res) => {
                const { email, password } = req.body;
                const id = { id: helper.getNewId(users) };
                
                try {
                    const user = await helper.findUser(users, email);
                    if (user) {
                        console.log("User already exists!");
                        return res.redirect("login");
                    }
                    
                    // Generate salt
                    const salt = await bcrypt.genSalt(10);
                    
                    // Hash password
                    const hashedPassword = await bcrypt.hash(password, salt);
                    
                    const newUser = {
                    ...id,
                    email,
                    password: hashedPassword,
                    };

                    await users.push(newUser);
                    await helper.writeJSONFile(filename, users);

                    res.redirect("login");
                } catch (err) {
                    res.status(500).json({ message: err.message });
                }
            });

            /* Log in user */
            router.post("/login", async (req, res) => {
                const { password, email } = req.body;

                try {
                    const user = await helper.findUser(users, email);

                    if (!user) {
                    console.log("User does not exist!");
                    return res.redirect("login");
                    }

                    // Compare passwords
                    const matchedPassword = await bcrypt.compare(password, user.password);

                    if (!matchedPassword) {
                        console.log("Passwords did not match!");
                        return res.redirect("login");
                    }
                    // return res.status(401).json({
                    //   token: null,
                    //   message: "Invalid password",
                    // });
                    res.render("profile", { user });
                } catch (err) {
                    res.status(500).json({ message: err.message });
                }
            });

            router.get("/login", (req, res) => {
                res.render("login");
            });

            router.get("/register", (req, res) => {
                res.render("register");
            });

            router.get("/profile", (req, res) => {
                res.render("profile");
            });

            module.exports = router;
                        </code>
                    </pre>
                    <li>Previous example <i>user.json</i></li>
                    <pre>
                        <code>
            [
                {
                    "id":1,
                    "email":"lucinda90@codecademy.com",
                    "password":"$2b$10$3euPcmQFCiblsZeEu5s7p.9OVHgeHWFDk9nhMqZ0m/3pd/lhwZgES"
                },
                {
                    "id":2,"email":"enrique10@email.com",
                    "password":"$2b$10$69SrwAoAUNC5F.gtLEvrNON6VQ5EX89vNqLEqU655Oy9PeT/HRM/a"},
                {
                    "id":3,
                    "email":"lola@codecademy.com",
                    "password":"$2b$10$9PU0sCJU201C3lO41bsOIu.HRrik7Alv2ZlxwM9A8lGr/clLK6D0m"},
                {
                    "id":4,"email":"joan@gmail.com",
                    "password":"$2b$10$EQSDN0hNs.7TFzQPetYKVerxMpzOLYrP3dp2W82AGXSgUuWU9YuPC"
                }
            ]
                        </code>
                    </pre>
                </ul>
            </div>
            <hr/>
            <h3>OAuth 2.0</h3>
            <ul>
                <li>There are three main types of <strong>API authentication:</strong> HTTP Basic Auth, API Keys, OAuth.</li>
                <li>Sometimes we don’t have to create a username and password for a new account. Instead, we can
                sign in with Google, LinkedIn, Twitter, and more. This is possible because of OAuth. 
                <strong>OAuth</strong> is an authorization framework that provides specific authorization flows 
                which allow unrelated servers to access authenticated resources without sharing any passwords. 
                It works by allowing applications to authenticate with third-party services in exchange for an 
                access token which can be passed with an HTTP request to access protected content.
                All methods of authorization have advantages and vulnerabilities and OAuth is no exception; however, it remains 
                a generally secure and convenient way to authenticate yourself on trusted applications.</li>
                Here're the steps on how it works:</li>
                <ul>
                    <li>Redirect user to provider for authorization -> User grants authorization -> Redirect user to application 
                    -> Exchange for access grant -> Grant access token -> Create connection.</li>
                </ul>
                <li><strong>Access Tokens: </strong>Authentication in OAuth is facilitated by the use of access tokens. 
                Access tokens are used to make API requests on behalf of the user and represent the authorization of a specific
                application to access specific parts of a user’s data. These API requests are made over HTTPS connections.
                Access tokens are very short-lived, and they only last anywhere from a few minutes to just hours. Their
                ephemeral nature limits the amount of time an attacker can use a stolen token.</li>
                <li><strong>Refresh tokens: </strong>Are longer lived than access tokens and are used by applications to get new access tokens 
                without prompting the user. Refresh tokens can expire, like access tokens, but they can also be revoked by
                the authorization server.</li>
                <li><strong>Grant Types: </strong>OAuth 2.0 grant types, <u>also known as flows</u>, describe multiple ways to 
                obtain access tokens. Flows involve two main parts: Redirecting the user to the OAuth provider and obtaining 
                an access token & using the access token to gain restricted access.</li>
                <ul>
                    <li>Some <strong>OAuth grant types: </strong>Client Credentials Grant; Authorization Code;
                    Proof Key for Code Exchange (PKCE); Implicit Grant - Deprecated; Device Code Grant;
                    Resource Owner Password Credential Grant - Deprecated.</li>
                    <li><strong>In the Client Credentials flow</strong>, permissions are granted directly to the application itself by 
                    an administrator. When the app presents a token to a resource, the resource enforces that the app 
                    itself has authorization to perform an action since there is no user involved in the authentication</li>
                    <li><strong>The Authorization Code Grant</strong> is the most widely used grant for publicly available applications. 
                    This was the grant type we showed earlier in this article. To use this grant type, the webserver must have the 
                    capability to store client credentials securely.
                    This approach uses browser redirection to communicate between the resource server and the authorization server. 
                    The client will obtain an authorization code and then exchange it for an access token.</li>
                </ul>
                <li>The <strong>four OAuth Roles</strong>:</li>
                <ul>
                    <li><strong>Resource Owner</strong>: the user who authorizes an application to an account (user);</li>
                    <li><strong>Resource Server</strong>: the API server that accepts access tokens and verifies their validity (server side, where resource relies);</li>
                    <li><strong>Authorization Server:</strong> the server that issues access tokens (auth server, like google, github, facebook...);</li>
                    <li><strong>Client:</strong> the application that requests the access tokens (client side).</li>
                </ul>
                <li>OAuth defines <strong>two types of clients:</strong></li>
                <ul>
                    <li><strong>Public clients</strong> are NOT able to store credentials securely and 
                    can only use grant types that do not use their client secret.</li>
                    <li><strong>Confidential clients</strong> are applications that can be registered to 
                    an authorization server using credentials. Those credentials, a client ID and a client secret, 
                    can be secured without exposing them to a third party. They require a backend server to store the credentials. 
                    A client’s ability to securely store credentials determines which type of OAuth authorization flows should be 
                    used. More information <a href="https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/" target="_blank">here</a>.</li>
                </ul>              
                <li><strong>Material on OAuth </strong><a href="https://www.codecademy.com/learn/paths/full-stack-engineer-career-path/tracks/fscp-22-user-authentication-authorization/modules/wdcp-22-oauth-2/cheatsheet" target="_blank">here</a>.</li>
                <li><strong>Download</strong> github-oauth-app project <a href="https://static-assets.codecademy.com/content/paths/web-security/oauth2/github-oauth-app.zip" target="_blank">here</a>.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode43" onclick="showCode('displayCode43', 'showCode43')">Display</button>
            <div id="displayCode43">
                <button onclick="closeCode('displayCode43', 'showCode43')">Close</button>
                <ul>
                    <li><strong>Implementing OAuth</strong></li>
                    <ul>
                        <li><strong>Install:</strong> We will use the oauth2-server module to implement 
                        an OAuth 2.0 provider in Node.js utilizing 
                        the client credentials grant type to demonstrate obtaining an access token and using it in request.
                        The package can be installed in the terminal using npm with the command: <strong><i>npm install oauth2-server</i></strong></li>
                        <li>From here, we instantiate the oauth2-server module and store it in a variable like below: <strong><i>const OAuth2Server = require('oauth2-server')</i></strong>;</li>
                        <li>We’ll create an <strong>instance of the OAuth2Server</strong> object and store it in a variable named oauth.
                        The OAuth2Server object requires a model object which contains functions to access, store, and validate our access tokens. 
                        We’ll be writing them separately in a file named model.js.</li>
                        <ul>
                            <li>OAuth2Server can be supplied with additional options in the constructor. To pass tokens inside the URL, we’ll set the 
                            <strong>allowBearerTokensInQueryString</strong> attribute to true.</li>
                            <li>The access token lifetime can also be configured as an option using the <strong>accessTokenLifetime</strong> attribute. 
                            The lifetime is set in seconds.</li>
                        </ul>
                        <pre>
                            <code>
                //app.js

                const oauth = new OAuth2Server({
                    model: require('./model.js'),
                    allowBearerTokensInQueryString: true,
                    accessTokenLifetime: 60 * 60
                })
                            </code>
                        </pre>
                    </ul>
                    <hr/>
                    <li><strong>Registering Client to Application</strong></li>
                    <ul>
                        <li>We'll implement the <strong>Client Credentials</strong> flow to obtain an access token
                        for authentication. When a developer registers a client in an OAuth application, they’ll need:</li>
                        <ul>
                            <li><strong>A Client ID:</strong> a public identifier for apps that is unique across all clients and the authorization server.</li>
                            <li><strong>A Client Secret:</strong> a secret key known only to the application and the authorization server.</li>
                            <li>More about <a href="https://www.oauth.com/oauth2-servers/client-registration/client-id-secret/" target="_blank">here</a>.</li>
                        </ul>
                        <li>For our example application, we use an in-memory database defined in db.js. Inside db.js, 
                        we use modules.exports to create a module to hold our <strong>confidential client 
                        credentials</strong> and <strong>access tokens</strong>.
                        We can register an application to the list of confidentialClients in db.js. Inside the module.exports 
                        object, we create an attribute named <strong>confidentialClients</strong> and set it equal to an array. Within the array,
                        we create an object with the <i>clientId</i> and <i>clientSecret</i>, and specify 'client_credentials' 
                        in our array of grant types.</li>
                        <li>In our database, we’ll create a location to store access tokens. Within the module.exports object, we create another 
                        property named tokens and set it equal to an empty array.</li>
                        <pre>
                            <code>
                //db.js

                module.exports = {
                    // Add confidential clients[]
                    confidentialClients: [{
                        clientId: 'codecademy',
                        clientSecret:'codec@demy',
                        grants: [
                            'client_credentials'
                        ]
                    }],
                    // Add tokens[]
                    tokens: []
                }
                            </code>
                        </pre>
                        <li>OAuth2Server requires certain functions implemented in the model regardless 
                        of the authorization flow used. The <strong><i>getClient()</i></strong> function is an example of a required model function for all flows. 
                        The function is used to retrieve a client using a Client ID and/or a Client Secret combination.
                        The <i>getClient()</i> function takes two arguments: <i>clientId</i> and <i>clientSecret</i>. 
                        We must write a database query to match 
                        the provided arguments and its implementation will vary depending on the type of database used. Since we are 
                        using JavaScript as our in-memory database, we can use the <i>.filter()</i> method to evaluate if the clientId and 
                        clientSecret match any confidential clients in db.js and return the matching client.</li>
                        <li>We <strong>iterate over each element</strong> in the confidentialClients array inside db.js. Each element’s clientId
                        and clientSecret is tested to match against the clientId and clientSecret of the client that is passed 
                        and will return the client that matches both values in an array. Finally, the <i>getClient()</i> function returns 
                        the first element in confidentialClients.
                        Finally, we export the function from model.js so that it can be used from other files. We can do 
                        this using module.exports object.</li>
                        <li>The <strong><i>saveToken()</i></strong> function must be implemented for all grant types 
                        in the model used by OAuth2Server. This function stores the access token as an object to a 
                        database when an access token is obtained.
                        The <i>saveToken()</i> function is implemented with three arguments: token, client, and user.
                        We’ll also export the saveToken() function from models.js using module.exports.</li>
                        <ul>
                            <li>The <strong>token.user</strong> is set equal to an object with the username attribute. We set the 
                            username attribute equal to the username of the passed user object.</li>
                            <li>The <strong>token.client</strong> equal an object in which the id attribute is equal 
                            to the passed client’s clientId.</li>
                            <li>With the token formatted, we can save the token to our database by pushing the token 
                            to our db.tokens array and returning the token.</li>        
                        </ul>
                        <li>Certain grant types have specific functions that must be implemented for them to work. The Client Credentials 
                        grant type must have the <strong>getUserFromClient()</strong> function implemented to be used.
                        The <i>getUserFromClient()</i> function is invoked to retrieve the user associated with the specified 
                        client. We are not using a user in our application so we can return an empty object. However, 
                        leaving out this function declaration will throw an error when using the Client Credentials 
                        grant type. Finally, we export the function from model.js so that it can be used from other files. 
                        We can do this using <i>module.exports</i> object.</li>
                        <pre>
                            <code>
                //model.js

                let db = require('./db.js');

                // getClient() function
                const getClient = (clientId, clientSecret) => {
                        let confidentialClients = db.confidentialClients.filter((client) => {
                        return client.clientId === clientId && client.clientSecret === clientSecret
                    });
                    return confidentialClients[0];
                }
                
                // saveToken() function
                const saveToken = (token, client, user) => {
                        token.client = {
                        id: client.clientId
                    }
                    token.user = {
                        username: user.username
                    }
                    db.tokens.push(token);
                    return token;
                }

                const getUserFromClient = (client) => {
                    return {}
                  }
                
                // Export saveToken() here
                module.exports = {
                    getClient: getClient,
                    saveToken: saveToken,
                    getUserFromClient: getUserFromClient
                }
                            </code>
                        </pre>
                        <li>Now that our model functions for generating and saving access tokens are implemented 
                        in model.js, we need to create a callback function to handle obtaining the access token whenever 
                        a URL is requested in our application. Within app.js, we create a function named <strong>obtainToken()</strong> 
                        that takes the HTTP request and HTTP response as arguments—req and res.
                        <li>Inside <i>obtainToken()</i>, we create a new variable named request and set it to a new instance 
                        of <i>OAuth2Server.Request()</i>, passing the HTTP request, req, as the argument.
                        We’ll also create a new variable named response and set it to a new instance of OAuth2Server.Response(), 
                        taking in res as the argument.</li>
                        
                        <li>The <i>.token()</i> method of the oauth object returns the access token. The method passes the OAuth2Server‘s 
                        request and response stored in response and request variables. We use the <i>.then()</i> method to return a promise. 
                        If the token method is successful, we will send the access token back to the client using the <i>.json()</i> Express method.                        
                        We’ll chain the <i>.catch()</i> method to handle any errors if the <i>.token()</i> method fails. If the <i>.token()</i> method returns 
                        an error code or an HTTP 500 status, the error can be sent back to the client using the <i>.json()</i> method.</li>
                        
                        <li>Note, must declare our function expressions before they can be used. To make use of our 
                        <i>obtainToken()</i> function, we can define a new route and pass <i>obtainToken()</i> as a callback 
                        function. We use the <i>.all()</i> method to handle all types of HTTP requests since we will 
                        eventually use a POST request on the route. The route name can be anything we’d like—we’ll 
                        use /auth for our example.
                        Now the client can make an HTTP request with the Client Secret to /auth and receive an access token.</li>
                        <pre>
                            <code>
                //app.js

                // btainToken()
                const obtainToken = (req, res) => {
                    let request = new OAuth2Server.Request(req);
                    let response = new OAuth2Server.Response(res);
                    return oauth.token(request, response)
                    .then((token) => {
                        res.json(token);
                    }).catch((err) => {res.json(err)})
                }
                
                // '/auth' route
                app.all('/auth', obtainToken);                
                            </code>
                        </pre>
                        <li><strong>getAccessToken(): </strong>
                        Now that we’ve written the code to obtain an access token, <u>we can use it to restrict access 
                        to content unless a user is authenticated with a valid access token</u>. Inside <i>model.js</i>, we implement 
                        the <i>getAccessToken()</i> function to retrieve existing tokens that were previously saved when the 
                        <i>saveToken()</i> function is invoked.
                        
                        The <i>getAccessToken()</i> function is required when the <i>.authenticate()</i> method is used on an 
                        OAuth2Server instance. <i>getAccessToken()</i> is declared with one parameter—accessToken.
                        
                        When the function is invoked the accessToken is checked against the tokens stored inside the db.js to 
                        see if there is a match. We can use JavaScript’s <i>.filter()</i> method to each token in the database against 
                        the access token that is passed. If there is a match, the access token can be returned.</li>
                        <li>The <i>getAccessToken()</i> function expression is called with an access token as an argument. 
                        The <i>.filter()</i> method is used to check each token saved in the tokens array in the database 
                        to match the access token passed to the function. Finally, we return the matching access token from the array.
                        We export the function from <i>model.js</i> so that it can be used from other files. We can do this using module.exports object.</li>
                        <pre>
                            <code>
                //model.js

                const getAccessToken = (accessToken) => {
                let tokens = db.tokens.filter((savedToken)=>{
                    return savedToken.accessToken === accessToken;
                })
                return tokens[0];
                }
                            </code>
                        </pre>
                        <li><strong>module.export</strong> will look like this</li>
                        <pre>
                            <code>
                module.exports = {
                    getClient: getClient,
                    saveTokens: saveTokens,
                    getUserFromClient: getUserFromClient,
                    getAccessToken: getAccessToken
                }
                            </code>
                        </pre>
                        <li><strong>Authentication Middleware: </strong>
                        With the model function for checking access tokens implemented, let’s create a middleware function 
                        to handle authenticating access tokens inside our application. Inside <i>app.js</i>, we will create a function 
                        named <i>authenticateRequest()</i> that takes three arguments: <i>req</i>, <i>res</i>, <i>next</i>.

                        Inside the function, we create a new variable named request and set it to a new instance of 
                        <i>OAuth2Server.Request()</i>, taking in the HTTP request, req, as the argument.
                        We’ll create a new variable named response and set it to a new instance of <i>OAuth2Server.Response()</i>, 
                        passing in the HTTP response, res.

                        We then return <i>.authenticate()</i> method, that is provided by the OAuth2Server object, on oauth, 
                        passing in response and request. The method returns a Promise that resolves to the access token object 
                        returned from the <i>.getAccessToken()</i> method we defined in model.js. We’ll use a promise chain to handle the flow.
                        We use the <i>.then()</i> method, and if the access token is valid, we can call the <i>next()</i> function to call the 
                        next function. We’ll chain the .catch() method to handle an error or if the access token is invalid. 
                        Inside <i>.catch()</i> method, we can send a response back to the client using the </i>.send()</i> method.
                        Finally, we can add <i>authenticateRequest</i> as a middleware function to a route to restrict access. 
                        Now the client must include the bearer token in the header when making a request to the route to 
                        gain authenticated access.</li>
                        <pre>
                            <code>
            //app.js
                                
            const authenticateRequest = (req, res, next) => {
            
            let request = new OAuth2Server.Request(req);
            let response = new OAuth2Server.Response(res);
            
            return oauth.authenticate(request, response)
                .then(()=>{
                    next();
                })
                .catch((err) => {
                    res.send('You are not allowed')
                })
            }
                            </code>
                        </pre>
                        <li><strong>authenticateRequest as middleware</strong> to '/secret'</li>
                        <pre>
                            <code>
            // app.js                    
                        
            app.get('/secret', authenticateRequest, (req, res)=>{
                res.send('Welcome to the secret area.');
            })
                            </code>
                        </pre>
                    </ul>
                    <hr/>
                    <li><strong>Full</strong> <i>app.js</i> implementation:</li>
                    <pre>
                        <code>
            const express = require('express');
            const path = require('path');
            const OAuth2Server = require('oauth2-server');

            const app = express();

            app.use(express.json());
            app.use(express.urlencoded({extended: true}));

            const PORT = 4001;

            const oauth = new OAuth2Server({
                model: require("./model"),
                allowBearerTokensInQueryString: true
            })

            const authenticateRequest = (req, res, next) => {
            
            let request = new OAuth2Server.Request(req);
            let response = new OAuth2Server.Response(res);
            
            return oauth.authenticate(request, response)
                .then(()=>{
                    next();
                })
                .catch((err) => {
                    res.send('You are not allowed')
                })
            }

            const obtainToken = (req, res) => {
                let request = new OAuth2Server.Request(req);
                let response = new OAuth2Server.Response(res);

                return oauth.token(request, response)
                .then((token) => {
                    res.json(token);
                })
                .catch((err) => {
                    res.json(err);
                })
            }

            app.all('/auth', obtainToken);

            app.get('/', (req, res)=>{
                res.sendFile(path.join(__dirname, 'public/home.html'));
            })
            app.get('/login', (req, res)=>{
                res.sendFile(path.join(__dirname, 'public/login.html'));
            })

            app.get('/public', (req, res)=>{
                res.sendFile(path.join(__dirname, 'public/allowed.html'));
            })

            app.get('/secret', authenticateRequest, (req, res)=>{
                res.send('Welcome to the secret area.');
            })

            app.listen(PORT, ()=>console.log(`Listening on port ${PORT}`));

                        </code>
                    </pre>
                    <hr/>
                    <li><strong>Testing Endpoints with HTTP</strong></li>
                    We’ve implemented the Client Credentials OAuth 2.0 flow in our application! The handling 
                    of access tokens is done with HTTP requests. We can make an HTTP POST request to the /auth 
                    route to obtain an access token.
                    <pre>
                        <code>
                    POST http://localhost:4001/auth
                    Content-Type: application/x-www-form-urlencoded
                    Authorization: Basic Y29kZWNhZGVteTpjb2RlY0BkZW15
                    
                    grant_type=client_credentials
                        </code>
                    </pre>
                    <li>In the HTTP header, we set Authorization to Basic and the base64 encoded Client ID and Client 
                    Secret. In the POST request data, we provide grant_type=client_credentials. The server will 
                    respond with an access token that looks like this:</li>
                    <pre>
                        <code>
                    {
                        "accessToken":" "<access token>",
                        "accessTokenExpiresAt":"2021-06-17T01:02:37.272Z",
                        "client": {
                            "id": "codecademy"},
                            "user":{}
                        }
                    }
                        </code>
                    </pre>
                    <li>To use the access token while requesting authenticated content, we pass the bearer token in 
                    the Authentication request header, replacing < Access Token > with the token returned from the 
                    request to /auth like so: < /Access >
                    <pre>
                        <code>
                    GET http://localhost:4001/secret
                    Authorization: Bearer < Access Token >
                        </code>
                    </pre>
                    <li><strong>In resume: </strong>
                    On the /login page, the login button sends a POST request to /auth with the Authorization header 
                    already populated with the Client ID. When the server receives the request, the Client ID is passed 
                    to the <i>obtainToken()</i> callback function where the <i>.token()</i> method is called and returns the access 
                    token to the client.
                    Now, when we click the link to /secret the client passes the access token as a URL parameter, and the server 
                    calls the <i>authorizeHandler()</i> callback function where the <i>.authorize()</i> method is called to verify whether 
                    the access token is valid. If the access token is valid, then secret.html is sent to the client, otherwise 
                    <i>error.html</i> is sent.</li>
                </ul>
            </div>
        </div>
        <div class="styleGuide">
            <h2>Test-driven development (TDD)</h2>
            <ul>
                <li><strong>TDD: </strong> 
                When software engineers and development teams build new features, they’re faced with challenging 
                questions along the way. Where do we start development? (Do I start writing HTML, or adding server implementation?).
                What is the most efficient implementation? (Is X implementation faster than Y implementation?).
                How will the new feature impact our existing code? (Will new code introduce a bug?).
                <strong>TDD</strong> is the process of writing tests before implementation code. You use the 
                feedback from your tests to inform the implementation of a feature or outcome.</li>
                <li><strong>Red, Green, Refactor approach:</strong> A common approach to TDD is the <strong>red, green, refactor cycle</strong>. When you write a test before the implementation 
                exists you start “in the <strong>red</strong>” phase, because your test fails and outputs a red error message. 
                Next, you write the minimum implementation code to get your test to pass. This puts you “in the <strong>green</strong>” phase, 
                because your test passes and outputs a green message.
                Once you are in the green, you should consider whether your implementation is the best or most efficient 
                approach. If you think your code could be written more efficiently or cleaner, then you enter the 
                <strong>refactor</strong> phase. You can refactor your code with confidence, because you have tests that cover the 
                expected behavior.</li>
                <li><strong>Outside-in TDD:</strong> Is an approach that developers use to build full-stack 
                web applications. It leverages the same red, green, refactor steps that we covered above, but with one caveat — a 
                failing test does not always inform you to write new implementation code. Instead, it may require that you implement 
                new functionality at a different level. </li>
                <ul>
                    <li>You start at the top of the stack, the view, and write 
                    tests as you work your way towards the database layer. If a test pushes you to a lower level, 
                    you restart your red, green, refactor cycle by writing a new test. This test informs the 
                    implementation at your new layer. You continue the TDD cycle at this lower level until: 
                    You need to drop another layer to implement the desired behavior /
                    You have addressed the reason for dropping to the current layer.</li>
                    <li>Once you address the reason for dropping a layer, you can start working your way back up the <strong>testing pyramid</strong>. 
                    If you’re in the model/database layer, you step up to the server, and run your server tests to see if you get 
                    a different response. The response should be one of the following:</li>
                    <ul>
                        <li><strong>The test passes</strong> — you can start another red, green, refactor cycle at the server level or step up to the view layer.</li>
                        <li><strong>The test fails</strong> — the server test that pushed you to the model layer fails, but for a different reason.
                        This is common, and indicates that you’re making progress. This failure may indicate that you need to write 
                        additional implementation at the server level, or drop back to the model.</li>
                    </ul>
                </ul>
                <p class="center"><strong>Outside-in TDD example:</strong></p>
                <button id="showCode44" onclick="showCode('displayCode44', 'showCode44')">Display</button>
                <div id="displayCode44">
                    <button onclick="closeCode('displayCode44', 'showCode44')">Close</button>
                    <li><strong>Outside-in Example</strong></li>
                    <ul>
                        <li>We’re going to use the following as an example of how to develop a new feature with 
                        outside-in TDD: You have a movie blog and want to develop a feature that renders user comments 
                        under your blog posts. The application should render no more than ten comments when a user lands
                        on the web page. The application should present the comments in reverse chronological order 
                        (i.e. the most recent comment should be first).
                        Let’s assume the web application generates HTML at the server — any updates to the view require 
                        implementation at the server level.</li>
                        <li><strong>Feature Testing: </strong>
                        The first step is to write a feature test that checks if your web application is rendering 
                        comments to the browser. Let’s use the following outside-in TDD approach:</li>
                        <ol>
                            <li>Write a test that checks for the presence of a comment under a blog post.</li>
                            <li>The test fails, because your web application does not render comments.</li>
                            <li>Because your web application generates HTML at the server layer, you drop to the server to address the error.
                            Although we could continue to write feature tests to check for the number of rendered comments, 
                            we know server tests are cheaper, so we can test those details when we drop a layer.</li>
                        </ol>
                        <li><strong>Server Testing: </strong>
                        At the server layer, we start by writing a test that informs the implementation of our 
                        -generated HTML. Because our web application renders unique comments from the database, 
                        we want to check that the server-generated HTML is dynamic.</li>
                        <ol>
                            <li>Write a test that checks for the presence of a dynamically generated comment element in the server HTML.</li>
                            <li>The test fails, so we add implementation for a server-generated comment.</li>
                            <li>Once we’re in the green and consider refactoring, we want to write a test that calls a method at the model 
                            layer, let’s call it <i>Comment.latest()</i>. At the server layer, we’ll check if the method returns comments from the database.</li>
                            <li>Because this method doesn’t exist, we must drop to the model/database layer.</li>
                        </ol>
                        <li><strong>Model and Database Testing:</strong>
                        At the model layer, we start by writing a test that informs the implementation of our Comment.latest method. This method requires that 
                        you interface with the web application’s database.</li>
                        <ol>
                            <li>Write a test that checks if the Comment.latest method returns ten comments when the database has eleven comments.</li>
                            <li>Implement the Comment.latest method to return ten comments, so the test is green.</li>
                            <li>Once you’ve considered refactoring, write a test that checks whether the method returns the last ten comments in reverse chronological order.</li>
                            <li>Implement and refactor.</li>
                            <li>Write a test that checks if Comment.latest() returns an empty array when your database is empty.</li>
                            <li>Implement and refactor.</li>
                            <li>Write a test that checks if Comment.latest returns the correct number and order of comments when your database has between zero and ten comments in it.</li>
                            <li>Implement and refactor.</li>
                        </ol>
                        <li><strong>Taking Stock:</strong> At this point, your entire test suite should be green. You have written seven new tests, and the implementation code to make them pass — your web application 
                        should render the last ten comments from your database in reverse chronological order.
                        Let’s take stock of our seven new tests:</li>
                        <ol>
                            <li><strong>Feature:</strong> Comments are rendered to a user’s browser.</li>
                            <li><strong>Server:</strong> The server generates an HTML field for comments.</li>
                            <li><strong>Server:</strong> The server has access to ten comments from the database.</li>
                            <li><strong>Model:</strong> The Comment.latest method returns ten comments from your database.</li>
                            <li><strong>Model:</strong> The Comment.latest method returns the last ten comments in your database in reverse chronological order.</li>
                            <li><strong>Model:</strong> The Comment.latest method returns an empty array when your database has zero comments.</li>
                            <li><strong>Model:</strong> The Comment.latest method returns all of the comments when your database has between zero and ten comments.</li>
                        </ol>    
                        <li>Once your feature is working as expected, you should consider how your new tests fit into the broader test suite. The rest of the test suite could have few tests, 
                        or over one hundred. It’s time to refactor.</li>
                        <li><strong>Refactoring Your Test Suite: </strong>
                        The way you approach refactoring will vary based on the size and types of tests in your suite. One guiding light in refactoring is to optimize the suite for confidence and speed. Because we used TDD to implement our comment feature, 
                        we should feel confident that our comments are working as expected, and the feature is fully covered.
                        Consider the questions below when deciding how to refactor your suite:</li>
                        <ul>
                            <li>How much longer does it take to run my test suite with these new tests?</li>
                            <li>Is the additional amount of time that your test suite takes to run acceptable?</li>
                            <li>Is there overlap between any of my new tests?</li>
                            <li>Is there overlap between my new tests and existing tests?</li>
                        </ul>   
                        <li>Let’s take a moment to consider a few of these questions in the context of our test suite.</li>
                        <i>How much longer does it take to run my test suite with these new tests?</i>
                        <ul>
                            <li>You can calculate this value by running your test suite before and after writing the new tests, 
                            and calculate the difference. Seven new tests, like the ones above may only add a few seconds to your suite. 
                            Let’s use our next question to think about how you can evaluate what an acceptable amount of time may be.</li>
                        </ul>
                        <i>Is the additional amount of time that your test suite takes to run acceptable?</i>
                        <ul>
                            <li>Although a few seconds may seem acceptable, this time can add up as your suite grows. 
                            if you’re comfortable with the additional time, you should always consider whether you 
                            can make speed improvements that don’t impact confidence.</li>
                        </ul>
                        <i>Is there overlap between any of my new tests?</i>
                        <ul>
                            <li>You should consider if any new tests, especially in the feature or server level, can be 
                            deleted without impacting your confidence that the comments feature works as expected. 
                            For example, our first server test checks if the server generates an HTML field for comments. 
                            Your feature-level test checks the same functionality — it also takes longer, but provides a 
                            higher level of confidence. We decide to delete the server test for reasons we will investigate 
                            when we consider our next question.</li>
                        </ul>
                        <i>Is there overlap between my new tests and existing tests?</i>
                        <ul>
                            <li>Next, you should look outside your seven (now six) new tests to consider the coverage offered 
                            by the other tests in your suite. Often, your test suite will have a feature test that checks 
                            whether the web page renders as expected — this is usually good enough coverage for most new 
                            features. Given the cost of feature-level tests, and the coverage of your lower-level tests, 
                            it often makes sense to delete the new feature-level test.</li>
                        </ul>
                    </ul>
                </div>
                <li><strong>Headless browser testing: </strong>
                Headless testing is a way of running browser UI tests without the head, which in this case means that there’s no 
                browser UI, no GUI of any sorts. This is useful since when running tests, especially in a CI environment, there is 
                nobody “watching” the visuals, so there is no need to have the extra overhead of the browser GUI.
                One of the biggest reasons for using a headless browser/carrying out headless testing is performance, since it lets 
                you run tests more quickly in a real browser environment. 
                <strong>More about it</strong> <a href="https://blog.logrocket.com/introduction-to-headless-browser-testing-44b82310b27c/" target="_blank">here</a>.
                <hr/>
                <h3><strong>Outside-in TDD approach</strong></h3>
                <li><strong>Feature Test Toolbelt: </strong>To write the most effective feature tests, we are going to 
                employ a few additional tools. These tools are meant to support JavaScript testing. We will cover their 
                uses in the scope of building a feature test that drives implementation.
                <strong>Video implementation</strong> <a href="https://www.youtube.com/watch?v=eGcPoUfm6Ow&embeds_euri=https%3A%2F%2Fwww.codecademy.com%2F&embeds_origin=https%3A%2F%2Fwww.codecademy.com&feature=emb_imp_woyt" target="_blank">here</a>.</li>
                <ul>
                    <li><strong>Chai: </strong>
                    Node.js has a default assertion library that provides enough functionality to write basic test code. The Chai testing library extends the types of assertions we can make.
                    Chai is an assertion library for Node.js and browsers that can be paired with any JavaScript testing framework. <strong>Documentation</strong> <a href="https://www.chaijs.com/" target="_blank">here</a>.</li>
                    <li><strong>PhantomJS: </strong>Is a headless browser scriptable with a JavaScript API, which allows us to write tests that mimic user interaction and then evaluate the results. It does not require us to render the application in a browser.
                    A browser runs “headless” when it doesn’t render anything to the screen, but runs in the background. <strong>Documentation</strong> <a href="https://phantomjs.org/documentation/" target="_blank">here</a>.</li>
                    <li><strong>WebdriverI/O: </strong>
                    WebdriverIO provides methods that allow us to programmatically interact with the user-facing elements 
                    of our app in the headless browser that PhantomJS runs. <strong>Documentation</strong> <a href="https://webdriver.io/docs/why-webdriverio/" target="_blank">here</a>.</li>
                    <li><strong>Toolbelt High-Level Summary: </strong>
                    Phantom allows us to run an instance of a headless browser so you can run tests that mimic user 
                    interaction with a web application. WebdriverIO provides the methods to interact with browser values 
                    programmatically. We can make assertions against these tests using the Chai assertion library.</li>
                </ul>
            </ul>
            <p class="center"><strong>Feature Test Example:</strong></p>
            <button id="showCode45" onclick="showCode('displayCode45', 'showCode45')">Display</button>
            <div id="displayCode45">
                <button onclick="closeCode('displayCode45', 'showCode45')">Close</button>
                <li><strong>Feature Test I: </strong>
                Feature tests exercise behavior by simulating a user navigating the application in a web browser.
                Imagine we wanted to create a simple web-based poetry writing application.
                The first feature test we want to write is to check our application’s empty state. 
                The functionality we want to test is:</li>
                <ul>
                    <li>When a user visits the homepage, the poems section is empty.</li>
                    <li>We want to make sure that when there are no poems in the database, there are no poems rendered on the homepage. This is the application’s empty state.</li>
                </ul>
                <li>The term ‘root’, refers to our application’s entry point, which in this example is the home page 
                that users will visit in their browser.</li>
                <li>Next, we add an it block to describe the behavior we want to test in our app.
                When a user visits the root of our app, they should have a blank page on which to write their own poem.</li>
                <li><strong>The Plumbing:</strong>
                Next, we reach for our feature testing toolbelt. We start by to using the global browser variable
                that is provided by WebdriverI/O.
                The browser variable is powerful because it gives us access to the browser that Phantom 
                is running in the background. We can simulate a user interacting with our website by calling 
                different methods on the global browser variable in our test suite.
                For example, we can use browser.url() to simulate a user visiting the home page of our application, 
                which is the first behavior we want to test.
                The .url method navigates to the URL that is passed to it as an argument. The following line of code
                would navigate to the Codecademy website in the Phantom browser.
                In the case of our poetry web app, we will pass in '/' as the argument, which will point the browser to the root file of our project, which in this case is our index.html.</li>
                <li><strong>Assert: </strong>
                The last thing our test needs is an assert statement to verify that the behavior we 
                expect is equal to the actual behavior of our code. We want to make sure our app is in an empty state.
                We can write a test for this behavior by deciding that poems will be listed in an HTML element 
                with an id attribute set to poems. Then, write an assert statement to verify that the element with the ID poems is empty.
                We can do this using the Chai assert.equal method, which evaluates if the two arguments are equal.
                Because we will render the poetry onto the page as text, we can evaluate the contents of the HTML 
                element as a string. The .getText method, from WebdriverI/O, gets the text content from the selected DOM element.
                Here we are using browser.getText() to evaluate if the text in the element with the ID poems is equal 
                to an empty string. Our final code for this feature test would look like this:                            
                <pre>
                    <code>
            describe('User visits root', () => {
                describe('without existing poems', () => {
                    it('page starts blank', () => {
                    browser.url('/');
                
                    assert.equal(browser.getText('#poems'), '');
                    });
                });
            });              
                    </code>
                </pre>
                <li>index.js should be, so test <strong>passes</strong>:</li>
                <pre>
                    <code>
                    < section id="poems" >< /section >
                    </code>
                </pre>
                <hr/>
                <li><strong>Feature Test II: </strong>Now we want to write a test to check if the application saves 
                the title and text of a user’s poem when they press the submit button.
                The functionality we want to test is:</li>
                <ol>
                    <li>The user enters text into a text input element (the poem).</li>
                    <li>The user enters text into a second text input element (the title of the poem).</li>
                    <li>The user presses a submit button</li>
                </ol>
                <li>Next, we want to write the setup, exercise, and verification phases of our test.
                In the setup phase for this test, we create variables to represent a user’s input
                to the title and poem fields on the home page. The second test will look like this:</li>
                <li>The next step for our poetry web app is to use our browser variable for the exercise phase of the test.
                First, we will set the URL of the browser to go to the root of our project using the .url method.
                Next, we will use the .setValue method, which sends a sequence of keystrokes to an element, based 
                on a string argument.
                We will use .setValue() to mimic a user entering the title and poem into the corresponding HTML 
                input elements at the root of our web app.
                The first argument passed to .setValue() is the CSS selector that references an HTML element, and the 
                second argument is the value you want to assign that element.</li>
                <pre>
                    <code>
            browser.setValue('input[id=title]', title);
            browser.setValue('textarea[id=poem]', poem);
                    </code>
                </pre>
                <li>In the example above, a text input with the ID of title will be set to a value of title. Also, the 
                textarea with ID poem will be set to the value poem. The variables referenced here are the ones we 
                created in the setup phase.
                To complete the exercise phase of our test we would use the .click method to mimic a user clicking
                on a submit button. browser.click('input[type=submit]');
                Now that we have programmed the behavior we want to test in the exercise phase, we will write the 
                verification phase of our test. We will compare the actual results of exercising the code with the 
                expected results.
                In the case of our poetry app, we want to verify that once a user submits a poem, the section of the 
                app’s webpage that we have decided will display the poems includes that poem.
                We have created that element already to make our first feature test pass. It is the following line 
                of code in our index.html file:</li>
                <pre>
                    <code>
                < section id="poems" >< /section >
                    </code>
                </pre>
                <li>To add an assert statement to evaluate the behavior of our feature, we will use the browser 
                variable, and .getText() to return the text contents of the element, with the id poem.
                The Chai Assertion Library allows us to use the .include method to check if the string that is returned
                from .getText() includes the substrings of the title and poem that the user has submitted:
                assert.include(browser.getText('#poems'), title);
                assert.include(browser.getText('#poems'), poem);
                In both assert statements the first argument we pass to .include() is the function we created above it.</li>
                <pre>
                    <code>
            describe('demo poetry web app', () => { 
                it('saves the user poem and title', () => {
                    // Setup
                    const title = 'Words Birth Worlds';
                    const poem = 'Our words are marvelous weapons with which we could behead the sun';
                    // Exercise
                    browser.url('/');
                    browser.setValue('input[id=title]', title);
                    browser.setValue('textarea[id=poem]', poem);
                    browser.click('input[type=submit]');
                    // Verify
                    assert.include(browser.getText('#poems'), title);
                    assert.include(browser.getText('#poems'), poem);
                });
            });
                    </code>
                </pre>
                <li>On <strong>index.js:</strong></li>
                <pre>
                    <code>

                < label for="title" >Title< /label >
                < input id="title" >
                    
                < label for="poem" >Your poem:< /label >
                < textarea id="poem" >< /textarea >
                    
                < input type="submit" >
                    </code>
                </pre>
                <li>This will run an error. While this error message looks similar to the ones before, 
                it is a different type of error message, and it signals the need for a shift in our TDD process.
                What’s different here is that the failure comes from the verification phase instead of the exercise 
                phase. While this isn’t always the case, that means that we’ve changed the implementation code enough 
                to get to the part of the test where we’re specifying behavior, not just the existence of elements.                  
                The kind of test we need to write in response to this error will force us to drop levels in the TDD 
                Testing Pyramid.</li>
            </div>
            <ul>
                <li><strong>Server Testing Stack: </strong>
                Server tests are used to test the server response only, not any front-end rendering of code or user interactions. 
                We “disconnect” the browser and interact directly with the server using requests. The tests define the expected 
                behavior of the interactions and check the actual responses against what we expect.
                Server tests are commonly used to test API responses, but we also use server tests for any server response 
                that our application relies on. This can include checking status codes and error messages. <strong>Video Implementation</strong>
                <a href="https://www.youtube.com/watch?v=2E88EjDJgkw&embeds_euri=https%3A%2F%2Fwww.codecademy.com%2F&embeds_origin=https%3A%2F%2Fwww.codecademy.com&source_ve_path=MjM4NTE&feature=emb_title" target="_blank">here</a>.
                What we use:</li>
                <ul>
                    <li><strong>Chai</strong> - a library for extending the built in Node assertion library</li>
                    <li><strong>jsdom</strong> - a library for interacting and testing the DOM returned by the server
                    (this functionality is encapsulated in our parseTextFromHTML helper function).
                    <strong>Documentation </strong><a href="https://github.com/jsdom/jsdom#readme" target="_blank">here</a>.</li>
                    <li><strong>async / await</strong> - a pattern for making asynchronous code more readable</li>
                    <li><strong>SuperTest</strong> - a library for making Node server requests and testing their 
                    responses. <strong>Tutorial </strong>
                    <a href="https://hackernoon.com/api-testing-using-supertest-1f830ce838f1" target="_blank">here</a>.
                    <strong>Documentation </strong><a href="https://www.codecademy.com/paths/full-stack-engineer-career-path/tracks/fscp-22-back-end-and-feature-testing/modules/wdcp-22-server-testing-with-tdd/external_resources/ext-doc-supertest" target="_blank">here.</a></li>
                </ul>
            </ul>
            <p class="center"><strong>Server Test Example:</strong></p>
            <button id="showCode46" onclick="showCode('displayCode46', 'showCode46')">Display</button>
            <div id="displayCode46">
                <button onclick="closeCode('displayCode46', 'showCode46')">Close</button>
                <ul>
                    <li><strong>Testing Framework (Chai):</strong>When writing tests, sometimes you’ll find that 
                    the tests require calculation steps or inline code to determine if the test is passing. 
                    For example, to test if an array foo includes an element bar using Mocha with the built-in 
                    Node assertion library, we use the JavaScript includes helper:</li>
                    <ul>
                        <pre>
                            <code>
                    assert.ok(foo.includes(bar));
                            </code>
                        </pre>
                        <li>To improve the readability and flow of our tests, we extend the built-in Node assertion library with Chai.</li>
                        <pre>
                            <code>
                    const {assert} = require('chai'); 
                            </code>
                        </pre>
                        <li>The main function in Chai we are using is .include(). This allows us to rewrite the previous example as:</li>
                        <pre>
                            <code>
                    assert.include(foo, bar); 
                            </code>
                        </pre>
                        <li>Include also works to check that text contains certain values:</li>
                        <pre>
                            <code>
                    assert.include('foobar', 'bar'); // Evaluates to true  
                            </code>
                        </pre>
                        <li>The large set of assertion methods in the chai library enable us to write more expressive tests that
                        are easy for developers to understand. Example:</li>
                        <pre>
                            <code>
                const {assert} = require('chai');
                describe('Array', () => {
                    describe('.pop()', () => {
                        it('should return a value and remove the element from the array', () => {
                        // setup
                        const foo = [4];
                        const includedNumber = 4; 
                        // check setup
                    assert.include(foo, includedNumber)
                        // exercise
                        const fooPop = foo.pop();

                        // asserts
                        assert.equal(fooPop, includedNumber)
                        assert.equal(foo.length, 0)
                        });
                    });
                });
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Testing HTML Responses: </strong>
                Our back-end server is serving dynamic HTML to the user. For the homepage, this is located in 
                the jsdom-test.js file to the right. It is possible to use .include() to verify that the HTML
                response contains certain Strings, but gets cumbersome to verify the hierarchical relationships of DOM elements.

                We can use the <strong>jsdom library</strong> to improve this type of assertion. It allows us to 
                select elements of the DOM and check relationships and content. To increase the readability of our 
                tests, we abstracted the jsdom functionality into a custom function, parseTextFromHTML:</li>
                <ul>
                    <pre>
                        <code>   
                const parseTextFromHTML = (htmlAsString, selector) => {
                    const selectedElement = jsdom(htmlAsString).querySelector(selector);
                    if (selectedElement !== null) {
                        return selectedElement.textContent;
                    } else {
                        throw new Error(`No element with selector 
                        ${selector} found in HTML string`);
                    }
                };

                        </code>
                    </pre>
                    <li>This function takes the HTML response as a string and the desired selector as inputs and 
                    returns the textContent of the corresponding element. If no element is found, it will return
                    a TypeError.</li>
                    <pre>
                        <code>

                
                describe('HTML tests', () => {
                    describe('#bar', () => {
                        it('should include the string "Hello"', () => {
                            // setup
                            const foo = '< html >< div id="bar">Hello< /div >< div id="buzz">Hello< /div>< html>';
                            //asserts     
                            assert.include(parseTextFromHTML(foo, "#bar"), 'Hello'); 
                        });
                    });
                });
                        </code>
                    </pre>
                    <li><strong>Async / Await: </strong>
                    A server typically handles many requests at a time, but may be only capable of processing a subset 
                    of the requests concurrently. One side effect of this is that the server response time is neither 
                    instant nor predictable. If no other processes are occurring on the server, requests are handled 
                    quickly, but if the server is close to full capacity, the request can take a few seconds or even timeout.
                    We need a way to receive asynchronous responses from the server and then act on them. The async/await pattern introduced in Node 8 helps us write readable descriptions of the behavior of our application which is an important part of writing good tests.                  
                    To use this pattern, define the function with the async keyword. Then, within the function, use the await keyword in front of the asynchronous function you are calling.
                    Here, we are waiting for someAsyncThing() to return before logging the result to the console:</li>
                    <pre>
                        <code>
                const request = require('supertest');
                const app = require('../../app');
                
                describe('the homepage', () => {
                    it('returns the correct content', async () => {
                    const response = await request(app)
                        .get('/')
                        .send();
                        console.log(response.text);
                    });
                });                            
                        </code>
                    </pre>
                    </ul>
                    <li><strong>SuperTest:</strong>
                    As you may have noticed in the previous exercise, we are using the function request to make 
                    server calls to support our tests. This is actually a reference to the SuperTest library:
                    <i>const request = require('supertest');</i>This library was specifically designed for testing Node server responses and integrates well with 
                    Mocha and Chai. To use SuperTest, we pass the app object from our app into the request function. 
                    To make a GET request, we use .get() with the desired route as the argument:</li>
                    <ul>
                        <pre>
                            <code>                
                await request(app)
                        .get('/')
                        .send();
                            </code>
                        </pre>    
                        <li>It is also possible to perform a POST using SuperTest. We chain any desired properties or 
                        inputs to the HTTP call, and use .send() to make the request:</li>
                        <pre>
                            <code>
                await request(app)
                        .post('/messages')
                        .type('form')
                        .send({author, message});
                            </code>
                        </pre>    
                    </ul>
                    <hr/>
                    <li><strong>Server Testing Patterns: </strong></li>
                    <ul>
                        <li><strong>Status Codes: </strong>
                        Server tests are slightly faster than browser-driven feature tests. Since the web browser is cut 
                        out of the test, we are not testing how things are rendered for the user. Instead, we are focused 
                        on the server response.
                        One use of TDD at the server level is to ensure that the HTTP status codes are returned as 
                        expected. Verifying status codes provide the most basic level of confidence that the server 
                        is functioning correctly. Having a test suite that includes status codes provides a quick check 
                        when implementing a new feature that we haven’t accidentally caused a request for valid routes to 
                        respond not authorized (401) or not found (404). 
                        To verify status codes, we are asserting that the response status is equal to the status code 
                        integer that our application requires: <i>assert.equal(response.status, 200);</i>
                        If we use the “red, green, refactor” approach to implement our server behavior we would start out 
                        with an assertion like this and expect it to fail (“red”). We then implement the behavior to pass
                        the test (“green”) and continue to refactor if needed, ensuring the test remains passing.</li>
                        <pre>
                            <code>
                        //index-test.js
            
                        const {assert} = require('chai');
                        const request = require('supertest');
                        
                        const app = require('../../app');
                        
                        describe('root page', () => {
                            describe('GET request', () => {
                                it('returns a 200 status', async () => {
                                    const response = await request(app).
                                    get('/');
                                    assert.equal(response.status, 200);
                                });
                            });
                        });
                            </code>
                        </pre>
                        <pre>
                            <code>
                    //index.js
            
                    const express = require('express');
                    const router = express.Router();
            
                    router.get('/', (req, res) => {
                    res.send()
                    });
            
                    module.exports = router;
            
                            </code>
                        </pre>
                        <li><strong>Response Content:</strong>
                        In the previous exercise, we checked that the server responded with specific status codes. Now we need to 
                        make sure the server is responding with the correct content. Specifically, we are looking at HTML responses 
                        that are rendered by the front-end.
                        Many servers return dynamic HTML content based on the user, the URL accessed, header values, and more. 
                        We use TDD to ensure the server responds correctly for each case. When designing our tests, it is 
                        important to consider both the intended and unintended user behavior.
                        We can organize our tests into two categories:</li>
                        <ul>
                            <li>tests that exercise the “Happy Path” — expected use cases of our application</li>
                            tests that exercise the “Sad Path” — unexpected or invalid use of our application
                            <li>For our tests, once we retrieve the response from the server, we use assert.include() 
                            from the Chai library to check the response.</li>
                        </ul>
                        <li>As an example, after requesting a valid profile page for “My Name”, you may receive the following 
                        response content:</li>
                        <pre>
                            <code>
            response.text = '< div>< div id="my-name">My Name< /div>< /div>';
                            </code>
                        </pre>
                        <li>You can retrieve the content of #my-name and check it using the following:</li>
                        <pre>
                            <code>
            assert.include(parseTextFromHTML(response.text, '#my-name'), "My Name"); //True
                            </code>
                        </pre>
                        <li>We could also write a separate test to check the corresponding “sad path”. Perhaps there is not yet a page for “Your Name”, so you should not receive a response containing similar HTML. We use .notInclude() to verify that the response is not including “Your Name” :</li>
                        <pre>
                            <code>
            assert.notInclude(parseTextFromHTML(response.text, '#my-name'), "Your Name"); //True
                            </code>
                        </pre>
                        <li>Note that here we are identifying the HTML elements by their ID using our parseTextFromHTML() helper but you can use any selectors supported by the jsdom library. This helper is returning the text content of the corresponding HTML element only, but you could write a separate helper for accessing other attributes.</li>        
                    </ul>
                    <li><strong>Refactoring: Route Parameters</strong>
                    In the previous exercise, we checked that the server responded with a specific message. On our home page, the title is constant for everyone, “Messaging App”.
                    What if we want to create a profile page that is customized for each user?
                    A straightforward implementation would be to generate hard coded routes for every single user of our app. Think: 'welcome/alice' => '< h1>Your Name is alice< /h1>', 'welcome/bob' => '< h1>Your Name is bob< /h1>', etc.
                    Hopefully if you see repetitive code like this, you’ll have an urge to refactor it to something more elegant using a variable route parameter. This allows us to put any username into the url and have the server generate the appropriate response. Think: 'welcome/:username' => '< h1 >Your Name is ' + req.params.username +'< /h1 >'.
                    If you are using the red, green, refactor approach, you will start with a set of passing (“green”) assertions for the section of code you are looking to improve. With the current behavior captured, you can begin refactoring, knowing that your tests will “catch” you by turning red if you miss something in your approach.</li>
                    <pre>
                        <code>
                //profile-test.js
    
                const {assert} = require('chai');
                const request = require('supertest');
                const {jsdom} = require('jsdom');
    
                const app = require('../../app');
    
                const parseTextFromHTML = (htmlAsString, selector) => {
                    const selectedElement = jsdom(htmlAsString).querySelector(selector);
                    if (selectedElement !== null) {
                        return selectedElement.textContent;
                    } else {
                        throw new Error(`No element with selector ${selector} found in HTML string`);
                    }
                };
    
                describe('profile page', () => {
                    describe('GET request', () => {
                        it('greets alice', async () => {
                            const response = await request(app).
                            get('/profile/alice');
                            assert.equal(parseTextFromHTML(response.text, '#welcome-message'), 'Welcome alice!');
                        });
                        it('greets bob', async () => {
                            const response = await request(app).
                            get('/profile/bob');
                            assert.equal(parseTextFromHTML(response.text, '#welcome-message'), 'Welcome bob!');
                        });
                    });
                });
                        </pre>
                    </code>
                    <pre>
                        <code>
                //profile.js
    
                const express = require('express');
                const router = express.Router();
    
    
                router.get('/:username', (req, res) => {
                    res.send('< h1 id="welcome-message">Welcome ' + req.params.username + '!< /h1>');
                });
    
                module.exports = router;
                        </code>
                    </pre>
                    <li><strong>Refactoring: Handlebars</strong>
                    Sometimes during the reflection of the refactor phase, you will realize that you can implement something better or more efficiently. In the code so far, we have been responding with inline HTML strings. On a large project, this could make it difficult for the front end developer to organize and maintain.
                    An improved approach to this is using a templating library like Handlebars to separate the HTML view from the JavaScript controller.
                    In the web app that you’ve built in this lesson, we’ve placed the templates in the /views folder and have an extension of .handlebars. Our controller will now use render to create the view and pass in any variables:</li>
                    <ul>
                        <pre>
                            <code>
                        const param = 'Foo';
                        res.render('templateName', {param});
                            </code>
                        </pre>
                        <li>The templates are written like regular HTML, but variables can be accessed within the view using 
                        double curly braces: <i>< h1 >{{ param }}< /h1></i> 
                        When the view is rendered, it will replace {{ param }} with its actual value:
                        <i>< h1>Foo< /h1></i></li>
                    </ul>
                    <li><strong>API Errors: </strong>
                    As mentioned earlier, one of the use cases for server testing is for checking API responses, 
                    especially the “sad path” where a user interacts with the server in an unexpected or disallowed 
                    manner. We need to make sure our server properly handles invalid passwords, form field errors, etc.
                    Ensuring the app is designed to withstand these issues and that the error interactions are well 
                    bounded is important.
                    Keep in mind that while there may only be one “happy path” for an interaction (user submits a 
                    valid password), there can be many corresponding “sad paths” (password is too short, doesn’t 
                    contain special characters, etc). By testing the majority of these on the server level, it saves 
                    us from testing them at a more resource intensive level including the user view.</li>
                    <li><strong>Summary</strong>
                    We used several technologies to write tests for both “happy” and “sad” paths of:
                    <ul>
                        <li>Server status codes</li>
                        <li>Server response content</li>
                        <li>Error cases</li>
                    </ul>
                    <li>We also saw how TDD can be used at the server level to guide the implementation of the server code:</li>
                    <ul>
                        <li>We wrote a failing test</li>
                        <li>We wrote the minimal required server code to pass the test</li>
                        <li>When we decided or needed to refactor to meet external requirements, we used the existing tests to make sure our refactored code maintained the same end behavior</li>
                    </ul>
                </ul>
                <hr/>
            </div>
            <li><strong>Is it worth a server test?: </strong>In general, it is up to the developer to make a judgement call on how in depth to write a test. Every test 
            written adds time to the testing cycle and can require maintenance if changes are made to the server 
            behavior. For example, extensively testing failure cases at the feature level might be more than is needed 
            if the error behavior can be fully tested and described at the server level.
            As you develop an application, you may realize that you can replace feature tests or reduce them with equal 
            coverage at a lower level. One question to ask when deciding between a full feature test versus a server 
            test is:
            “Is it worth trading a slow feature test for a faster server test that doesn’t test the UI?”
            Based on the context of the different levels of testing, you should aim to pick the set of tests that gives you the best combination of reliable, complete and fast tests.</li>
        </div>
        <div class="styleGuide">
            <h2>Database</h2>
            <ul>
                <li><strong>Database</strong> is a set of data stored in a computer. This data is usually structured in 
                a way that makes the data easily accessible.</li>
                <li><strong>Relational Database: </strong>
                A relational database is a type of database. It uses a structure that allows us to identify and access
                data in relation to another piece of data in the database. Often, data in a relational database is 
                organized into tables.</li>
                <ul>
                    <li><strong>Tables (Rows and Columns):</strong>
                    Tables can have hundreds, thousands, sometimes even millions of rows of data. These rows are often called 
                    records. Tables can also have many columns of data. Columns are labeled with a descriptive name 
                    (say, age for example) and have a specific data type.
                    For example, a column called age may have a type of INTEGER (denoting the type of data it is meant to hold).
                    In the table above, there are three columns (name, age, and country).
                    The name and country columns store string data types, whereas age stores integer data types. The set of 
                    columns and data types make up the schema of this table.
                    The table also has four rows, or records, in it (one each for Natalia, Ned, Zenas, and Laura).</li>
                </ul>
                <li><strong>NoSQL: </strong>
                Any database technology that stores data differently from relational.
                databases can be categorized as a NoSQL database.</li>
                <li><strong>Relational database VS NoSQL: </strong>Using a <strong>relational</strong> database structure, we might separate the information for each person, having 
                their id, name, and email, in one table named customers, and then another table for the subscriptions,
                having the newsletter name, and other information associated with the subscriptions.
                With a <strong>NoSQL database</strong>, instead of separating information in this way, 
                we might just have a single 
                document with the person’s information, as well as the subscription information, all in one document.</li>
                <hr/>
                <h3>Relational Database Management System (RDBMS)</h3>
                <li><strong>Relational Database Management System (RDBMS):</strong>
                A relational database management system (RDBMS) is a program that allows you to create, update, and 
                administer a relational database. Most relational database management systems use the SQL language to 
                access the database. <strong>SQL (Structured Query Language)</strong> is a programming language used 
                to communicate with data stored in a relational database management system. SQL syntax is similar to 
                the English language, which makes it relatively easy to write, read, and interpret.
                Many RDBMSs use SQL (and variations of SQL) to access the data in tables. For example, SQLite is a 
                relational database management system. SQLite contains a minimal set of SQL commands (which are the 
                same across all RDBMSs). Other RDBMSs may use other variants.
                (SQL is often pronounced in one of two ways. You can pronounce it by speaking each letter individually 
                like “S-Q-L”, or pronounce it using the word “sequel”.)
                By learning the fundamentals with one RDBMS, you can easily begin work in another. Here are some popular RDBMSs:</li>
                <ul>               
                    <li><strong>MySQL:</strong> Is the most popular open source SQL database. It is typically used for web 
                    application development, and often accessed using PHP.
                    The main advantages of MySQL are that it is easy to use, inexpensive, reliable (has been around 
                    since 1995), and has a large community of developers who can help answer questions.                   
                    Some of the disadvantages are that it has been known to suffer from poor performance when scaling,
                    open source development has lagged since Oracle has taken control of MySQL, and it does not 
                    include some advanced features that developers may be used to.</li>
                    <li><strong>PostgreSQL</strong> Is an open source SQL database that is not controlled by any corporation. It is typically used for web application development.
                    PostgreSQL shares many of the same advantages of MySQL. It is easy to use, inexpensive, reliable and has a large community of developers. It also provides some additional features such as foreign key support without requiring complex configuration.                   
                    The main disadvantage of PostgreSQL is that it can be slower in performance than other databases such as MySQL. It is also slightly less popular than MySQL.
                    For more information about PostgreSQL including installation instructions, read this 
                    <a href="https://www.postgresql.org/" target="_blank">article</a>.</li>
                    <p class="center"><strong>Postgre Implementation:</strong></p>
                    <button id="showCode49" onclick="showCode('displayCode49', 'showCode49')">Display</button>
                    <div id="displayCode49">
                        <button onclick="closeCode('displayCode49', 'showCode49')">Close</button>
                        <li>In order to run and use Postgres on your own computer, you will need to <strong>set up both 
                        a Postgres server and a client.</strong></li>
                        <li><strong>Setting Up Postgres (server): </strong>
                        Installation 
                        <a href="https://www.postgresql.org/download/windows/" target="_blank">here</a>.
                        You’ll be prompted to enter in a password for the postgres user: for now, set the password 
                        as “postgres”. If you are asked to enter a port, you can use the default of “5432”.
                        After completing the installation, you may be asked whether you would like to use Stack 
                        Builder to install additional software. You shouldn’t need to install anything else for now.</li>
                        <li><strong>Setting up Postgres (client): </strong>
                        Now that Postgres is running locally, we can connect to it via a “client” – a graphical or 
                        command-line interface that enables us to connect to the Postgres server, write and execute 
                        SQL commands as input, and see the resulting output.
                        While you can have only one instance of Postgres running per port (typically 5432), you 
                        can have multiple open connections to the same database with different interfaces. 
                        There are many options; our preferences are listed below!</li>
                        <ul>
                            <li><strong>GUI: </strong>Our preference for a cross-platform software to visually 
                            interact with Postgres is <a href="https://github.com/Paxa/postbird" target="_blank">Postbird</a>.
                            A strong runner up is <u>PgAdmin</u>, one of the most popular and feature-rich open source 
                            administration and development platforms for Postgres.                        
                            Postbird will automatically open, and from there you can enter in the username (postgres) and password 
                            (postgres) to connect to your locally running Postgres instance.
                            From there you can now use Postbird to start writing SQL queries. You can select the database you want to 
                            work in using the dropdown menu in the top left corner, you can add tables to that database using the plus 
                            sign in the bottom left corner, and you can use the query tab to write SQL queries to manipulate and investigate
                            tables that you create!
                        </li>
                            <li><strong>Command Line: </strong>
                            You can also connect using the command line tool <a href="https://www.postgresql.org/docs/9.3/app-psql.html" target="_blank">psql</a>.</li>
                        </ul>
                        <hr/>
                    </div>
                    <li><strong>Oracle DB: </strong>Oracle Corporation owns Oracle Database, and the code is not open sourced.
                    Oracle DB is for large applications, particularly in the banking industry. Most of the world’s 
                    top banks run Oracle applications because Oracle offers a powerful combination of technology and 
                    comprehensive, pre-integrated business applications, including essential functionality built specifically for banks.                   
                    The main disadvantage of using Oracle is that it is not free to use like its open source 
                    competitors and can be quite expensive.</li>
                    <li><strong>SQL Server</strong>
                    Microsoft owns SQL Server. Like Oracle DB, the code is close sourced.                   
                    Large enterprise applications mostly use SQL Server.
                    Microsoft offers a free entry-level version called Express 
                    but can become very expensive as you scale your application.</li> 
                    <li><strong>SQLite</strong> is a popular open source SQL database. It can store an entire database 
                    in a single file. One of the most significant advantages this provides is that all of the data can be stored locally without having to connect your database to a server.
                    SQLite is a popular choice for databases in cellphones, PDAs, MP3 players, set-top boxes, and 
                    other electronic gadgets. The SQL courses on Codecademy use SQLite.                   
                    For more info on SQLite, including installation instructions, read this article.</li>
                </ul>
                <li><strong>Material</strong> <a href="https://www.codecademy.com/resources/docs/general/relational-database?page_ref=catalog" target="_blank">here</a>.</li>
                <li><strong>List of SQL Commands</strong> <a href="https://www.codecademy.com/article/sql-commands" target="_blank">here</a>.</li>
                <li><strong>Table Video implementation</strong> <a href="https://www.youtube.com/watch?v=nwLV5Txc8jM&embeds_euri=https%3A%2F%2Fwww.codecademy.com%2F&embeds_origin=https%3A%2F%2Fwww.codecademy.com&source_ve_path=MjM4NTE&feature=emb_title" target="_blank">here</a>.</li>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode47" onclick="showCode('displayCode47', 'showCode47')">Display</button>
                <div id="displayCode47">
                    <button onclick="closeCode('displayCode47', 'showCode47')">Close</button>
                    <li><strong>Manipulation</strong></li>
                    <ul>
                        <li><strong>Statements:</strong>
                        The code below is a SQL statement. A statement is text that the database recognizes as a 
                        valid command. Statements always end in a semicolon <i>;</i>.</li>
                        <pre>
                            <code>
                        CREATE TABLE table_name (
                            column_1 data_type, 
                            column_2 data_type, 
                            column_3 data_type
                        );
                            </code>
                        </pre>
                        <ol>
                            <li><strong>CREATE TABLE</strong> is a clause.  
                            Clauses perform specific tasks in SQL. By convention, clauses are 
                            written in capital letters. Clauses can also be referred to as commands.
                            CREATE TABLE tells SQL you want to create a new table.</li>
                            <li><strong>table_name</strong> refers to the name of the table that the command is 
                            applied to.</li>
                            <li><strong>(column_1 data_type, column_2 data_type, column_3 data_type)</strong> 
                            is a parameter. A parameter 
                            is a list of columns, data types, or values that are passed to a clause as an argument. 
                            Here, the parameter is a list of column names and the associated data type.</li>
                        </ol>
                        <li><strong>SELECT</strong> statements are used to fetch data from a database.:</li>
                        <pre>
                            <code>
                SELECT name FROM celebs;
                            </code>
                        </pre>
                        <ol>
                            <li><strong>SELECT</strong> is a clause that indicates that the statement is a query. You will use SELECT every 
                            time you query data from a database. SELECT statements always return a new table called the result set.</li>
                            <li>name specifies the column to query data from (we can use * to select every column in a table).</li>
                            <li><strong>FROM</strong> celebs specifies the name of the table to query data from. In this statement, data is 
                            queried from the celebs table.</li>
                        </ol>
                        <li>The <strong>INSERT</strong> statement inserts a new row into a table.
                        (id, name, age) is a parameter identifying the columns that data will be inserted into.
                        <strong>VALUES</strong> is a clause that indicates the data being inserted.</li>
                        <pre>
                            <code>
                INSERT INTO celebs (id, name, age)
                VALUES (1, 'Justin Bieber', 22);

                //For multiple insertion
                INSERT INTO table (col1, col2, col3)
                VALUES
                (row1_val1, row1_val2, row1_val3),
                (row2_val1, row2_val2, row2_val3),
                (row3_val1, row3_val2, row3_val3);
                            </code>
                        </pre>
                        <li>The <strong>ALTER TABLE:</strong> statement adds a new column to a table. You can use this command 
                        when you want to add columns to a table.</li>
                        <ul>
                            <pre>
                                <code>
                    ALTER TABLE celebs 
                    ADD COLUMN twitter_handle TEXT;
                                </code>
                            </pre>
                            <li><strong>ADD COLUMN</strong> is a clause that lets you add a new column to a table:</li>
                            <ul>
                                <li>twitter_handle is the name of the new column being added</li>
                                <li>TEXT is the data type for the new column</li>
                            </ul>
                            <li>NULL is a special value in SQL that represents missing or unknown data. Here, the 
                            rows that existed before the column was added have NULL (∅) values for twitter_handle.</li>
                        </ul>
                        <li>The <strong>UPDATE</strong> statement edits a row in a table. You can use the UPDATE statement when you 
                        want to change existing records.
                        The ALTER statement is used to modify columns. With ALTER, you can add columns, remove them, 
                        or even modify them.
                        The UPDATE statement is used to modify rows. However, UPDATE can only update a row, and cannot 
                        remove or add rows.</li>
                        <ul>
                            <pre>
                                <code>
                UPDATE celebs 
                SET twitter_handle = '@taylorswift13' 
                WHERE id = 4; 
                                </code>
                            </pre>
                            <li>SET is a clause that indicates the column to edit.</li>
                            <ul>
                                <li>twitter_handle is the name of the column that is going to be updated</li>
                                <li>@taylorswift13 is the new value that is going to be inserted into the twitter_handle column.</li>
                            </ul>
                            <li><strong>WHERE</strong> is a clause that indicates which row(s) to update with the new 
                            column value. Here the row with a 4 in the id column is the row that will have the twitter_
                            handle updated to @taylorswift13.</li>
                        </ul>
                        <li>The <strong>DELETE FROM</strong> statement deletes one or more rows from a table. You can use the 
                        statement when you want to delete existing records. The statement below deletes all 
                        records in the celebs table with no twitter_handle:</li>
                        <ul>
                            <pre>
                                <code>
                DELETE FROM celebs 
                WHERE twitter_handle IS NULL;
                                </code>
                            </pre>
                            <li><strong>WHERE</strong> is a clause that lets you select which rows you want to delete. Here we want to delete all of the rows where the twitter_handle column IS NULL.</li>
                            <li><strong>IS NULL</strong> is a condition in SQL that returns true when the value is NULL and false otherwise.</li>
                        </ul>
                        <li><strong>Constraints</strong> that add information about how a column can be used are invoked 
                        after specifying the data type for a column. They can be used to tell the database to reject 
                        inserted data that does not adhere to a certain restriction. The statement below sets 
                        constraints on the celebs table.</li>
                        <pre>
                            <code>
                        CREATE TABLE celebs (
                            id INTEGER PRIMARY KEY, 
                            name TEXT UNIQUE,
                            date_of_birth TEXT NOT NULL,
                            date_of_death TEXT DEFAULT 'Not Applicable'
                        );
                            </code>
                        </pre>
                        <ul>
                            <li><strong>PRIMARY KEY</strong> columns can be used to uniquely identify the row. Attempts to insert a 
                            row with an identical value to a row already in the table will result in a constraint 
                            violation which will not allow you to insert the new row.</li>
                            <li><strong>UNIQUE</strong> columns have a different value for every row. This is similar to PRIMARY KEY 
                            except a table can have many different UNIQUE columns.</li>
                            </li><strong>NOT NULL</strong> columns must have a value. Attempts to insert a row without a value for a 
                            NOT NULL column will result in a constraint violation and the new row will not be inserted.</li>
                            <li><strong>DEFAULT</strong> columns take an additional argument that will be the assumed value for an 
                            inserted row if the new row does not specify a value for that column.</li>
                        </ul>
                    </ul>
                </div>
                <hr/>
                <h3>NoSQL</h3>
                <li><strong>NoSQL: </strong>
                NoSQL keeps all the information in one place, in the form of key-values or documents.</li>
                <ul>
                    <li>Benefits:<strong>Scalability:</strong> NoSQL was designed with
                    scalability as a priority. NoSQL can be an excellent choice for massive datasets that need to be 
                    distributed across multiple servers and locations.
                    <strong>Flexibility:</strong> Unlike a relational database, NoSQL databases don’t require a schema. This means that 
                    NoSQL can handle unstructured or semi-structured data in different formats
                    <strong>Developer Experience:</strong> NoSQL requires less organization and thus lets developers focus more on using
                    the data than on figuring out how to store it.</li>
                    <li><strong></strong>Drawbacks:</strong>
                    <strong>Data Integrity:</strong> Relational databases are typically ACID compliant, ensuring high data integrity. 
                    NoSQL databases follow BASE principles (basic availability, soft state, and eventual consistency)
                    and can often sacrifice integrity for increased data distribution and availability. However, some 
                    NoSQL databases do offer ACID compliance.
                    <strong>Language Standardization:</strong> While some NoSQL databases do use the Structured Query Language (SQL), 
                    typically, each database uses its unique language to set up, manage, and query data.</li>
                </ul>
                <li><strong>Types of NoSQL</strong> Databases:</li>
                <ul>
                    <li>A <strong>key-value database</strong> consists of individual records organized via key-value pairs. In this model, 
                    keys and values can be any type of data, ranging from numbers to complex objects. However, keys 
                    must be unique. This means this type of database is best when data is attributed to a unique key, 
                    like an ID number. Ideally, the data is also simple, and we are looking to prioritize fast queries 
                    over fancy features. Amazon <a href="https://aws.amazon.com/pt/dynamodb/" target="_blank">DynamoDB</a> 
                    and <a href="https://redis.com/" target="_blank">Redis</a> are popular options for developers 
                    looking to work with key-value databases.</li>
                    <li>A <strong>document-based</strong> (also called document-oriented) database consists of data stored in hierarchical 
                    structures. Some supported document formats include JSON, BSON, XML, and YAML. The document-based 
                    model is considered an extension of the key-value database and provides querying capabilities not 
                    solely based on unique keys. Documents are considered very flexible and can evolve to fit an 
                    application’s needs. They can even model relationships!
                    <a href="https://www.mongodb.com/?utm_campaign=academia_partners&utm_source=codecademy&utm_medium=referral" target="_blank">MongoDB</a> is a popular option for developers looking to work with a document database.</li>
                    <li>A <strong>graph database</strong> stores data using a graph structure. In a graph structure, data is stored in 
                    individual nodes (also called vertices) and establishes relationships via edges (also called 
                    links or lines). The advantage of the relationships built using a graph database as opposed to 
                    a relational database is that they are much simpler to set up, manage, and query. For example, 
                    let’s say we wanted to build a recommendation engine for our e-commerce store. We could establish
                    relationships between similar items our customers searched for to create recommendations.
                    <a href="https://neo4j.com/" target="_blank">Neo4j</a> is a popular option for developers looking to work with a graph database.</li>
                    <li>A <strong>column-oriented</strong> NoSQL database stores data similar to a relational database. However, 
                    instead of storing data as rows, it is stored as columns. Column-oriented databases aim to 
                    provide faster read speeds by being able to quickly aggregate data for a specific column. 
                    Amazon’s <a href="https://aws.amazon.com/redshift/" target="_blank">Redshift</a> is a popular 
                    option for developers looking to work with a column-oriented database.</li>
                </ul>
                <p class="center"><strong>Example:</strong></p>
                <button id="showCode48" onclick="showCode('displayCode48', 'showCode48')">Display</button>
                <div id="displayCode48">
                    <button onclick="closeCode('displayCode48', 'showCode48')">Close</button>
                    <ul>
                    </ul>
                </div>
            </ul>
        </div>
    </body>
</html>
