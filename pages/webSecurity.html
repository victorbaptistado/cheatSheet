<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="../component/button.js" defer></script>
        <title>WebSecurity</title>
        <h1>WebSecurity</h1>
    </header>
    <body>
        <div class="styleGuide">
            <h2>WebSecurity</h2>
            <ul>
                <li><strong>OWASP (Open Web Application Security Project)</strong> is a respected authority 
                in the field of web security.
                OWASP Top Ten threats can be used as a guide for a webapp security - see it
                <a href="https://owasp.org/www-project-top-ten" target="_blank">here.</a></li>
                <li><strong>Security Principles: </strong>A good rule of thumb for web security, and cybersecurity in general, is something called the
                CIA triad (no, not the US federal agency). CIA stands for Confidentiality, Integrity, and 
                Availability.</li>
                <ul>
                    <li>Confidentiality refers to protecting private information from eyes that shouldn’t have 
                    access to it. It’s the need to enforce access - who can see this, and who shouldn’t? Examples 
                    of enforcing confidentiality include implementing robust user authentication and encryption of 
                    important user data.</li>
                    <li>Integrity refers to data integrity here. We need security controls that protect data from 
                    being changed or deleted, and that the damage can be reversed if done accidentally. Some 
                    techniques related to integrity are database security, keeping backups and using cryptography 
                    to check for changes.</li>
                    <li>Availability refers to data being consistently, reliably available to those authorized. For 
                    example, social media websites ensure that even with high traffic or when a server is 
                    compromised, information gets to a user’s screen. This is accomplished through constant 
                    maintenance of hardware and software, monitoring servers and networks, and having a plan for 
                    any disasters.</li>
                </ul>
            </ul>
            <hr/>
            <h3>Data Security</h3>
            <ul>
                <li></strong>Transport Layer Security(TLS): </strong>
                is a protocol for establishing secure connections between computers. TLS’s largest 
                claim to fame is that it powers HTTPS, the protocol that lets us browse the web securely.
                As suggested by its name, TLS provides security for data that is sent through transport 
                layer protocols. It does this by creating a secure connection (often conceptualized as 
                a tunnel) through which data can be transmitted to its destination. You can think of 
                TLS as a wrapper for transport layer protocols. TLS makes use of other algorithms and 
                protocols to handle things like encryption and key exchange. However, TLS is not itself 
                an encryption algorithm.
                TLS uses public-key certificates in order to make sure that servers (and sometimes 
                clients) are who they say they are. These certificates are created using the ability 
                of asymmetric cryptography to digitally sign data, verifying its authenticity and 
                provenance.</li>
                <ul>
                    <li><strong>Secure Sockets Layer (SSL)</strong> is the predecessor of TLS. Like TLS, it is a protocol 
                    meant to establish secure communications between computers. The primary difference 
                    between SSL and TLS is that SSL has a history of serious security vulnerabilities, 
                    with the final version being deprecated in 2015.
                    Both SSL and TLS use the same kind of certificate, and TLS was originally created 
                    to replace SSL. Because SSL was around first, it’s still common to refer to 
                    ‘SSL/TLS certificates’ as just ‘SSL certificates’. For the most part, whenever 
                    you hear someone talk about SSL, you can probably assume they’re actually talking 
                    about TLS.</li>
                </ul>
                <li><strong>Role-Based Access Control (RBAC) </strong>is a way of managing permissions using roles.
                As the name suggests, roles are a core part of Role-Based Access Control. A role serves 
                as an layer between permissions and users; rather than permissions being granted 
                directly to users, permissions are granted to roles, and then users are assigned roles 
                as appropriate.</li>
            </ul>
            <p class="center"><strong>Example:</strong></p>
            <button id="showCode67" onclick="showCode('displayCode67', 'showCode67')">Display</button>
            <div id="displayCode67">
                <button onclick="closeCode('displayCode67', 'showCode67')">Close</button>
                <ul>
                    <li>employee</li>
                    <ul>
                        <li>Time-Tracking Software (Personal Access)</li>
                        <li>Payroll Software (Personal Access)</li>
                    </ul>
                    <li>mechanic</li>
                    <ul>
                        <li>Work Orders (View/Edit)</li>
                    </ul>
                    <li>cashier</li>
                    <ul>
                        <li>Point Of Sale Terminal Access</li>
                        <li>Inventory Database (Read)</li>
                        <li>Work Orders (Read)</li>
                    </ul>
                    <li>inventory_manager</li>
                    <ul>
                        <li>Inventory Database (Read/Write)</li>
                        <li>Supply Orders (View/Create)</li>
                    </ul>
                    <li>hr</li>
                        <li>Time-Tracking Software (Administrative)</li>
                    <li>payroll</li>
                    <ul>
                        <li>Payroll Software (Administrative)</li>
                    </ul>
                    <li>billing</li>
                    <ul>
                        <li>Invoice Software (Create/Pay)</li>
                        <li>Supply Orders (View)</li>
                    </ul>
                    <li>it</li>
                    <ul>
                        <li>Administrative Computer Access</li>
                    </ul>
                </ul>
            </div>
            <hr/>
            <h3>Common Attacks on Web Applications</h3>
            <ul>
                <li><strong>Cross-Site Scripting (XSS)</strong> is a common web application vulnerability 
                that occurs when a web application renders unsanitized input to the front end of an application. 
                An attacker takes advantage of this vulnerability by injecting malicious code, generally in the form of 
                JavaScript, through the browser.
                XSS is preventable with <strong>input sanitization</strong> and <strong>application-level firewalls</strong>.
                Prevention Cheatsheet 
                <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html" target="_blank">here</a>.
                <ul>
                    <strong>Sanitization</strong> is the process of removing/replacing problematic characters with safe 
                    versions. Depending on the backend language, there may or may not be built-in functions to aid in this 
                    process. However, if these functions do not exist, we can generally succeed 
                    in preventing XSS attacks by removing characters such as <, >, ", =, and potentially dangerous keywords.
                    Rather than remove characters, we can also replace them with HTML-encoded versions of the characters. 
                    This allows us to retain the characters, but remove their capacity to affect the page’s HTML.
                    For example, the < character would be converted to the “<” string. The browser will render this string 
                    as the “<” character, but it will not interpret it as actual HTML, preventing the attack.
                    It is important to note, however, that depending on how the data is used, this type of escaping may 
                    not be enough. It’s important to consider all potential avenues for an attack.
                    There are also JavaScript packages like sanitize-html that help sanitizer user inputs. Here are some
                    types of XSS attacks:</li>
                    <ul>
                        <li><strong>Stored XSS (server and/or database)</strong> <a href="https://owasp.org/www-community/attacks/xss/#stored-xss-attacks" target="_blank">here</a>.</li>
                        <li><strong>Reflected XSS (server and/or database)</strong> <a href="https://owasp.org/www-community/attacks/xss/#reflected-xss-attacks" target="_blank">here</a>.</li>
                        <li><strong>DOM-based Atacks (client side)</strong> <a href="https://owasp.org/www-community/attacks/DOM_Based_XSS" target="_blank">here</a>.</li>
                    </ul>
                    <li>Video protecting against <strong>XSS attacks</strong> <a href="https://www.youtube.com/watch?v=JHOmNd2218g" target="_blank">here</a>.</li>
                    <li>Video Acme Bank pproctecting against <strong>Various attacks</strong> 
                    <a href="https://www.youtube.com/watch?v=d0pWvLyngHM" target="_blank">here</a>.</li>
                    <li><strong>Securing Cookies and Headers: </strong></li>
                    <ul>
                        <li><strong>Cookies</strong> can be used to steal user’s data. An express server that uses 
                        express-session to store cookies has the properties httpOnly and secure to configure 
                        how to store and send cookies. Setting <strong>httpOnly</strong> and <strong>secure</strong>
                        to true helps mitigate the risk of client-side script accessing the protected cookie.
                        In order to set up a cookie in an Express server, you can use the library 
                        express-session to set up a session and configure the application with specific 
                        properties pertaining to cookies:</li>
                        <pre>
                            <code>
                            app.use(
                            session({
                                secret: "my-secret",
                                resave: true,
                                saveUninitialized: true,
                                cookie: {
                                httpOnly: true,
                                secure: true
                                },
                            })
                            );
                            </code>
                        </pre>
                        <li><strong>Setting Security Headers: </strong>
                        Moreover, we can include the helmet package to edit HTTP headers. Helmet.js is a 
                        collection of 15 Node modules that interface with Express. Each module provides 
                        configuration options for securing different HTTP headers. One of them being the 
                        contentSecurityPolicy which is an added layer of security that helps to detect and 
                        mitigate certain types of attacks. Fortunately, by just including this package in 
                        your express app, 11 of these modules (including the content security policy module) 
                        will be configured automatically. You can require helmet 
                        using: <i><strong>const helmet = require('helmet');</strong></i>
                        You can use helmet by adding the following line 
                        of code:</li>
                        <pre>
                            <code>
                            app.use(helmet());
                            </code>
                        </pre>
                    </ul>
                    <li><strong>Data Validation and Sanitization: </strong>
                    In the <strong>Reflected</strong> and <strong>Stored XSS Attacks</strong>, an attacker can inject malicious 
                    code into the server and/or database using a form.
                    When we validate data we ensure that the user is not submitting information that doesn’t 
                    fit a certain format. Moreover, we can use sanitization in order to reformat data so no 
                    malicious code is sent.
                    In other words, <strong>validation</strong> checks if the input meets a set of criteria (such as a string 
                    contains no standalone single quotation marks), whereas <strong>sanitization</strong> modifies the input 
                    to ensure that it is valid (such as removing single quotes).
                    There are many packages that help validate user data, and one common package is 
                    express-validator - recomended for express applications.
                    <strong>Documentation</strong> <a href="https://express-validator.github.io/docs/validation-chain-api/" target="_blank">here</a>.
                    List of express-validor's method <strong>validations</strong> 
                    <a href="https://github.com/validatorjs/validator.js" target="_blank">here</a>.</li>
                    <p class="center"><strong>Example:</strong></p>
                    <button id="showCode69" onclick="showCode('displayCode69', 'showCode69')">Display</button>
                    <div id="displayCode69">
                        <button onclick="closeCode('displayCode69', 'showCode69')">Close</button>
                        <li>With <strong>express-validator</strong>, we can verify if a string matches a certain format by importing 
                        certain functions such as check:
                        <i>const { check } = require("express-validator");</i>
                        Once the function is imported, it can be used as a middleware within our endpoints, 
                        to validate any input that’s submitted within objects attached to req (such as data 
                        sent in a form through req.body):</li>
                        <ul>
                            <pre>
                                <code>
                        app.post("/login", [
                            check('email').isEmail(),
                        ], (req, res) => {});
                                </code>
                            </pre>
                            <li>In the example above, the email field is sent through a login form and retrieved from 
                            req.body. Notice how we’re using an array since we can pass in multiple check‘s for input 
                            data.
                            If the input data is valid, then the rest of the request will be executed and we know 
                            that the data passed in is safe and properly formatted.</li>
                        </ul>
                    </div>
                    <li><strong>DOM-Based Precautions: </strong>
                    Ideally, one could take a step further and <strong>avoid rendering user input</strong>, 
                    especially if it affects DOM elements such as the document.url, document.location, or document.referrer.
                    Lastly, one should <strong>validate and sanitize</strong> all user input in order to prevent any data manipulation.
                    </li>
                </ul>
                <li><strong>Cross-Site Request Forgery (CSRF) Attacks</strong></li>
                <ul>
                    <li>Cross-Site Request Forgery (CSRF) is a common class of vulnerability that tricks a user into submitting a web request on behalf of an attacker.
                    <strong>More info</strong> <a href="https://owasp.org/www-community/attacks/csrf" target="_blank">here</a>.</li>
                    <li><strong>Preventing: </strong>
                    One of the simplest ways to prevent these attacks is to add a <strong>CSRF token</strong>. This token is 
                    a unique value that is added to each request. This value is dynamically generated by the 
                    server and used to verify all requests. This token is kept strictly with the form the 
                    user is currently on if they were making the legitimate request, so the attacker does 
                    not have access to it, and cannot get the user to complete the same request without the 
                    token. Since this value is unique for every request and constantly changing, it is nearly 
                    impossible for an attacker to pre-create the URLs/requests for an attack AND bypass 
                    the token check.
                    While a CSRF token can prevent many malicious requests, it can still fail. If an application is vulnerable to Cross-Site Scripting (XSS) attack, a hacker could use their XSS attack to extract this token!
                    As an extra layer of security, we can ask users to re-authenticate by manually enter 
                    additional information prior to a critical request. For example, prior to changing a 
                    username, email, or password, we may want the user to enter their current password. 
                    By ensuring the request has the correct password, we can ensure that an attacker isn’t 
                    able to easily compromise a user, even with XSS.
                    </li>
                </ul>
                <li><strong>SQL Injection</strong></li>
                <ul>
                    <li>When you log in to Codecademy, you provide a username and password which are used 
                    to authenticate you. When you provide these 
                    credentials, the Codecademy server will take your input and compare it against user 
                    data inside a database.
                    That step of checking the input against the database can be abused by attackers. 
                    Through a cleverly and carefully crafted input an attacker can inject code directly 
                    into the database query, getting precious data.
                    A hacker can use their knowledge of the SQL language to cleverly construct text 
                    inputs that modify the backend SQL query to their liking. They can force the 
                    application to output private data or respond in ways that provide intel.
                    Here are some types:</li>
                    <ul>
                        <li><strong>Union-Based Injections</strong></li>
                        <li><strong>Error-Based Injections</strong></li>
                        <li><strong>Boolean-Based Injections</strong></li>
                        <li><strong>Time-Based Injections</strong></li>
                        <li><strong>Out-of-Band SQL Injections</strong></li>
                    </ul>
                    <li><strong>Prevention: </strong>
                    There are two main methods for preventing injection attacks: sanitization and prepared statements.
                    <strong>Video Implementation</strong>
                    <a href="https://www.youtube.com/watch?v=SwBz06hM_XY&embeds_euri=https%3A%2F%2Fwww.codecademy.com%2F&embeds_origin=https%3A%2F%2Fwww.codecademy.com&source_ve_path=MjM4NTE&feature=emb_title" target="_blank">here</a>.</li>
                    <ul>
                        <li><strong>Sanitization: </strong>When it comes to SQL injections, we would want to escape 
                        dangerous characters such as: <i>' ; \--</i>
                        While this does provide a layer of protection, this method isn’t perfect. If 
                        a user finds a way to bypass your sanitization process, they can easily inject 
                        data into your system. 
                        Additionally, depending on your query, removing certain characters may have no 
                        effect! Therefore, this shouldn’t be your only defense mechanism.
                        <strong>validator.js</strong> is a library of string validators and sanitizers 
                        that can be used server-side with Node.js. validator.js can be used to validate 
                        forms and sanitize inputs before using a form value in the application code
                        (that's different from express-validator, which is sanitization for express
                        framework). <strong>A list of all validators methods</strong> <a href="https://www.npmjs.com/package/validator" target="_blank">here</a>.</li>
                        <pre>
                            <code>
                const validator = require('validator');

                app.post('/submit', 
                (req, res) => {
                    console.log( validator.isEmail(req.body.email)); 
                })
                            </code>
                        </pre>
                        <li><strong>Prepared Statements:</strong>
                        Arguably, the best technique to protect against SQL injections
                        Writing prepared statements (also known as parameterized queries) in backend code 
                        is a common, reliable, and secure solution against SQL injections. 
                        Prepared statements are nearly foolproof.
                        Prepared statements are predefined SQL queries that take user
                        input and place them into placeholders using array syntax.</li>
                    </ul>   
                    <p class="center"><strong>Example:</strong></p>
                    <button id="showCode70" onclick="showCode('displayCode70', 'showCode70')">Display</button>
                    <div id="displayCode70">
                        <button onclick="closeCode('displayCode70', 'showCode70')">Close</button>
                        <li><strong>How does it work? </strong>We provide the database the query we want 
                        to execute in advance.
                        First, a SQL query template is sent to the database. Certain values, called 
                        parameters, are left unspecified. For example, user input.
                        The database processes the query and performs optimizations.
                        Values are bound to the parameters and the SQL query is executed.
                        Then we pass in the parameters/user input. Any input, regardless of whether the 
                        content has SQL syntax, is then treated only as a parameter and will not be treated
                        as SQL code. In addition to providing added security, prepared 
                        statements also make queries far more efficient.</li>
                        <li>Consider this insecure SQLite database query that directly constructs the query 
                        string from user input:</li>
                        <pre>
                            <code>
            db.get(`SELECT * FROM Employee  WHERE FirstName = ${req.body.firstName} 
                AND LastName =  ${req.body.lastName}`, (error, results) => {
                    ...
            });
                            </code>
                        </pre>
                        <li>The query can be reconstructed to use the following <strong>array syntax</strong>, where the 
                        first element replaces the first question mark, and the second element replaces 
                        the second question mark.
                        This minimal change ensures that the input strings are properly escaped and 
                        special characters are removed, preventing SQL injection attacks.</li>
                        <pre>
                            <code>
            db.all("SELECT * FROM Employee  WHERE FirstName = ? AND LastName = ? ", 
                [req.body.lastName, req.body.firstName], 
                (error, results) => {
                ...
            });
                            </code>
                        </pre>
                        <li>Another way to implement prepared statements is to use <strong>named placeholders</strong>. 
                        Instead of using an array, we use an <strong>object to map</strong> the parameters to the query 
                        variables. Consider the following prepared statement using placeholders:</li>
                        <pre>
                            <code>
            db.all("SELECT * FROM Employee  WHERE FirstName = ? AND LastName = ? ", 
                [req.body.lastName, req.body.firstName], 
                (error, results) => {
                ...
            });
                            </code>
                        </pre>
                        <li>The query can be reconstructed to use named placeholders by replacing the <i>?</i> with 
                        a variable beginning with the <i>$</i> character, and passing an object that maps to the
                        named placeholder value. This minimal change makes the code more readable for complicated queries.</li>
                        <pre>
                            <code>
            db.all("SELECT * FROM Employee  WHERE FirstName = $firstName 
            AND LastName = $lastName ", 
                {
                    $firstName: req.body.firstName,
                    $lastName: req.body.lastName
                },
                (error, results) => {
                ...
            });
                            </code>
                        </pre>
                    </div>
                </ul>
            </ul>
            <hr/>
            <h3>Defensive Coding In Javascript</h3>
            <ul>
                <li><strong>Dangerous Code</strong></li>   
                <ul> 
                    <li><strong>The eval Function </strong>
                    in JavaScript takes a string as an argument and executes it as Javascript source code. 
                    The functions, <i>setInterval()</i>, <i>setTimeout()</i>, and new <i>Function()</i> use <i>eval()</i> 
                    in their implementations, and should be used with the same caution.
                    We might be able to mitigate this risk with npm packages like 
                    <a href="https://github.com/hacksparrow/safe-eval" target="_blank">safe-eval</a> and 
                    <a href="https://www.npmjs.com/package/expression-eval" target="_blank">expression-eval</a>. 
                    Both allow us to limit which methods and properties are available to eval(). 
                    Best practices with eval are: Avoid using it altogether!
                    If you must use it, use a safer version, and only allow trusted, non-user input.</li>
                    <li><strong>The exec method </strong> takes a string as an argument 
                    and runs it as a shell command, enabling shell syntax within JavaScript. The danger is 
                    that unrestricted commands can access, modify, and delete files.
                    The <strong><i>execFile()</i></strong> method is an alternative that works similarly 
                    to <strong><i>exec()</i></strong> but requires 
                    separation of the commands and its arguments. This prevents piped commands and path 
                    variable access. This separation ensures that an attacker cannot inject their malicious 
                    commands. Whereas exec will allow for additional unintended commands in the input,
                    execFile will detect an error.</li>
                    <li><strong>fs Module</strong>
                    The file system, or fs, module in Node.js enables file system operations. 
                    It gives us access to methods like: <i>chmod()</i> to change file permissions,
                    <i>mkdir()</i> to create directories, <i>rmdir()</i> to delete directories and many more.
                    The fs module coupled with improperly sanitized user input gives attackers access to our 
                    entire file system and exposes it to path traversal and file inclusion vulnerabilities.
                    To mitigate the risk, we can tweak our code to restrict traversal scope to a directory 
                    of our choice. We use the <i>join()</i> method of the path method to combine our desired directory with 
                    the user-provided file name. Hiding the directory the server is operating on makes 
                    it tougher to reach valuable information.</li>
                    <pre>
                        <code>
                const user_input = "example.txt"
                const root_directory = process.cwd();    // Hard-code path to restrict scope
                const filePath = path.join(root_directory , fileName);
                fs.unlinkSync(filePath);
                        </code>
                    </pre>
                    <li><strong>Regular Expressions</strong>
                    are used in almost every single programming language to validate whether user input 
                    adheres to an expected condition. Attackers can make use of insecure regex expressions 
                    to trigger a <a href="https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS" target="_blank">Regular expression Denial of Service (ReDoS)</a>.
                    The <strong>RegEx</strong> engine can take a large amount of time on poorly defined Regex expressions. 
                    To prevent this danger, we can use the <strong>validator</strong> npm package. It provides a library of 
                    string validators and sanitizers for things like IP addresses, emails, and phone numbers. 
                    For Regex expression we must write ourselves, we can use tools like the safe-regex npm 
                    package to detect dangerous regular expressions.
                    We encourage you to take a look at some examples in the 
                    <a href="https://www.npmjs.com/package/safe-regex" target="_blank">safe-regex</a> documentation.</li>
                </ul>
                <li><strong>Secure Your Code</strong></li>
                <li><strong>Video Implementation: </strong>
                <a href="https://www.youtube.com/watch?v=MJ-ZzgqCblI" target="_blank">here</a>.</li>
                <ul>
                    <li><strong>Strict Mode: </strong>
                    Let’s learn about some defensive tools. One of them is JavaScript’s strict mode. 
                    Using strict mode throws errors that would otherwise be silent, which can help reveal 
                    vulnerabilities. To invoke strict mode, simply put "use strict"; in single or double
                    quotes on top of your JavaScript file.</li>
                    <li><strong>Static Code Analysis: </strong>
                    Static Code Analysis evaluates a code without executing it. A lint, or linter, is a 
                    static code analysis tool used to improve source code by finding and flagging 
                    programming errors, bugs, and patterns that may compromise security. Some of the
                    most popular JavaScript linters are: ESLint, JSLint, JSHint.
                    </li>
                </ul>
            </ul>
            <hr/>
            <h3>Managing Environment Variables, API keys, AND files in NODE.JS</h3>
            <ul>
                <li>Exposing sensitive developer-only data like credentials and keys remains a common mistake.
                This vulnerability counts as <strong>Sensitive Data Exposure</strong>, one of OWASP’s top ten web application security risks.
                We will introduce how to store sensitive application data securely into environment variables. 
                We will also learn how .gitignore helps you control which files, folders, and secrets we want to 
                display in public code repositories.</li>
                <li><strong>Environment Variables:</strong>
                An environment variable is no different than other variables we use while programming. It is used to store 
                information we want to reference in a program. The only difference is that it’s a key-value pair whose value 
                is set and stored outside a program, usually by the operating system or the production environment. 
                Environment variables can prevent the secret development keys and passwords from getting out. 
                They also reward us with more efficient coding in the long run. 
                Environment variables are not recommended for every situation because they are global variables.
                On a large-scale application, global variables can be hard to keep track of.
                Whether the database is hosted online or locally, it is generally a good idea to keep database credentials 
                in the .env file rather than hard-coding it. This ensures our database is not exposed on accidental pushes 
                to a git repository and allows for quick configuration when distributing or deploying our project on a 
                different environment. While the credentials may differ depending on the database, the following are 
                typically present in each database: <strong>Host IP address, Port, Username, Password</strong>.
                <strong>API keys</strong> also must be kept in .env, since it can be used by others, and the API price
                would go high above. </li>
                <pre>
                    <code>
                    DB_HOST=123.45.678.90
                    DB_USER=root
                    DB_PASS=123456
                    API_KEY=V3rYPubl1cK3y
                    </code>
                </pre>
                <ul>
                    <li>We must initialize them in a file called .env (note the dot in the beginning). We can create 
                    this file by running the command <strong><i>touch .env</i></strong>.
                    Node.js stores all the environment variables into a <strong>global variable</strong> called <strong>process.env</strong>. 
                    We can use a npm package called <strong>dotenv</strong> 
                    (documentation <a href="https://github.com/motdotla/dotenv#readme" target="_blank">here</a>) 
                    to load all our environment variables 
                    from .env to process.env, allowing us to access them in our program - you’d normally have to use 
                    the command npm install dotenv to install the dotenv package. We need to set <strong>.gitignore</strong>
                    so the .env file doesn't upload to a repository.</li>
                </ul>
                <li><strong>Environment Variables vs Config Variables </strong>
                share some similarities; choosing one comes down to the developer’s preference and environment. 
                While a <strong>config.json</strong> file allows us to have a greater variety of data types and complex data structures,
                the data in a <strong>.env</strong> file is generally more intelligible. Moreover, some online hosting platforms 
                natively support environment variables. At the end of the day, they both accomplish the same purpose: keeping your 
                information secure.</li>
                <li><strong>Environment Variables and Project Collaboration: </strong>             
                The best practice when it comes to working as part of a team or shared project is to include 
                a sample .env file in the public repository as a template 
                for the next person. This would usually be named <strong>sample.env</strong> or <strong>example.env</strong>. This file contains 
                the names of all the environment variables we need to run a project but their values are empty.
                Writing <strong>comments</strong> to explain each variable is recommended and it helps to group related variables. 
                Other developers can simply add their credentials and rename this file to .env. Take a look at 
                the example.env file in the workspace.
                It’s also best practice to provide instructions for obtaining someone’s own credentials or API keys 
                in the project <strong>README.md</strong> file. Take a look at the README.md in the workspace for an example.
                Just be careful to NOT add the sample.env file or the README.md to .gitignore.</li>
            </ul>
            <hr/>
            <ul>
                <h3>Remediation and Incident Response</h3>
                <li>In Cybersecurity, the term <strong>incident</strong> is when something bad happens, like a breach or 
                policy violation, that harms or potentially harms the security of a system. While a big 
                part of security is preventing incidents from happening in the first place, the reality 
                is that sooner or later, there’s going to be an incident.
                <strong>NIST (the United States National Institute of Standards and Technology)</strong> 
                runs the Computer Security Research Center (CSRC), whose recommendations and guides are 
                highly respected within the industry. NIST Guide
                <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-61r2.pdf" target="_blank">here</a></li>
                <ul>
                    <li><strong>Remediation: </strong>NIST defines remediation as “The act of mitigating a vulnerability or 
                    a threat”. In simple terms, remediation is simply “the process of fixing a security issue”. 
                    It could be patching a vulnerability in a piece of software, removing malware from 
                    an infected computer, or kicking a malicious attacker out of a network. Not all 
                    remediation comes as the result of an incident; arguably the best remediation happens 
                    before the security issue can evolve into an incident.</li>
                    <li><strong>Incident response: </strong>NIST defines incident response as “The mitigation of violations of security 
                    policies and recommended practices.”, but a simpler definition might be “everything 
                    that needs to happen to investigate and recover from an incident”.
                    Incident response begins before an incident even occurs, with preparations to ensure 
                    that an organization is able to respond quickly when an incident does occur. These 
                    preparations can include training, ensuring access to tools, and creating incident 
                    response plans that contain details about what to do when an incident happens.
                    <strong>Incident Response Playbook</strong> contains procedures outlining what needs 
                    to happen to respond to an incident. These playbooks contain information on what 
                    constitutes an incident, what procedures should be enacted and by who, who needs to 
                    be contacted, etc...</li>
                </ul>
            </ul>
        </div>
    </body>
</html>