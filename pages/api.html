<!DOCTYPE html>
<html>
    <header>
        <link href="/resources/css/index.css" type="text/css" rel="stylesheet" >
        <script src="../component/button.js" defer></script>
        <title>API</title>
        <h1>API</h1>
    </header>
    <body>
        <div class="styleGuide">
            <h2>API websites</h2>
            <ul>
                <li><a href="https://rapidapi.com/hub" target="_blank">Rapid-API</a>.</li>
                <li><a href="https://api-ninjas.com/" target="_blank">API-Ninjas</a>.</li>
            </ul>
        </div>
        <div class="styleGuide">
            <section>
                <h2>API</h2>
                <ul>
                    <li><strong>API (Application Programming Interface)</strong> is a software tool that makes it easier for developers 
                    to interact with another application to use some of that application’s functionality.
                    With web APIs, we have a tool that we can use to access the functionality and data of 
                    another application. An <u>API is not a server</u>, although it can be stored in one.
                    An API is usually a way to communicate with a server, to extract and manipulate data.
                    There are two main types of APIs: browser and third-party. <strong>Browser APIs</strong> require specific 
                    syntax and permissions. <strong>Third-party APIs</strong> have their own rules and requirements set by the 
                    organizations that maintain them.</li>
                    <li>When making a request to API, we might have to supply more details about what 
                    information we want. >If we get a successful response, we still have to decide how 
                    to consume the response data.</li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API" target="_blank" style="cursor: pointer;">List of API's</a></li></li>
                </ul>
            </section>
            <hr/>
            <section>
                <h2>Synchronous & Asynchronous</h2>
                <ul>
                    <li><strong>Synchronous</strong> code executes in sequential order — it starts with the code at the 
                    top of the file and executes line by line until it gets to the end of the file. 
                    This type of behavior is known as blocking (or blocking code) since each line of code 
                    cannot execute until the previous line finishes.</li>
                    <li><strong>Asynchronous</strong> code can be executed in parallel to other code that is already running. 
                    Without the need to wait for other code to finish before executing, our apps can save time 
                    and be more efficient. This type of behavior is considered non-blocking.</li>
                    <li><strong>Thread</strong> is a resource that a computer provides an app
                    to do a task.The ability to execute asynchronous code depends on the number of threads 
                    that an app has access to. The more threads we have, the more tasks we can run concurrently.
                    JavaScript is a single-threaded language. but we can emulate concurrency 
                    with the event loop. Code will always execute synchronously, but asynchronous 
                    code can be pushed to web APIs and directed back into the stack via the event
                    queue and event loop.</li>
                    <pre>
                        <code>
                            Thread 1: preheat oven
                            Thread 2: prepare ingredients -> bake-cake
                        </code>
                    </pre>
                </ul>
            </section>
            <hr/>
            <section>
                <h2>Promises</h2>
                <p>Promises are objects that represent the eventual outcome of an asynchronous operation. 
                A Promise object can be in one of three states:</p>
                <li><strong>Pending:</strong> The initial state— the operation has not completed yet.</li>
                <li><strong>Fulfilled:</strong> The operation has completed successfully and the promise now has a resolved value. For example, a request’s promise might resolve with a JSON object as its value.</li>
                <li><strong>Rejected:</strong> The operation has failed and the promise has a reason for the failure. This reason is usually an Error of some kind.</li>
                <li><strong>Settled:</strong> The outcome of a promisse, either fulfilled or rejected.</li>
                <p class="center">How to make a <strong>promise?</strong></p>
                <button id="showCode4" onclick="showCode('displayCode4', 'showCode4')">Display</button>
                <div id="displayCode4">
                    <button onclick="closeCode('displayCode4', 'showCode4')">Close</button>
                    <pre>
                        <code>
                            const executorFunction = (resolve, reject) => {
                                if (someCondition) {
                                    resolve('I resolved!');
                                } else {
                                    reject('I rejected!'); 
                                }
                            }
                            const myFirstPromise = new Promise(executorFunction);
                        </code>
                    </pre>
                </div>
                <ul>
                    <li><strong>.then()</strong> is invoked on a “successful” promise, or a promise that resolved, passing in a success handler callback function. .then() method allows us to say, “I have a promise, when it settles, then here’s what I want to happen…”. then() always returns a promise. </li>
                    <li><strong>.catch()</strong> accomplishes the same thing as .then() with only a failure handler. It's used as output for failure promises, making the code cleaner (instead of using .then).</li>
                </ul>
                <p class="center">How to use <strong>.then?</strong></p>
                <button id="showCode5" onclick="showCode('displayCode5', 'showCode5')">Display</button>
                <div id="displayCode5">
                    <button onclick="closeCode('displayCode5', 'showCode5')">Close</button>
                    <p>With only .then:</p>
                    <pre>
                        <code>
                            let prom = new Promise((resolve, reject) => {
                                let num = Math.random();
                                if (num < .5 ){
                                resolve('Yay!');
                                } else {
                                reject('Ohhh noooo!');
                                }
                            });
                            
                            const handleSuccess = (resolvedValue) => {
                                console.log(resolvedValue);
                            };
                            
                            const handleFailure = (rejectionReason) => {
                                console.log(rejectionReason);
                            };
                            
                            prom.then(handleSuccess, handleFailure);
                        </code>
                    </pre>
                    <p>With .catch chained to .then for cleaner code:</p>
                    <pre>
                        <code>
                            prom.then((resolvedValue) => {
                                console.log(resolvedValue);
                            })
                            .catch((rejectionReason) => {
                                console.log(rejectionReason);
                            });
                        </code>
                    </pre>
                </div>      
                <ul>
                    <li><strong>Composition</strong> is the process of chaining promises together. Multiple operations which depend on each other to execute or that must be executed in a certain order. We might make one request to a database and use the data returned to us to make another request and so on...</li>
                    <li><strong>Promise.all()</strong> agroups many promisses in any order into a single promise. Promise.all() accepts an array of promises as its argument and returns a single promise. The Promise.all() method returns a Promise, if Promise resolves, it is fulfilled as an array.</li>
                </ul>
                <p class="center">Example of <strong>Composition</strong> & <strong>Promise.all():</strong></p>
                <button id="showCode6" onclick="showCode('displayCode6', 'showCode6')">Display</button>
                <div id="displayCode6">
                    <button onclick="closeCode('displayCode6', 'showCode6')">Close</button>
                    <p>Composing checkInventory -> processPayment -> shipOrder</p>
                    <pre>
                        <code>
                            checkInventory(order).then((resolvedValueArray) => {
                                return processPayment(resolvedValueArray);
                            })
                            .then((resolvedValueArray) => {
                                return shipOrder(resolvedValueArray);
                            })
                            .then((successMessage) => {
                                console.log(successMessage);
                            })
                            .catch((errorMessage) => {
                                console.log(errorMessage);
                            });
                        </code>
                    </pre>
                    <p>Example of Promise.all():</p>
                    <pre>
                        <code>
                            let myPromises = Promise.all([returnsPromOne(), returnsPromTwo(), returnsPromThree()]); 
                            myPromises
                            .then((arrayOfValues) => {
                                console.log(arrayOfValues);
                            })
                            .catch((rejectionReason) => {
                                console.log(rejectionReason);
                            });
                        </code>
                    </pre>          
                </div>
            </section>
            <hr/>
            <section>
                <h2>Async... Await syntax</h2>
                <ul>
                    <li>Async function has the same use as Promise, but with a clearer code.
                    The async...await version more closely resembles synchronous code, which helps developers 
                    maintain and debug their code. 
                    Async functions always return a promise. This means we can use traditional promise syntax, 
                    like .then() and .catch with our async functions.</li>
                    <li><strong>async</strong> keyword is used to write functions that handle asynchronous actions.</li>
                    <li><strong>await</strong> is an operator: it waits and returns the resolved value of a promise.</li>
                </ul>
                <p class="center">Promise VS <strong>Async... await</strong></p>
                <button id="showCode8" onclick="showCode('displayCode8', 'showCode8')">Display</button>
                <div id="displayCode8">
                    <button onclick="closeCode('displayCode8', 'showCode8')">Close</button>
                    <p>Promise:</p>
                    <pre>
                        <code>
                            function nativePromiseVersion() {
                                returnsFirstPromise()
                                .then((firstValue) => {
                                    console.log(firstValue);
                                    return returnsSecondPromise(firstValue);
                                })
                                .then((secondValue) => {
                                    console.log(secondValue);
                                });
                            }
                        </code>
                    </pre>
                    <p>Async... await:</p>
                    <pre>
                        <code>
                            async function asyncAwaitVersion() {
                                let firstValue = await returnsFirstPromise();
                                console.log(firstValue);
                                let secondValue = await returnsSecondPromise(firstValue);
                                console.log(secondValue);
                            }
                        </code>
                    </pre>
                    <p>The true beauty of async...await is when we have a series of asynchronous actions 
                    which depend on one another. For example, we may make a network request based on a query 
                    to a database. In that case, we would need to wait to make the network request until 
                    we had the results from the database.</p>
                </div>
                <ul>
                    <li><strong>try...catch</strong> statements are used for error handling. By using this syntax, 
                    not only are we able to handle errors in the same way we do with synchronous code, 
                    but we can also catch both synchronous and asynchronous errors 
                    (therefore without breaking the code).</li>
                </ul>
                <p class="center">How to use <strong>try... catch?</strong></p>
                <button id="showCode9" onclick="showCode('displayCode9', 'showCode9')">Display</button>
                <div id="displayCode9">
                    <button onclick="closeCode('displayCode9', 'showCode9')">Close</button>
                    <pre>
                        <code>
                            async function usingTryCatch() {
                                try {
                                let resolveValue = await asyncFunction('thing that will fail');
                                let secondValue = await secondAsyncFunction(resolveValue);
                                } catch (err) {
                                // Catches any errors in the try block
                                console.log(err);
                                }
                            }
                                
                            usingTryCatch();
                        </code>
                    </pre>
                </div>
                <ul>
                    <li><strong>Await Promise.all()</strong> can be used in await syntax.</li>
                </ul>
                <p class="center">How to make a await <strong>Promise.All?</strong></p>
                <button type="button" id="showCode10" onclick="showCode('displayCode10', 'showCode10')">Display</button>
                <div id="displayCode10">
                    <button onclick="closeCode('displayCode10', 'showCode10')">Close</button>
                    <pre>
                        <code>
                            async function asyncPromAll() {
                                const resultArray = await Promise.all([asyncTask1(), asyncTask2(), 
                                asyncTask3(), asyncTask4()]);
                                for (let i = 0; i < resultArray.length; i++){
                                console.log(resultArray[i]); 
                                }
                            }
                        </code>
                    </pre>
                </div>
            </section>
            <hr/>
            <section>
                <h2>HTTP Request</h2>
                <ul>
                    <li><strong>HTTP</strong> stands for <strong>Hypertext Transfer Protocol</strong> and is used to structure requests and 
                    responses over the internet. HTTP requires data to be transferred from one point to another over the network.
                    The transfer of resources happens using TCP (Transmission Control Protocol). 
                    In viewing this webpage, TCP manages the channels between your browser and the server 
                    (in this case, codecademy.com). TCP is used to manage many types of internet connections 
                    in which one computer or device wants to send something to another. HTTP is the command language 
                    that the devices on both sides of the connection must follow in order to communicate.
                    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank" style="cursor: pointer;">More Info</a></li>
                    <li><strong>Protocol</strong> is a system of rules that define how data is exchanged within or between computers. 
                    Communications between devices require that the devices agree on the format of the data that is being exchanged. </li>
                </ul>
                <div class="flex">
                    <p>HTTP request analogy</p>
                    <button id="showCode11" class="p-icon--plus" onclick="showCode('displayCode11', 'showCode11')">Display</button>
                </div>
                <div id="displayCode11">
                    <button onclick="closeCode('displayCode11', 'showCode11')">Close</button>
                    <p>It can be tricky to understand how HTTP functions because it’s difficult to examine what your 
                    browser is actually doing. (And perhaps also because we explained it using acronyms that may 
                    be new to you.) Let’s review what we learned by using an analogy that could be more familiar to you.
                    Imagine the internet is a town. You are a client and your address determines where you can be reached. 
                    Businesses in town, such as Codecademy.com, serve requests that are sent to them. The other houses are
                    filled with other clients like you that are making requests and expecting responses from these 
                    businesses in town. This town also has a crazy fast mail service, an army of mail delivery staff that 
                    can travel on trains that move at the speed of light.</p>

                    <p>Suppose you want to read the morning newspaper. In order to retrieve it, you write down what you need in a language called HTTP and ask your local mail delivery staff agent to retrieve it from a specific business. The mail delivery person agrees and builds a railroad track (connection) between your house and the business nearly instantly, and rides the train car labeled “TCP” to the address of the business you provided.
                    Upon arriving at the business, she asks the first of several free employees ready to fulfill the request. The employee searches for the page of the newspaper that you requested but cannot find it and communicates that back to the mail delivery person.
                    The mail delivery person returns on the light speed train, ripping up the tracks on the way back, and tells you that there was a problem “404 Not Found.” After you check the spelling of what you had written, you realize that you misspelled the newspaper title. You correct it and provide the corrected title to the mail delivery person.
                    This time the mail delivery person is able to retrieve it from the business. You can now read your newspaper in peace until you decide you want to read the next page, at which point, you would make another request and give it to the mail delivery person.</p>
                </div>
            </section>
            <hr/>
            <h2>REST (REpresentational State Transfer)</h2>
            <p><strong>REST, or REpresentational State Transfer</strong>, is an architectural style for providing standards between 
            computer systems on the web, making it easier for systems to communicate with each other. REST-compliant systems, often called 
            RESTful systems, are characterized by how they are stateless and separate the concerns of client and server.</p>
            <p class="center"><strong>Separation of Client and Server</strong> & <strong>Statelessness</strong></p>
            <button type="button" id="showCode12" onclick="showCode('displayCode12', 'showCode12')">Display</button>
            <div id="displayCode12">
                <button onclick="closeCode('displayCode12', 'showCode12')">Close</button>
                <ul>
                    <li><h3>Separation of Client and Server:</h3> 
                    <p>In the REST architectural style, the implementation of the client and the implementation of the server can be done 
                    independently without each knowing about the other. This means that the code on the client side can be changed at any time without 
                    affecting the operation of the server, and the code on the server side can be changed without affecting the operation of the client.
                    As long as each side knows what format of messages to send to the other, they can be kept modular and separate.
                    Separating the user interface concerns from the data storage concerns, we improve the flexibility of the interface across platforms and improve scalability 
                    by simplifying the server components. Additionally, the separation allows each component the ability to evolve independently.
                    By using a REST interface, different clients hit the same REST endpoints, perform the same actions, and receive the same responses.</p></li>
                    <li><h3>Statelessness</h3>
                    <p>Systems that follow the REST paradigm are stateless, meaning that the server does not need to know anything about what state 
                    the client is in and vice versa. In this way, both the server and the client can understand any message received, even without 
                    seeing previous messages. This constraint of statelessness is enforced through the use of resources, rather than commands. 
                    Resources are the nouns of the Web - they describe any object, document, or thing that you may need to store or send to other services.
                    Because REST systems interact through standard operations on resources, they do not rely on the implementation of interfaces.
                    These constraints help RESTful applications achieve reliability, quick performance, and scalability, as components that can be managed, 
                    updated, and reused without affecting the system as a whole, even during operation of the system.</p></li>
                </ul>
                </div>
                <h3>Making Requests</h3> 
            <p>REST requires that a client make a request to the server in order to retrieve or modify data 
            on the server. A request generally consists of:</p>
            <ul>
                <li><strong>HTTP verb</strong>, which defines what kind of operation to perform</li>
                <li><strong>Header</strong>, which allows the client to pass along information about the request (such as type of content).</li>
                <li><strong>Path</strong> to a resource that the operation should be performed on. Conventionally, the first part of the path should be the plural form of the resource.</li>
                <li><strong>Message</strong>(optional) body containing data</li>
            </ul>
            <p class="center"><strong>Request & Response</strong> examples</p>
            <button type="button" id="showCode13" onclick="showCode('displayCode13', 'showCode13')">Display</button>
            <div id="displayCode13">
                <button onclick="closeCode('displayCode13', 'showCode13')">Close</button>
                <li><strong>Id</strong> is used for GET (specific request), PUT & Delete. 
                It's not necessary for POST, since it creates its own id.</li>
                <br/>
                <p><strong>GET Request</strong> (all data in customers):</p>
                <pre>
                    <code>
                        GET http://fashionboutique.com/customers
                        Accept: application/json
                    </code>
                </pre>
                <pre>
                    <code>
                        // Response
                        Status Code: 200 (OK)
                        Content-type: application/json
                    </code>
                </pre>

                <p><strong>GET Request</strong> (specific customer):</p>
                <pre>
                    <code>
                        GET http://fashionboutique.com/customers/123
                        Accept: application/json
                    </code>
                </pre>  
                <pre>
                    <code>
                        // Response
                        Status Code: 200 (OK)
                        Content-type: application/json
                    </code>
                </pre>   
                <p><strong>POST</strong> Request:</p>
                <pre>
                    <code>
                        POST http://fashionboutique.com/customers
                        Body:
                        {
                        “customer”: {
                            “name” = “Scylla Buss”,
                            “email” = “scylla.buss@codecademy.org”
                        }
                        }
                    </code>
                </pre>
                <pre>
                    <code>
                        // Response
                        201 (CREATED)
                        Content-type: application/json
                    </code>
                </pre>
                <p><strong>PUT</strong> Request:</p>
                <pre>
                    <code>
                        PUT http://fashionboutique.com/customers/123
                        Body:
                        {
                        “customer”: {
                            “name” = “Scylla Buss”,
                            “email” = “scyllabuss1@codecademy.com”
                        }
                        }
                    </code>
                </pre>
                <pre>
                    <code>
                        // Response
                        A possible response header would have Status Code: 200 (OK), 
                        to notify the client that the item with id 123 has been modified.</p>                
                    </code>
                </pre>
                <p><strong>Delete</strong> Request:</p>
                <pre>
                    <code>
                        DELETE http://fashionboutique.com/customers/123
                    </code>
                </pre>
                <pre>
                    <code>
                        The response would have a header 
                        containing Status Code: 204 (NO CONTENT), 
                        notifying the client that the item 
                        with id 123 has been deleted, and nothing in the body.
                    </code>
                </pre>
            </div>
            <hr/>
            <h2>JSON</h2>
            <ul>
                <li><stron>JSON</strong> (JavaScript Object Notation) is a popular, <strong>language-independent</strong>, standard format for storing and exchanging data.</li>
                <li>JSON is heavily used to <strong>facilitate data transfer</strong> in web applications between a client, such as a web browser, and a server.</li>
                <li><strong>.parse()</strong> is a built-in JSON class method that takes a JSON string as a parameter and returns a JavaScript object.</li>
                <li><strong>.stringify()</strong> is a built-in JSON class method that transform a JavaScript object to a JSON string.</li>
            </ul>
            <p class="center"><strong>JSON</strong> to <strong>JavaScript</strong> & <strong>JavaScript</strong> to <strong>JSON</strong> conversion examples</p>
            <button type="button" id="showCode14" onclick="showCode('displayCode14', 'showCode14')">Display</button>
            <div id="displayCode14">
                <button onclick="closeCode('displayCode14', 'showCode14')">Close</button>
                <pre>
                    <code>
                        const jsonData =
                        {
                            "student": {
                            "name": "Rumaisa Mahoney",
                            "age": 30,
                            "fullTime": true,
                            "languages": [ "JavaScript", "HTML", "CSS" ],
                            "GPA": 3.9,
                            "favoriteSubject": null
                            }
                        }

                        // Converting JSON to JavaScript object

                        const jsObject = JSON.parse(jsonData);
                        console.log(jsObject);

                        
                        // Converting JavaScript object to JSON

                        const jsObject = { book: 'JSON Primer', price: 29.99, inStock: true, rating: null };
                        const jsonData = JSON.stringify(jsObject);
                        console.log(jsonData);
                    </code>
                </pre>
            </div>
            <hr/>
            <h2>Request with FETCH api</h2>
            <ul>
                <li><strong>fetch()</strong> function: creates a request object that contains relevant 
                information that an API needs.</li>
                <li>Sends that request object to the API endpoint provided.</li>
                <li>Returns a promise that ultimately resolves to a response object, which contains the status 
                of the promise with information the API sent back. <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data" target="_blank" style="cursor: pointer;">More Info</a>
            </li>
                <li>To fetch from API, it's common the need of an <strong>API key</strong> & a 
                <strong>query params</strong>.</li>
                <pre>
                    <code>
                    // there are two paramaters on this request, separated by "&".
                    const requestParams = `?api_key=${tmdbKey}&with_genres=${selectedGenre}`;
                    const urlToFetch = `${baseUrl}${endpoint}${requestParams}`;
                    </code>
                </pre>
                </li>
            </ul>
            <p class="center"><strong>Fetch</strong> examples</p>
            <button type="button" id="showCode15" onclick="showCode('displayCode15', 'showCode15')">Display</button>
            <div id="displayCode15">
                <button onclick="closeCode('displayCode15', 'showCode15')">Close</button>
                <p class="center"><strong>GET</strong> with <strong>FETCH</strong> using <strong>async</strong> (easier way).</p>
                <pre>
                    <code>
                        export const getData = async () => {
                            try {
                                const response = await fetch('https://api-to-call.com/endpoint');
                                
                                // handles success
                                if (response.ok) {
                                    const jsonResponse = await response.json();
                                    // Code to execute with jsonResponse
                                }

                                // handles error
                                throw new Error("Request failed!");
                            } catch (error) {
                                console.log(error);
                            }
                        }
                    </code>
                </pre>
                <p class="center"><strong>POST</strong> with <strong>FETCH</strong> using <strong>async</strong> (easier way).</p>
                <pre>
                    <code>
                        export const getData = async () => {
                            try {
                                const response = await fetch('https://api-to-call.com/endpoint', {
                                    method: 'POST',
                                    body: JSON.stringify({id: 200})
                                });
                                
                                // handles success
                                if (response.ok) {
                                    const jsonResponse = await response.json();
                                    // Code to execute with jsonResponse. Return to end function getData and return a value.
                                        e.g. const genres = jsonResponse.genres;
                                                return genres;
                                }

                                // handles error
                                throw new Error("Request failed!");
                            } catch (error) {
                                console.log(error);
                            }
                        }
                    </code>
                </pre>  
                <hr/>
                <p class="center"><strong>GET</strong> with <strong>FETCH</strong></p>
                <pre>
                    <code>
                    // Asynchronous function
                    export const asyncFunction = () => {

                        //sends request
                        fetch("http://api-to-call.com/endpoint").then(response => {

                            //converts response object to JSON 
                            if(response.ok) {
                                return response.json();
                            }

                            //handling error
                            throw new Error('Request failed!');
                            }, networkError => {
                                console.log(networkError.message)

                            //handling success
                            }).then((jsonResponse) => {
                                renderResponse(jsonResponse);  //code to execute
                        });
                    }
                    </code>
                </pre>
                <p class="center"><strong>POST</strong> with <strong>FETCH</strong></p>
                <pre>
                    <code>
                    // Asynchronous function
                    export const asyncFunction = () => {

                        //sends request (fetch takes two arguments: 
                                            endpoint and an object with information 
                                            for the POST request.)

                        fetch("http://api-to-call.com/endpoint", {
                            method: 'POST';
                            body: JSON.stringify({id: '200'})

                        //converts response object to JSON 
                        }).then(response =>
                            if(response.ok) {
                                return response.json();
                            }

                            //handling error
                            throw new Error('Request failed!');
                        }, networkError => {
                            console.log(networkError.message)

                        //handling success
                        }).then((jsonResponse) => {
                            //code to execute with jsonResponse
                        });
                    }
                    </code>
                </pre>    
            </div>
        </div>
        <div class="styleGuide">
            <h2><strong>Connecting Front-End & Back-End</strong></h2>
            <ul>
                <h3>Transfering Data</h3>
                <li>In web applications, the front-end and the back-end communicate via an <strong>HTTP request/response</strong> 
                cycle. Once the server has received the request made by the front-end, it builds a response to 
                send back to the client.</li>
                <li><strong>HTTP request</strong> from the client to the server can be broken down into:</li>
                <ul>
                    <li>A start line that includes an HTTP method, the path for the requested resource, and the HTTP version number.</li>
                    <li>Headers that provide the server with additional information about the sender and the request.</li>
                    <li>A body, if needed. Generally, POST and PUT requests will include a body to send data.</li>
                </ul>
                <li><strong>HTTP response</strong> can also be broken down into at least two parts:</li>
                <ul>
                    <li>A status line that indicates whether or not the request was completed successfully.</li>
                    <li>A series of headers to give more context about the response.</li>
                    <li>Often a response from the server will contain a body, which includes data requested 
                    from the client. Generally, the server will send back the following types of data:</li>
                    <ul>
                        <li>HTML documents</li>
                        <li>Static assets, like stylesheets, JavaScript files, and images</li>
                        <li>Formatted data</li>
                    </ul>
                </ul>
                <hr/>
                <h3>Different Types of Rendering</h3>
                <li><strong>Client-side rendering:</strong> The content of the page is dynamically generated in 
                the browser as the user navigates the app.
                In client-side rendering, the server sends the browser a boilerplate HTML document 
                that includes a reference to a JavaScript file. This JavaScript code is responsible 
                for dynamically generating content in the browser, as the user moves through the 
                site. With client-side rendering, content is generated and rendered as needed; 
                only the requested content will be loaded, at the time it is requested.
                In terms of user experience, the initial page load can be slow, since the JavaScript 
                first has to generate the content for a given view before it is visible and 
                interactable. As the user navigates the app, however, JavaScript code will produce 
                content directly in the browser. Since round-trip calls to the server are not 
                necessary to render additional content, subsequent loads will be much faster. 
                Because of its quick rendering time after the initial load, client-side rendering 
                tends to be preferred for highly interactive web applications.
                Front-End frameworks like React, Vue, and Angular often rely on client-side 
                rendering to deliver Single Page Applications.
                When deciding whether client-side rendering is right for your app, consider the 
                following pros and cons:</li>
                <ul>
                    <li><strong>Pros:</strong> Fast speed after initial page load.</li>
                    <li><strong>Cons:</strong> Poor Search Engine Optimization (SEO) performance with dynamically 
                    generated content. Can lead to poor user experience on slower devices.</li>
                </ul> 
                <li><strong>Server-side rendering:</strong> The server 
                generates the content and sends it to the browser, on-demand.
                Pages are generated and rendered on-demand. Every time the user navigates to a different 
                page on the site, the server builds the web page and sends it to the client. Because the 
                content is ready to be rendered when it arrives in the browser, the time it takes for the 
                page to become viewable is usually quick.
                Before the page is fully interactable, the browser must download and parse the JavaScript. 
                This process can be slow, and largely depends on the amount of JavaScript code, the quality 
                of the network connection, and the user’s device.
                Since static content loads quickly, server-side rendering is ideal for informational sites 
                where there is little interactivity. Implementing server-side rendering for sites that have 
                rich interactions can lead to a poor user experience since more requests to the server need 
                to be made, and JavaScript has to load before the user can engage with the site.
                Consider the following pros and cons before choosing server-side rendering for your next app:</li>
                <ul>
                    <li><strong>Pros: </strong>Visual elements of the page load quickly, since the content is ready 
                    to render before it’s sent to the browser.
                    Better Search Engine Optimization (SEO) performance, since search engines can index static 
                    content immediately.</li>
                    <li><strong>Cons: </strong>Time to interactive 
                    <a href="https://developer.mozilla.org/en-US/docs/Glossary/Time_to_interactive" target="_blank">(TTI)</a> can be slow if the page is 
                    JavaScript-heavy. Speed depends on many factors outside of the developer’s control, 
                    like network connection quality, and the user’s device.</li>
                </ul>
                <li><strong>Hybrid-rendering:</strong></li> Combine 
                client-side and server-side rendering to incorporate the 
                advantages of both. In hybrid-rendering, static content is generated on the server, 
                while dynamic content is generated on the client-side as the user navigates the site. 
                <hr/>
                <h3>RESTful APIs</h3>
                <li><strong>OpenAPI Specification (OAS): </strong> is a standard for describing RESTful APIs. 
                Similar to how create-react-app provides a standard for React projects by generating 
                templates, OAS provides the rules and syntax necessary to describe an API.</li>
                <p class="center"><strong>RESTful endpoints</strong></p>
                <button type="button" id="showCode66" onclick="showCode('displayCode66', 'showCode66')">Display</button>
                <div id="displayCode66">
                    <button onclick="closeCode('displayCode66', 'showCode66')">Close</button>
                    <li><strong>GET: </strong></li>
                    <pre>
                        <code>
                export const getBooks = async () => {
                    const response = await fetch(`${API_ENDPOINT}/books`);
                    const books = await response.json();
                
                    return books;
                };
                        </code>
                    </pre>
                    <li><strong>POST: </strong></li>
                    <pre>
                        <code>
                export const addNewBook = async (newTitle, newStart, newEnd) => { 
                    const response = await fetch(`${API_ENDPOINT}/books`, {
                        method: "POST",
                        body: JSON.stringify({
                            title: newTitle,
                            start: newStart,
                            end: newEnd
                        }),
                        headers: {
                            "Content-Type": "application/json",
                        },
                        });
                        const newBook = await response.json();
                        return newBook;
                };                            
                        </code>
                    </pre>
                    <li><strong>PUT: </strong></li>
                    <pre>
                        <code>
                export const updateBook = async (id, newTitle, newStart, newEnd) => {
                    const response = await fetch(`${API_ENDPOINT}/books/:/${id}`, {
                        method: "PUT",
                        body: JSON.stringify({
                            newTitle,
                            newStart,
                            newEnd
                        }),
                        headers: {
                            "Content-Type": "application/json"
                        },
                    })
                    return response.status;
                }                            
                        </code>
                    </pre>
                    <li><strong>DELETE: </strong></li>
                    <pre>
                        <code>
                export const deleteBook = async (id) => {
                    const response = await fetch(`${API_ENDPOINT}/:${id}`, {
                    method: 'DELETE'
                    });
                    return response.status;
                }
                        </code>
                    </pre>
                </div>
                <li><strong>More info: </strong></li>
                <ul>
                    <li>Front-end back-end API connection <strong>Bookstore</strong>
                    <a href="https://static-assets.codecademy.com/Courses/Connecting-FE-to-BE/creating-rest-api.zip" target="_blank">here</a>.</li>
                    <li>Front-end, Back-end & Database connection <strong>Restaurant</strong> 
                    <a href="https://static-assets.codecademy.com/Courses/Connecting-FE-to-BE/external-api/external-api.zip" target="_blank">here</a>.</li>
                    <li><strong>OpenAPI code generator</strong>: Swagger Codegen, OpenAPI Generator, 
                    and AutoRest.</li>
                </ul>
                <hr/>
                <h2>MVC (Model View Controller)</h2>
                <li>As we design our software we sometimes need to view and organize our system at the big 
                picture level. One popular architectural pattern is the Model View Controller pattern, or MVC.
                The main drawback of MVC is that it can introduce unneeded complexity to an application. 
                Having multiple components and structure may not be necessary for simpler applications. A 
                decent guideline is that if our application requires multiple people for development, 
                having a pattern such as MVC probably would be helpful. This will help team members reason 
                about class intents and where an object might fit into the application.
                Overall, the MVC pattern is ideal for more complex projects in which there are expected to 
                be changes in the way data is represented or presented over the product’s lifetime. The 
                separation of these concerns allows flexibility when making changes to the system.</li>
                <ul>
                    <li><strong>Model</strong> is made up of the data storage, as well as any classes that represent that 
                    data as it moves around the application. Data is often stored outside the application 
                    in a database or files. While the data can be stored in different formats, we often read 
                    data from storage into a representational object. These objects should be extremely 
                    simple and have very little behavior outside of allowing access to their data.</li>
                    <li><strong>View</strong> component is the classes that describe how our application will be presented 
                    to the user — it’s what the users see. These might be our React components or HTML 
                    elements in a web application or XML files in an Android application.</li>
                    <li><strong>Controller</strong> is the brain of our application. The View and the Model do not define 
                    much behavior for our applications, instead, they merely represent presentational and 
                    data objects. The Controller defines the behaviors that our system will accomplish 
                    using the Model and View. The Controller is responsible for receiving events (clicks, 
                    submitted forms, typing) passed in from the View and processing them to make meaningful 
                    responses. The Controller will interact with the Model, making queries or representing 
                    data as appropriate to make these responses happen.</li>
                </ul>
                <li><strong>MVC </strong>expenses project<a href="https://static-assets.codecademy.com/Courses/Connecting-FE-to-BE/mvc/mvc.zip" target="_blank">here</a>.</li>
                <li><strong>MVC </strong>todoList project <a href="https://static-assets.codecademy.com/Courses/Connecting-FE-to-BE/mvc/to-do-list.zip" target="_blank">here</a>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>API Development (with Swagger and OpenAPI)</h2>
            <ul>
                <li>Developing an API by itself is no easy task. Creating an API encompasses a series of steps, each with its 
                own complex processes. This collection of steps is known as the API development lifecycle.
                While there are many frameworks and methodologies for the API lifecycle, there are typically 
                <strong>five chronological stages:</strong></li>
                <ul>
                    <li><strong>Planning and Designing the API:</strong>
                    This stage involves ideating and mapping out the various resources and operations and their 
                    associated use cases before the API is fully implemented in code.
                    Typically business team members (or sometimes even engineers) will begin by mapping out the 
                    capabilities of the API and the data it should expose. This process usually captures the API 
                    audience’s needs and the requirements from various stakeholders.
                    When the API requirements are done being mapped out, engineering teams can then begin laying out the 
                    architecture of the API. Naming conventions, protocols, technology, and much more are debated and finalized.
                    </li>
                </ul>
            </ul>
            <p class="center"><strong>More About</strong></p>
            <button id="showCode57" onclick="showCode('displayCode57', 'showCode57')">Display</button>                   
            <div id="displayCode57">
                <button onclick="closeCode('displayCode57', 'showCode57')">Close</button>  
                <ul>
                    <li>One slip-up can result in endless support requests from end-users and eventually result in 
                    a bad reputation. It’s crucial to plan, plan, and plan even more before actually implementing 
                    an API. This is why API design, typically the first step in the API development lifecycle, is 
                    so important.
                    The design process is not just about the developers who are building the API but also about 
                    understanding the API’s end-user, their needs, and how best the API can meet those needs.
                    Typically, a <strong>well-designed API will have the following characteristics:</strong></li>
                    <ul>
                        <li><strong>Easy to read and work with:</strong> A well-designed API will be easy to work with, and its 
                        resources and associated operations can quickly be memorized by developers who work with it 
                        regularly.</li>
                        <li><strong>Hard to misuse:</strong> Implementing and integrating with a well-designed API will be a 
                        straightforward process and less error-prone. It has informative feedback and doesn’t enforce 
                        strict guidelines on the API’s end-user.</li>
                        <li><strong>Complete and concise:</strong> A well-designed API is a complete API. This means the API exposes 
                        any data that the end-user expects it to expose. Most APIs are completed over a long period of 
                        time – implementing end-user feedback and releasing new versions along the way.</li>
                        <li><strong>Well documented:</strong> Finding any information about endpoints, integrations, and features 
                        should be simple with a well-designed API. The documentation will cover and explain all the 
                        available functionality of the API.</li>
                        <li><strong>Reliable:</strong> An API’s end-user will depend on an API to be available and functioning when 
                        they need it. They also expect functionality to not arbitrarily change without any proper notice.</li>
                    </ul>
                    <li><strong>Collections, Resources, and Their URLs: </strong> 
                    For any resource or collection that represents some data in an API, the base URL should 
                    always be neat, elegant, and, most importantly, intuitive. A long and difficult-to-read base 
                    URL is not just bad to look at but can also provide a more error-prone and challenging 
                    experience for the end-user. Try using <u>nouns for URLs</u>, to keep it clear.
                    Also, <u>mapping HTTP</u> methods to describe the typical CRUD operations of our applications 
                    allows developers to know exactly what they should expect to occur.</li>
                    <li><strong>Responses: </strong>Give Feedback to Help Developers Succeed
                    Providing good feedback to developers on how well they are using an API goes a long way in 
                    improving adoption and retention. Good feedback involves positive validation on correct 
                    implementations and an informative error on incorrect implementations that can help developers 
                    debug and correct how they use the API.
                    For APIs, errors (and relevant error codes) are a great way to provide context when things go 
                    wrong! In general, there are three possible 
                    <a href="https://www.restapitutorial.com/httpstatuscodes.html" target="_blank">error</a> outcomes when using an API:
                    <u>The client application behaved erroneously</u> (client error - 4xx response code);
                    <u>The API behaved erroneously</u> (server error - 5xx response code);
                    <u>The client and API worked</u> (success - 2xx response code);
                    When designing an API, describe these error responses well, but keep them concise and neat. 
                    In addition, use specific response codes to detail errors accordingly in the API. Lastly, provide enough information in the error codes for an 
                    end-user to start work on fixing the cause, and, if there’s more information needed, provide 
                    links to additional documentation.</li>
                    <li><strong>Requests: </strong>Handle complex requests elegantly. We want to make sure that our 
                    data is complete, available, and accounts for relationships between different types of data. In 
                    the interest of performance, we’d only want to surface the relevant data that an end-user needs 
                    and even consider limiting the amount of data they get in the response.
                    We’ve already seen how we can retrieve individual resources (e.g. /photos/1) and a collection 
                    (e.g. /photos), but how can we add more complex behavior to our requests? One way to account for 
                    specific properties and limit responses is to use a query parameter, adding a ? with key-value 
                    pairs that list out what a user needs.                        
                    Let’s take the example of our photo-sharing app. Someone might want to get photos from a specific 
                    location and a specific hashtag. We might also want to limit the number of results to 10 per API 
                    call to prevent server load. If the user wants to find the top 10 photos in Boston with a hashtag 
                    #winter, the call would be:
                    <pre>
                        <code>    
                    GET /photos?location=boston&hashtag=winter&limit=10
                        </code>
                    </pre>
                    Notice how the complexities have now been reduced to a simple association with a query parameter. 
                    These are just some of the ways we could design parameters that strive towards API completion and 
                    help our end developers use our API intuitively.   
                    Also, when in doubt, leave it out. Developing and maintaining APIs is a continuous process, so we 
                    can wait for feedback from our end-users to see how we can improve our API. This way, we account 
                    for the immediate and future needs of the API.</li>
                </ul>
                <hr/>
                <ul>
                    <li><strong>Best Practices in API Documentation</strong></li>
                    <ul>
                        <li><strong>Detailed Error Messages:</strong> Error messages are important because they tell end-users when they’re integrating with an API 
                        incorrectly. Explain error standards and provide solutions on how to overcome them when an end-user 
                        gets an error.</li>
                        <li><strong>A List of All Exposed Resources: </strong>
                        Resources are the core components of an API that end-users will constantly be interacting with. 
                        An API should list all of its exposed resources and understand how end-users may integrate with them.</li>
                        <li><strong>A Terms of Use Agreement: </strong>
                        Terms of use is a legal agreement between the end-user and an organization, defining how the end-user 
                        should ideally use the API’s services. These terms should include API limits under best practices, 
                        with terms and conditions. Constraints also need to be clearly stated so that end-users understand 
                        what API usage and practices are permitted, so they don’t accidentally have their access restricted.</li>
                        <li><strong>A Changelog: </strong>A changelog is a document, usually published on an APIs website, that should detail 
                        updates and versions of an API and how it might affect API end-users. This will help end-users know 
                        the stability of the API and see if any changes need to be made to their integration with the API.</li>
                        <li><strong>Less Technical Jargon:</strong> Keep in mind that many end-users working with an API may not have intimate
                        knowledge of the domain to 
                        understand technical jargon. Documentation should cater to the “very technical” developer audience and 
                        the less technical decision-makers. A big mistake technical writing teams make is assuming their
                        audience is entirely technical and has a complete understanding of how to work with APIs. If an API 
                        does have technical or domain-specific jargon, it is helpful to link those specific items to further 
                        documentation explaining the terms.</li>
                        <li><strong>Examples of all Requests and Responses:</strong>
                        An API call response is a guide for end-users, indicating whether they’re on the right track or are 
                        doing something wrong. An API end-user should know exactly what to expect from a successful API call. 
                        Ideally, an API provides examples for every single object it is supposed to return and examples of 
                        parameters that end-users can add for a successful call.</li>
                        It is also best to describe the entire sample response body in every supported format. Think of 
                        standard formats like XML or JSON, but also HTTP headers, error codes, and messages.</li>
                        <li><strong>An Authentication Guide:</strong> An API’s documentation should have a section dedicated to any 
                        authentication (if it exists) required to start consuming the API’s data. Most APIs have 
                        authentication schemes, and end-users have to authenticate before gaining access to the API. 
                        Make sure this section is adequately documented and hand-holds end-users to authenticate against 
                        the API successfully.</li>
                    </ul>
                    <li><strong>Arm Documentation with Resources:</strong> Excellent API documentation goes beyond the essential content 
                    and ensures end-users reach success with an API as quickly as possible. Let’s examine some potential 
                    candidates for resources to include in the documentation.</li>
                    <ul>
                        <li><strong>A Getting Started Guide:</strong> The getting started guide provides a detailed account of how to start 
                        working with the API quickly. The emphasis in the guide should be on ensuring end-users reach success
                        with the API as soon as possible, hand-holding them throughout the journey.</li>
                        <li><strong>SDKs and Libraries:</strong>
                        Code libraries help developers quickly call different resources. Having quick and easy methods 
                        in different languages to work with an API allows developers to feel more comfortable working with 
                        it. Software Development Kits (SDKs) - a set of libraries or tools that end-users can work with out 
                        of the box, are challenging to build, and aren’t crucial for launch, but can significantly improve 
                        API adoption.</li>
                        <li><strong>A Interactive Console:</strong>
                        One way to encourage end-users to test what they read in the API documentation immediately, is to 
                        provide an interactive API console. Experimentation is powerful, and a console makes getting started 
                        easy, with limited liability from the end-users perspective. An interactive console can go a long way 
                        in helping developers learn about an API’s value very quickly.</li>
                    </ul>
                </ul>
                <hr/>
            </div>
            <ul>
                <li><strong>Developing the API: </strong>
                Once the requirements are mapped out and the engineering team has a plan, the development stage 
                begins. This stage focuses on implementing the API based on the plan and design and is when 
                engineering teams will do the necessary work to bring the API to life.
                Typically this is also where the API is documented.
                In a few cases, coding before designing can be acceptable, like if the API will only be consumed by the team or 
                company building it - this is especially true if the API developed is small, with only a few endpoints 
                being used internally.</li>
                <li><strong>Testing the API: </strong>
                In the testing phase, the API would be thoroughly tested and monitored for performance issues. 
                This phase typically catches any issues so that engineering teams can refine the API before it is 
                released to the end-users (sometimes referred to as end-consumers). </li>
                <li><strong>Deploying and Managing the API: </strong>
                Ultimately, APIs must satisfy a use case for an end consumer, be it an internal developer team, 
                a partner company, or the general public. After the testing phase, APIs are ready for release and 
                are deployed to a secure environment to facilitate easy discovery and consumption.
                On some occasions, mainly when APIs are public-facing, APIs are released into beta where end-users 
                (sometimes only a small percentage) can test and experiment with the API and give feedback and report
                bugs. The beta helps finalize any outstanding issues as well as gain valuable feedback before a full API release.</li>
                <li><strong>Retiring the API: </strong>
                Lastly, the final phase of the API lifecycle is deprecation. This phase is where support for an API’s 
                version, or in many cases, an entire API itself, is discontinued.
                Deprecation involves creating a detailed plan on migrating users away from the API and releasing the 
                APIs resources. Deprecation needs to be handled with extreme care as it may impact many end-users and 
                associated products that utilize the API.</li>
            </ul>
            <hr/>
            <ul>
                <h3>OpenAPI</h3>
                <li><strong>OpenAPI Specification (OAS)</strong> is one of the most popular standards for designing human-readable 
                API contracts. The OAS specifies the rules and syntax required to describe an API’s interface. The OAS has evolved to meet the 
                needs of modern API teams and continues to introduce updates to make the specification simpler to use and easier 
                for humans and computers to understand.
                Here is the general structure of an OAS defined API contract using OAS 3.0:</li>
                <ul>
                    <li><strong>Info & OpenAPI: </strong>
                    The info and openapi section of the API contract contains essential metadata. There are both required 
                    and optional fields such as contact information, license information, terms of service links, and more! 
                    Essentially, the info object should give an API’s end-users and internal developers a high-level overview 
                    of what the API does. 
                    More about <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object" target="_blank">here</a>.</li>
                    <p class="center"><strong>More About</strong></p>
                    <button id="showCode60" onclick="showCode('displayCode60', 'showCode60')">Display</button>                   
                    <div id="displayCode60">
                        <button onclick="closeCode('displayCode60', 'showCode60')">Close</button>
                        <pre>
                            <code>
                    openapi: 3.0.0
                    info:
                    title: Simple Pet Store
                    version: 1.0.0
                    description: This is a sample server for a pet store.
                    termsOfService: http://example.com/terms/
                    contact:
                        name: API Blogger
                        email: support@example.com
                        url: http://example.com/support
                    license:
                        name: Apache 2.0
                        url: http://www.apache.org/licenses/LICENSE-2.0.html
                            </code>
                        </pre>
                    </div>
                    <li><strong>Servers: </strong>
                    An API is a contract between the end-user and a server (usually the server hosting the API). The servers 
                    object can give a client information on where the API’s servers are located through its URL. Unlike the 
                    2.0 version of the spec, which only allowed an API definition to have one server URL, OAS 3.0 supports 
                    multiple servers. This is useful since, in the real world, APIs exist in numerous environments, and each 
                    environment can have its own purpose.
                    More about <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#info-object" target="_blank">here</a>.</li>
                    <p class="center"><strong>More About</strong></p>
                    <button id="showCode61" onclick="showCode('displayCode61', 'showCode61')">Display</button>                   
                    <div id="displayCode61">
                        <button onclick="closeCode('displayCode61', 'showCode61')">Close</button>
                        <pre>
                            <code>
            servers:
            - url: https://development.gigantic-server.com/v1
                description: Development server
            - url: https://staging.gigantic-server.com/v1
                description: Staging server
            - url: https://api.gigantic-server.com/v1
                description: Production server
                            </code>
                        </pre>
                    </div>
                    <li><strong>Paths: </strong>
                    An OAS contract’s paths object shows the various endpoints an API exposes and the corresponding HTTP 
                    methods. It’s also under each method that the actual request-response cycle is detailed. The requests are 
                    described by parameter objects and the responses by the responses objects. This section gives all parties 
                    a clear sense of the data the API will expose and helps with planning, documenting, and implementing the API.
                    More about <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#paths-object" target="_blank">here</a>.</li>
                    <p class="center"><strong>More About</strong></p>
                    <button id="showCode62" onclick="showCode('displayCode62', 'showCode62')">Display</button>                   
                    <div id="displayCode62">
                        <button onclick="closeCode('displayCode62', 'showCode62')">Close</button>
                        <pre>
                            <code>
                        paths:
                            /pet/{petId}:
                            get:
                                summary: Find pet by ID
                                description: Returns a single pet
                                parameters:
                                - name: petId
                                in: path
                                description: ID of pet to return
                                required: true
                                schema:
                                    type: integer
                                    format: int64
                                responses:
                                200:
                                    description: successful operation
                                400:
                                    description: Invalid ID supplied
                                    content: {}
                                404:
                                    description: Pet not found
                                    content: {}
                            </code>
                        </pre>
                        <li>Notice two critical parts of the defined path:</li>
                        <ul>
                            <li>Parameters: Parameters are the variable parts of a request. There are four types of parameters that can 
                            be specified using the OAS 3.0:</li>
                            <ul>
                                <li><strong>path parameters</strong>, such as /users/{id}</li>
                                <li><strong>query parameters</strong>, such as /users?role=admin</li>
                                <li><strong>header parameters</strong>, such as X-MyHeader: Value</li>
                                <li><strong>cookie parameters</strong>, which are passed in the Cookie header, such as Cookie: debug=0; 
                                csrftoken=BUSe35dohU3O1MZvDCU</li>
                            </ul>
                            <li>Responses: Responses are the objects returned on a request. Every response is defined by its HTTP 
                            status code, and the data is returned. The HTTP status codes are used to define whether the 
                            request was successful or unsuccessful.</li>
                        </ul> 
                    </div>
                    <li><strong>External Docs: </strong>
                    Any additional information that an API can offer to ease consumption and integration with the API is 
                    always a good idea. OAS 3.0 allows an API to reference external documentation via the external 
                    documentation object.
                    More about <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#externalDocumentationObject" target="_blank">here</a>.</li> 
                    <p class="center"><strong>More About</strong></p>
                    <button id="showCode63" onclick="showCode('displayCode63', 'showCode63')">Display</button>                   
                    <div id="displayCode63">
                        <button onclick="closeCode('displayCode63', 'showCode63')">Close</button>
                        <pre>
                            <code>
                    description: Find more info here
                    url: https://example.com
                            </code>
                        </pre>
                    </div>
                    <li><strong>Tags: </strong>
                    Tags are friendly categories to group various API operations. This allows end-users of the API to better 
                    segment and identify what they want to use the API for. These tags can also be handled by other 
                    third-party tools which integrate or read the OAS.   
                    Tags can automatically be added to every path operation using the tags object. Tags can also be given 
                    descriptions by adding an optional tags section in the root level of the API definition.</li> 
                    <p class="center"><strong>More About</strong></p>
                    <button id="showCode64" onclick="showCode('displayCode64', 'showCode64')">Display</button>                   
                    <div id="displayCode64">
                        <button onclick="closeCode('displayCode64', 'showCode64')">Close</button>
                        <pre>
                            <code>
                    paths:
                        /pet/findByStatus:
                            get:
                            summary: Finds pets by Status
                            tags:
                                - pets
                        /pet:
                            post:
                            summary: Adds a new pet to the store
                            tags:
                                - pets
                    tags:
                    - name: pets
                    description: Everything about your Pets
                            </code>
                        </pre>
                    </div>
                    <li><strong>Components: </strong>
                    As an API needs to expose more resources and operations, the contract can tend to get really long. 
                    The API may repeat a lot of existing parameters or response descriptions in many different paths and 
                    operations, and rewriting them every time makes them prone to inconsistent descriptions and can be very 
                    time-consuming. 
                    The component object can hold a set of reusable objects for an APIs design. The reusable objects can be 
                    schemas, responses, parameters, examples, and more. The exact reusable component can then be referenced 
                    in any path item.</li> 
                    <p class="center"><strong>More About</strong></p>
                    <button id="showCode65" onclick="showCode('displayCode65', 'showCode65')">Display</button>                   
                    <div id="displayCode65">
                        <button onclick="closeCode('displayCode65', 'showCode65')">Close</button>
                        <pre>
                            <code>
                paths:
                    /pets/{petId}:
                        get:
                        summary: Get a pet by ID
                        parameters:
                            ...
                        responses:
                            '200':
                            description: A single pet.
                            content:
                                application/json:
                                schema:
                                    $ref: '#/components/schemas/Pet'
                    /pets:
                        get:
                        summary: Get all pets
                        responses:
                            '200':
                            description: A list of pets.
                            content:
                                application/json:
                                schema:
                                    type: array
                                    items:
                                    $ref: '#/components/schemas/Pet'
                components:
                    schemas:
                        Pet:
                        type: object
                        properties:
                            id:
                            type: integer
                            name:
                            type: string
                            </code>
                        </pre>
                    </div>
                </ul>
                <hr/>
                <h3>Swagger</h3>

                <li><strong>Swagger</strong> refers to the toolkit used for designing, building, and documenting APIs,    
                while <strong>OpenAPI</strong> refers 
                to the open-source definition format used with Swagger. Previously, Swagger was also the name of the 
                definition format, but the newest version changed the name to OpenAPI and changed the structure of the 
                format to be easier to use.
                The <strong>Swagger Editor</strong> is used to design the API specification, while <strong>Swagger CodeGen</strong>
                is used to generate code based on the created specification. <strong>Swagger UI</strong> allows anyone 
                to easily view the specification details in an easy-to-read way. Access them all <a href="https://swagger.io/tools/" target="_blank">here</a>
                We can also clone Swagger from github and use it <a href="https://github.com/swagger-api/swagger-editor" target="_blank">here</a>.</li>
                <ul>
                    <li>Complete tutorial <a href="https://static-assets.codecademy.com/Courses/Swagger-OpenAPI/orders_project_finished.zip" target="_blank">here</a>.</li>
                </ul>
            </ul>
        </div>
        <div class="styleGuide">
            <h2>Deploying Fullstack Web Applications</h2>
            <ul>
                <li><strong>Heroku</strong> is a cloud-based Platform as a Service (PaaS) that enables developers to get an 
                app up and running quickly, without the hassle of setting up a server.
                With Heroku, we don’t need a dedicated DevOps team. We can allow engineers to focus on 
                building the best user experience for our customers, and the same idea (scaled down) also 
                makes it valuable to a single developer, or small team of developers - more time spent 
                building the app, less time spent configuring the deployment (right now Heroku became
                non-free, but there's a free plan with limitations). Heroku is very useful for a
                MVP for example. Here are some disavantages:</li>
                <ul>
                    <li><strong>Scalability:</strong> Heroku offers easy scaling options, but this can become expensive for 
                    high-traffic applications. If you anticipate high levels of traffic, you may want to 
                    consider other options that offer more cost-effective scaling options.</li>
                    <li><strong>Customizability:</strong> Heroku offers a flexible platform that supports a wide range of 
                    programming languages and frameworks, but this flexibility comes at a cost of 
                    customizability. If you need more control over the underlying infrastructure, you may 
                    want to consider other hosting options.</li>
                    <li><strong>Security:</strong> Heroku offers a range of security features, including SSL encryption, 
                    access controls, and intrusion detection. However, you are responsible for securing 
                    your own application code and data.</li>
                    <li><strong>Cost:</strong> Heroku's pricing model can be cost-effective for small and medium-sized 
                    applications, but it can become expensive for large applications with high levels 
                    of traffic. You may want to consider other options if you need to keep costs low.</li>
                </ul>
            </ul>
        </div>
    </body>
</html>